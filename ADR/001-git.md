# 001-git

## GIT

### Introduction
Ce document décrit les conventions et bonnes pratiques Git à suivre pour contribuer au projet.
L’objectif est de maintenir un historique de code clair, compréhensible et facile à maintenir.

### Nommage des commits
Nous utilisons la convention [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) pour structurer nos messages de commit.
Cette convention permet de standardiser les messages et facilite la génération automatique de changelogs.

#### Format d'un message de commit

`type(périmètre): détails`

1. Type (obligatoire)
Il correspond à l'un des éléments dans la première colonne du tableau ci-dessous

| Type       | Description                                                                 |
|------------|-----------------------------------------------------------------------------|
| `feat`     | Ajout d’une nouvelle fonctionnalité                                         |
| `fix`      | Correction d’un bug                                                         |
| `docs`     | Modification de la documentation                                            |
| `style`    | Changements de style (formatage, points-virgules manquants, etc.)           |
| `refactor` | Refactorisation de code (sans ajout de fonctionnalité ni correction de bug) |
| `perf`     | Amélioration des performances                                               |
| `test`     | Ajout ou modification de tests                                              |
| `chore`    | Changements de configuration ou de maintenance                              |

2. Périmètre (conseillé)

Le périmètre (ou *scope*) permet de préciser la partie du projet concernée par le commit.
Il s’agit généralement d’un nom de module, de composant, de page ou de fonctionnalité.

Bonnes pratiques :
- Précis : utiliser un nom court et explicite (ex: auth, backOffice, api, collectStep, CI, ...).
- Cohérent : respecter la même nomenclature que celle utilisée dans le code ou la documentation du projet.
- Optionnel : si le commit concerne l’ensemble du projet ou qu’aucun scope précis ne s’applique, il peut être omis.

Pourquoi préciser le périmètre ?
- Recherche facilitée : permet de filtrer rapidement les commits liés à une partie spécifique du projet.
- Contexte clair : aide les autres développeuses et développeurs à comprendre immédiatement où les changements ont été appliqués.

3. Détails (obligatoire)

C'est ici qu'on indique les modifications apportées.
On rédige en anglais et au présent de l'indicatif.
✅ `feat: add something`
❌ `feat: adding something`

Ce formatage apporte plusieurs avantages clés pour le projet :

- **Lisibilité :** Les messages de commit sont structurés et faciles à comprendre pour toute l’équipe.
- **Automatisation :** Permet de générer automatiquement des changelogs et des notes de version.
- **Traçabilité :** Facilite le suivi des évolutions (fonctionnalités, corrections, etc.) dans l’historique Git.
- **Standardisation :** Uniformise les contributions, ce qui est particulièrement utile pour les projets collaboratifs ou open source.
- **Intégration :** Compatible avec de nombreux outils (commitizen, semantic-release, etc.) pour optimiser le workflow de développement.
- **Clarté :** Les messages de commit sont plus lisibles et informatifs.
- **Automatisation :** Facilite la génération de changelogs et la gestion des versions.
- **Collaboration :** Standardise les contributions de toute l’équipe.

Un bon message de commit devient ainsi un outil de documentation à part entière 

#### Exemples
- feat(backOffice): implement user profile page
- fix(collectStep): proposals not loading
- docs: update project README
- style: format javascript files
- fix(api): handle 404 error for missing resources
- refactor(auth): simplify token validation logic

##### Important
Dans GitHub, c'est le titre de la PR qui sera utilisé comme message de commit au moment du squash merge.
C'est donc l'endroit où il faut penser à respecter la convention afin de conserver un historique correctement formatté.