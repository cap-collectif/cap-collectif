"""An association."""
type APIEnterpriseAssociation {
  """Siren."""
  siren: String

  """Corporate name."""
  corporateName: String!

  """Corporate address."""
  corporateAddress: String!

  """Authorization URL."""
  legalRepresentative: String

  """The quality of the legal representative."""
  qualityRepresentative: String

  """The RIB of the enterprise."""
  availableSirenSituation: Boolean
}

"""Doc associated with the association."""
type APIEnterpriseDocuments {
  """Composition of the administration committee"""
  availableCompositionCA: Boolean

  """The RIB of the association"""
  availableStatus: Boolean

  """The RIB of the association"""
  availablePrefectureReceiptConfirm: Boolean

  """The RIB of the association"""
  availableFiscalRegulationAttestation: Boolean

  """The RIB of the association"""
  availableSocialRegulationAttestation: Boolean

  """The KBIS file of the enterprise"""
  availableKbis: Boolean
}

"""An enterprise."""
type APIEnterpriseEnterprise {
  """Siren."""
  siren: String

  """Corporate name."""
  corporateName: String!

  """Corporate address."""
  corporateAddress: String!

  """Authorization URL."""
  legalRepresentative: String

  """The quality of the legal representative."""
  qualityRepresentative: String

  """The RIB of the enterprise."""
  availableSirenSituation: Boolean

  """The RIB of the association"""
  availableTurnover: Boolean
}

"""A public organization."""
type APIEnterprisePublicOrganization {
  """Siren."""
  siren: String

  """Corporate name."""
  corporateName: String!

  """Corporate address."""
  corporateAddress: String!

  """Authorization URL."""
  legalRepresentative: String

  """The quality of the legal representative."""
  qualityRepresentative: String

  """The RIB of the enterprise."""
  availableSirenSituation: Boolean
}

union APIEnterpriseResult = APIEnterpriseAssociation | APIEnterprisePublicOrganization | APIEnterpriseEnterprise

"""Type of API Enterprise return"""
enum APIEnterpriseType {
  """Association"""
  ASSOC

  """Enterprise"""
  ENTER

  """Public Organization"""
  PUB_ORGA
}

"""An abstract debate argument."""
interface AbstractDebateArgument {
  """The ID of an object."""
  id: ID!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """True if the viewer has reported the argument."""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The url of the debate"""
  url: URI!

  """The content of the argument."""
  body: String!

  """The debate related to the argument."""
  debate: Debate!

  """Whether the argument is for or against."""
  type: ForOrAgainstValue!

  """IP of the author"""
  ipAddress: IP

  """The origin of a debate's argument"""
  origin: ContributionOrigin!

  """The URL of widget from which the debate's argument was added, if any."""
  widgetOriginUrl: URI

  """The formatted geolocalization informations."""
  geoip: FormattedGeolocalization

  """True if the viewer has upvoted the argument."""
  viewerHasVote: Boolean!

  """The upvotes on the argument."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Order by."""
    orderBy: DebateArgumentVoteOrder = {field: PUBLISHED_AT, direction: DESC}
  ): DebateArgumentVoteConnection!
}

"""An abstract debate vote."""
interface AbstractDebateVote {
  """The ID of an object"""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """Whether or not the vote is published."""
  published: Boolean!

  """The date when the vote was published at."""
  publishedAt: DateTime

  """The value of the vote."""
  type: ForOrAgainstValue!

  """The debate of the vote."""
  debate: Debate!

  """IP of the voter"""
  ipAddress: IP

  """The origin of a debate's vote"""
  origin: ContributionOrigin!

  """The URL of widget from which the debate's vote was added, if any."""
  widgetOriginUrl: URI
}

input AddArgumentInput {
  """The Argumentable ID to argue."""
  argumentableId: ID!

  """The contents of the argument body."""
  body: String!

  """The type of the argument."""
  type: ArgumentValue!
  clientMutationId: String
}

type AddArgumentPayload {
  """The newly created argument."""
  argument: Argument

  """The edge from the argumentable's arguments connection."""
  argumentEdge: ArgumentEdge

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input AddArgumentVoteInput {
  """The Node ID of the argument to vote."""
  argumentId: ID!
  clientMutationId: String
}

type AddArgumentVotePayload {
  voteEdge: ArgumentVoteEdge
  viewer: User!
  clientMutationId: String
}

input AddCommentInput {
  """The Commentable ID of the subject to comment."""
  commentableId: ID!

  """The contents of the comment."""
  body: String!
  authorName: String
  authorEmail: String
  clientMutationId: String
}

type AddCommentPayload {
  """The edge from the commentable's comment connection."""
  commentEdge: CommentEdge

  """The commentable."""
  commentable: Commentable

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input AddCommentVoteInput {
  """The Node ID of the comment to vote."""
  commentId: ID!
  clientMutationId: String
}

type AddCommentVotePayload {
  voteEdge: CommentVoteEdge
  viewer: User!
  clientMutationId: String
}

input AddContactFormInput {
  """Email of the interlocutor of the contact form."""
  email: String!
  translations: [ContactFormTranslationInput!]!
  clientMutationId: String
}

type AddContactFormPayload {
  """The contact form created."""
  contactForm: ContactForm!
  clientMutationId: String
}

"""Available errors for an `addDebateAnonymousVote` mutation."""
enum AddDebateAnonymousVoteErrorCode {
  """No `Debate` match your `debateId`."""
  UNKNOWN_DEBATE

  """The debate is closed and be voted."""
  CLOSED_DEBATE

  """The given captcha is invalid."""
  INVALID_CAPTCHA
}

input AddDebateAnonymousVoteInput {
  """The Node ID of the `Debate` to vote on."""
  debateId: ID!

  """Whether the vote will be `FOR` or `AGAINST`."""
  type: ForOrAgainstValue!

  """The captcha verification."""
  captcha: String!

  """The URL of widget from which the debate's argument was added, if any."""
  widgetOriginURI: URI = null
  clientMutationId: String
}

type AddDebateAnonymousVotePayload {
  """The token of the newly created anonymous vote."""
  token: String

  """The newly created anonymous vote."""
  debateAnonymousVote: DebateAnonymousVote

  """An unsuccessful mutation will return an error."""
  errorCode: AddDebateAnonymousVoteErrorCode
  clientMutationId: String
}

"""Available errors for an `addDebateArgumentVote` mutation."""
enum AddDebateArgumentVoteErrorCode {
  """No `DebateArgument` match your id."""
  UNKNOWN_DEBATE_ARGUMENT

  """The debate is closed and arguments cannot be voted for."""
  CLOSED_DEBATE

  """Viewer has already voted for this argument."""
  ALREADY_VOTED
}

input AddDebateArgumentVoteInput {
  """The id of the `DebateArgument` to vote for."""
  debateArgumentId: ID!

  """The URL of widget from which the debate's argument was added, if any."""
  widgetOriginURI: URI = null
  clientMutationId: String
}

type AddDebateArgumentVotePayload {
  """The argument that had just been upvoted."""
  debateArgument: AbstractDebateArgument

  """The vote just added."""
  debateArgumentVote: DebateArgumentVote

  """An unsuccessful mutation will return an error."""
  errorCode: AddDebateArgumentVoteErrorCode
  clientMutationId: String
}

"""Available errors for an `addDebateOpinion` mutation."""
enum AddDebateOpinionErrorCode {
  """No `Debate` match your `debateId`."""
  UNKNOWN_DEBATE

  """The provided values are not valid."""
  INVALID_FORM
}

input AddDebateOpinionInput {
  """The Node ID of the `Debate` where the opinion belongs."""
  debateId: ID!

  """The title value of the opinion."""
  title: String!

  """The body value of the opinion."""
  body: HTML!

  """The Node ID of a `User`. The author of the opinion."""
  author: ID!

  """Whether the opinion will be `FOR` or `AGAINST`."""
  type: ForOrAgainstValue!
  clientMutationId: String
}

type AddDebateOpinionPayload {
  """The newly created opinion."""
  debateOpinion: DebateOpinion

  """An unsuccessful mutation will return an error."""
  errorCode: AddDebateOpinionErrorCode
  clientMutationId: String
}

"""Available errors for an `addDebateVote` mutation."""
enum AddDebateVoteErrorCode {
  """No `Debate` match your `debateId`."""
  UNKNOWN_DEBATE

  """The debate is closed and be voted."""
  CLOSED_DEBATE
}

input AddDebateVoteInput {
  """The Node ID of the `Debate` to vote on."""
  debateId: ID!

  """Whether the vote will be `FOR` or `AGAINST`."""
  type: ForOrAgainstValue!

  """The URL of widget from which the debate's vote was added, if any."""
  widgetOriginURI: URI = null
  clientMutationId: String
}

type AddDebateVotePayload {
  """The newly created Vote."""
  debateVote: DebateVote

  """If there was an existing vote, the id of the remove vote."""
  previousVoteId: ID

  """An unsuccessful mutation will return an error."""
  errorCode: AddDebateVoteErrorCode
  clientMutationId: String
}

input AddEventInput {
  """When the event start."""
  startAt: DateTime!

  """When the event end."""
  endAt: DateTime
  translations: [EventTranslationInput!]!
  clientMutationId: String

  """Whether or not this event is published."""
  enabled: Boolean = true

  """The media to illustrate the event."""
  media: ID

  """Whether or not this event is commentable."""
  commentable: Boolean = true

  """The contents of the event addressJson."""
  addressJson: String

  """The contents of the event customCode."""
  customCode: String

  """An array of Node IDs of projects associated to this event."""
  projects: [ID]

  """An array of Node IDs of themes associated to this event."""
  themes: [ID]

  """Whether or not this event is allow registrations."""
  guestListEnabled: Boolean! = false

  """The Node ID of the author for this event."""
  author: ID

  """Author of event agree to use personal data for event only"""
  authorAgreeToUsePersonalDataForEventOnly: Boolean

  """Admin authorize data transfer"""
  adminAuthorizeDataTransfer: Boolean

  """An array of Node IDs of steps associated to this event."""
  steps: [ID!]

  """Is the event presential or remotely accessible"""
  isPresential: Boolean

  """Should the event be recorded or not"""
  isRecordingPublished: Boolean

  """The Node ID of the animator for this event if there is one."""
  animator: ID
}

type AddEventPayload {
  """The edge from the events connection."""
  eventEdge: EventEdge

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input AddEventsInput {
  """A list of events input to import."""
  events: [EventInput!]!

  """
  This option is useful if you want to test your import. Set it to true if you want to import definitively.
  """
  dryRun: Boolean!
  clientMutationId: String
}

type AddEventsPayload {
  """List of imported events."""
  importedEvents: [Event!]!

  """List of emails that didn't match an existing user."""
  notFoundEmails: [Email]!

  """List of themes ID that didn't match an existing themes."""
  notFoundThemes: [ID]!

  """List of dates that didn't got the good format"""
  brokenDates: [String]!
  clientMutationId: String
}

input AddOpinionVoteInput {
  """The Node ID of the opinion/version to vote."""
  opinionId: ID!

  """The vote value."""
  value: YesNoPairedVoteValue!
  clientMutationId: String
}

type AddOpinionVotePayload {
  vote: YesNoPairedVote
  voteEdge: YesNoPairedVoteEdge
  viewer: User!
  previousVoteId: ID
  clientMutationId: String
}

input AddProposalNewsInput {
  """The Node ID of the proposal to add news."""
  proposalId: ID!
  translations: [NewsTranslationInput!]!

  """Current media id"""
  media: ID
  clientMutationId: String
}

type AddProposalNewsPayload {
  """The new post."""
  proposalPost: Post

  """An unsuccessful mutation will return an error message"""
  errorCode: ProposalNewsErrorCode

  """the proposal attached to the news"""
  proposal: Proposal

  """the URL of proposalNews posted"""
  postURL: URI
  clientMutationId: String
}

input AddProposalVoteInput {
  """The Node ID of the proposal to vote."""
  proposalId: ID!

  """The Node ID of the step."""
  stepId: ID!

  """The vote will be anonymous."""
  anonymously: Boolean = false
  clientMutationId: String
}

type AddProposalVotePayload {
  vote: ProposalVote!
  viewer: User!
  voteEdge: ProposalVoteEdge!
  clientMutationId: String
}

input AddProposalsFromCsvInput {
  """The id of the form form proposal"""
  proposalFormId: ID!

  """The ID of csv file uploaded to import"""
  csvToImport: ID!

  """
  This option is useful if you want to test your import. Set it to false if you want to import definitively.
  """
  dryRun: Boolean! = true

  """the char mark to delimit column in csv"""
  delimiter: String = ";"
  clientMutationId: String
}

type AddProposalsFromCsvPayload {
  """List of imported proposals."""
  importedProposals: ProposalConnection

  """List of bad lines."""
  badLines: [Int]!

  """Number of doubloon"""
  duplicates: [Int]!

  """Lines with missing data mandatory"""
  mandatoryMissing: [Int]!

  """code of error"""
  errorCode: ProposalImportsErrorCode

  """Number of importable proposals."""
  importableProposals: Int!
  clientMutationId: String
}

"""Available errors on step assignment of proposals"""
enum AddProposalsToStepsErrorCode {
  """No proposal match your id"""
  NO_VALID_PROPOSAL

  """No step match your id or it does not fit the selected proposals"""
  NO_VALID_STEP
}

input AddProposalsToStepsInput {
  """The ids of the proposals to add to steps"""
  proposalIds: [ID!]!

  """The ids of the steps to which proposals should be moved"""
  stepIds: [ID!]!
  clientMutationId: String
}

type AddProposalsToStepsPayload {
  """Connection of assigned proposals"""
  proposals: ProposalConnection

  """An unsuccessful mutation will return an error message"""
  error: AddProposalsToStepsErrorCode
  clientMutationId: String
}

"""Available errors for an `addReply` mutation."""
enum AddReplyErrorCode {
  """the viewer does not meet requirements"""
  REQUIREMENTS_NOT_MET
}

input AddReplyInput {
  """The id of the questionnaire"""
  questionnaireId: ID!

  """The responses to the questionnaire questions"""
  responses: [ResponseInput]

  """Anonymous or not."""
  private: Boolean

  """If true will create a draft reply."""
  draft: Boolean! = false
  clientMutationId: String
}

type AddReplyPayload {
  reply: Reply
  questionnaire: Questionnaire
  errorCode: AddReplyErrorCode
  clientMutationId: String
}

input AddSourceInput {
  """The Sourceable ID to source."""
  sourceableId: ID!

  """The contents of the source body."""
  body: String!

  """The category of the source."""
  category: ID!
  link: URI!
  title: String!
  clientMutationId: String
}

type AddSourcePayload {
  """The newly created source."""
  source: Source

  """The edge from the sourceable's sources connection."""
  sourceEdge: SourceEdge

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input AddSourceVoteInput {
  """The Node ID of the source to vote."""
  sourceId: ID!
  clientMutationId: String
}

type AddSourceVotePayload {
  voteEdge: SourceVoteEdge
  viewer: User!
  clientMutationId: String
}

input AddUsersInGroupInput {
  """Users that will be added to the group."""
  users: [ID!]!

  """The concerned group id."""
  groupId: ID!
  clientMutationId: String
}

type AddUsersInGroupPayload {
  group: Group!
  clientMutationId: String
}

input AddUsersToGroupFromEmailInput {
  """A list of email(s)."""
  emails: [Email!]!

  """
  This option is useful if you want to test your emails list. Set it to true if you want to import definitively.
  """
  dryRun: Boolean!

  """The Node ID of the group."""
  groupId: ID!
  clientMutationId: String
}

type AddUsersToGroupFromEmailPayload {
  """List of imported users."""
  importedUsers: [User]!

  """List of emails that didn't match an existing user."""
  notFoundEmails: [Email]!

  """
  If an email from your list is already associated to a user who is in the chosen group, it will be in this field.
  """
  alreadyImportedUsers: [User]!
  clientMutationId: String
}

input AddVersionInput {
  """The concerned opinion id."""
  opinionId: ID!
  title: String!
  body: String!
  comment: String
  clientMutationId: String
}

type AddVersionPayload {
  version: Version
  versionEdge: VersionEdge

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError]
  clientMutationId: String
}

"""Represent an aggregrated result that should be displayed in a chart"""
type AggregatedResult {
  """A unique key that distinguish one result from another"""
  key: String!

  """How many objects are associated to the key"""
  totalCount: Int!
}

input AnalyseProposalAnalysisInput {
  """The id of the proposal to analyse."""
  proposalId: ID!

  """The responses from the evaluation form."""
  responses: [ResponseInput!]!

  """The comment related to the analysis."""
  comment: String!
  clientMutationId: String

  """The analysis decision taken about the proposal"""
  decision: ProposalAnalysisDecision!
}

type AnalyseProposalAnalysisPayload {
  """The changed proposal analysis."""
  analysis: ProposalAnalysis

  """Contains the error code if one occurred."""
  errorCode: ProposalStatementErrorCode
  clientMutationId: String
}

"""An analysis configuration."""
type AnalysisConfiguration {
  """The ID of an object."""
  id: ID!

  """The related ProposalForm."""
  proposalForm: ProposalForm!

  """Activate cost estimation on evaluation form."""
  costEstimationEnabled: Boolean!

  """The evaluation form of the analysis"""
  evaluationForm: Questionnaire

  """The step on which the analysis is based on."""
  analysisStep: Step

  """The date on which the related decision will become effective"""
  effectiveDate: DateTime

  """Indicates whether or not a proposal decision is immediately effective"""
  isImmediatelyEffective: Boolean!

  """The available favourable statuses to apply on contributions."""
  favourableStatus: ProposalStepStatus

  """The unfavourable status to apply on contributions."""
  unfavourableStatuses: [ProposalStepStatus!]

  """The step to which proposals will be moved."""
  moveToSelectionStep: SelectionStep

  """The status to apply on next step."""
  selectionStepStatus: ProposalStepStatus

  """The creation date."""
  createdAt: DateTime!

  """The last update date."""
  updatedAt: DateTime

  """A text to explain the analysis process."""
  body: HTML

  """
  Indicates whether or not a proposal has been processed on effectiveDate
  """
  effectiveDateProcessed: Boolean
}

"""A contribution"""
type Answer {
  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """Identifies the contribution title."""
  title: String

  """Identifies the body of the contribution."""
  body: HTML
  author: User
}

union AnswerOrPost = Answer | Post

"""A contribution"""
type Appendix {
  """Identifies the body of the contribution."""
  body: HTML

  """Identifies the body of the contribution rendered to text."""
  bodyText: String
  appendixType: AppendixType!
}

"""A contribution"""
input AppendixInput {
  """Identifies the body of the contribution."""
  body: HTML
  appendixType: ID
}

"""An AppendixType"""
type AppendixType {
  title: String!
}

"""Available errors on status assignment of proposals"""
enum ApplyProposalStatusErrorCode {
  """No status match your id"""
  NO_VALID_STATUS

  """No proposal match your id or it does not fit the selected status"""
  NO_VALID_PROPOSAL
}

input ApplyProposalStatusInput {
  """The ids of the proposals to add to steps"""
  proposalIds: [ID!]!

  """
  The id of the status to apply or nothing if the status is to be removed
  """
  statusId: ID
  clientMutationId: String
}

type ApplyProposalStatusPayload {
  """Connection of assigned proposals"""
  proposals: ProposalConnection

  """An unsuccessful mutation will return an error message"""
  error: ApplyProposalStatusErrorCode
  clientMutationId: String
}

"""An argument"""
type Argument implements Node & Publishable & Contribution & Trashable & UniformResourceLocatable & Reportable & ContributionWithAuthor & EditableContribution {
  """The ID of an object."""
  id: ID!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The URL to this resource."""
  url: URI!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """The type."""
  type: ArgumentValue!

  """The content of the argument."""
  body: String!

  """Does the viewer already submitted a report ?"""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """The author of the contribution."""
  author: User!
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ArgumentVoteConnection!

  """The kind of contribution (argument)."""
  kind: String!
  viewerHasVote: Boolean!
  viewerVote: ArgumentVote
  contribuable: Boolean!
  step: ConsultationStep!
}

"""A connection to a list of items."""
type ArgumentConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ArgumentEdge]
}

"""An edge in a connection."""
type ArgumentEdge {
  """The item at the end of the edge."""
  node: Argument

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which argument connections can be ordered."""
input ArgumentOrder {
  """The field in which to order nodes by."""
  field: ArgumentOrderField!

  """The direction in which to order nodes."""
  direction: OrderDirection! = ASC
}

"""Properties by which argument connections can be ordered"""
enum ArgumentOrderField {
  """Allows ordering a list of arguments by when they were published."""
  PUBLISHED_AT

  """Allows ordering a list of arguments by the number of votes it have."""
  VOTES
}

"""Value of an argument"""
enum ArgumentValue {
  """AGAINST argument"""
  AGAINST

  """FOR argument"""
  FOR
}

"""A contribution with an author"""
type ArgumentVote implements Vote & Publishable & Contribution {
  """The ID of an object"""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution."""
  author: User

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Argument

  """Returns Type of vote"""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """Url of the contribution"""
  url: URI!
}

"""A connection to a list of items."""
type ArgumentVoteConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ArgumentVoteEdge]
}

"""An edge in a connection."""
type ArgumentVoteEdge {
  """The item at the end of the edge."""
  node: ArgumentVote

  """A cursor for use in pagination."""
  cursor: String!
}

"""An argumentable"""
interface Argumentable {
  """The ID of an object"""
  id: ID!
  contribuable: Boolean!

  """The arguments related to the argumentable."""
  arguments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ArgumentOrder = {field: PUBLISHED_AT, direction: DESC}

    """If provided, returns the arguments of this particular type."""
    type: ArgumentValue

    """The connection will return the trashed results too."""
    includeTrashed: Boolean = false
  ): ArgumentConnection!

  """The unpublished arguments of to the viewer."""
  viewerArgumentsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """If provided, returns the arguments of this particular type."""
    type: ArgumentValue
  ): ArgumentConnection
}

"""Available errors on proposal related mutations."""
enum AskProposalRevisionErrorCode {
  """The given proposal does not exist."""
  NON_EXISTING_PROPOSAL

  """The provided values are not valid."""
  INVALID_FORM
}

input AskProposalRevisionInput {
  """The id of the proposal to be revised."""
  proposalId: ID!

  """The reason to revise the propose"""
  reason: String!

  """The datetime when revision expire"""
  expiresAt: DateTime!

  """The information to resolve revision"""
  body: HTML!
  clientMutationId: String
}

type AskProposalRevisionPayload {
  """The proposal"""
  proposal: Proposal

  """Contains the error code if one occurred."""
  errorCode: AskProposalRevisionErrorCode
  clientMutationId: String
}

input AssignAnalystsToProposalsInput {
  """Assign analyst list to a list of proposals."""
  proposalIds: [ID!]!

  """The concerned list of analysts"""
  analystIds: [ID!]!
  clientMutationId: String
}

type AssignAnalystsToProposalsPayload {
  """Connection of assigned proposals"""
  proposals: ProposalConnection

  """Contains the error code if one occurred."""
  errorCode: ProposalAssignmentErrorCode
  viewer: User!
  clientMutationId: String
}

input AssignDecisionMakerToProposalsInput {
  """Assign a decision maker to a list of proposals."""
  proposalIds: [ID!]!

  """The concerned decision maker id."""
  decisionMakerId: ID
  clientMutationId: String
}

type AssignDecisionMakerToProposalsPayload {
  """Connection of assigned proposals"""
  proposals: ProposalConnection

  """Contains the error code if one occurred."""
  errorCode: ProposalAssignmentErrorCode
  clientMutationId: String
}

input AssignSupervisorToProposalsInput {
  """Assign a supervisor to a list of proposals."""
  proposalIds: [ID!]!

  """The concerned supervisor id."""
  supervisorId: ID
  clientMutationId: String
}

type AssignSupervisorToProposalsPayload {
  """Connection of assigned proposals"""
  proposals: ProposalConnection

  """Contains the error code if one occurred."""
  errorCode: ProposalAssignmentErrorCode
  clientMutationId: String
}

"""The possible values for a proposal category color"""
enum AvailableProposalCategoryColor {
  COLOR_EF5350
  COLOR_B71C1C
  COLOR_880E4F
  COLOR_C2185B
  COLOR_9C27B0
  COLOR_6A1B9A
  COLOR_673AB7
  COLOR_3F51B5
  COLOR_0D47A1
  COLOR_1E88E5
  COLOR_0097A7
  COLOR_00796B
  COLOR_004D40
  COLOR_1B5E20
  COLOR_43A047
  COLOR_558B2F
  COLOR_827717
  COLOR_FFC107
  COLOR_FF9800
  COLOR_E65100
  COLOR_BF360C
  COLOR_795548
  COLOR_5D4037
  COLOR_3E2723
  COLOR_616161
  COLOR_78909C
  COLOR_455A64
  COLOR_263238
}

"""The possible values for a proposal category icon"""
enum AvailableProposalCategoryIcon {
  GAS_STATION
  BOAT
  EARTH
  TRAVEL
  PASSPORT
  ECONOMY
  PARKING
  COCKTAIL
  RESTAURANT
  FARMER_MARKET
  NETWORK
  MOBILE_PHONE
  COMPANY
  URBANISM
  VILLAGE
  CONSTRUCTION_CONE
  VEGETABLES_PLATE
  GROCERY_SHOPPING
  SHOPPING_BAG
  MEDICAL
  HOSPITAL
  HEALTH
  BICYCLE
  OFFICER
  SURVEILLANCE_CAMERA
  FAMILY_CHILDREN
  FAMILY_WALK_PARK
  FAMILY_CHILD_PLAY_BALL
  BASKETBALL_BALL
  DOG_LEASH
  WATER
  TREE
  PARK_BENCH_LIGHT
  RECYCLE
  BIN
  AGRICULTURE_MACHINE_TRACTOR
  HAND
  SOLIDARITY
  HIERARCHY
  ELDERLY
  PARAPLEGIC
  CAR
  CARPOOLING
  BUS_STATION
  RAILROAD_TRAIN
  BRIEFCASE
  BOOK_FLIP_PAGE
  CULTURE
  OFFICIAL_BUILDING
  GRADUATE
  LIGHT_BULB
  ENERGY
  ICN
  ECOLOGY_LEAF
}

"""Type of sso service"""
enum AvailableSso {
  """FranceConnect sso service"""
  FRANCE_CONNECT

  """Facebook sso service"""
  FACEBOOK
}

input BackgroundStyleInput {
  enabled: Boolean
  color: Color
  opacity: Float
}

input BorderStyleInput {
  enabled: Boolean
  color: Color
  opacity: Float
  size: Int
}

type CancelEmailChangePayload {
  """if it succeeded"""
  success: Boolean
  clientMutationId: String
}

"""Available errors when canceling a planned campaign"""
enum CancelEmailingCampaignErrorCode {
  """No campaign match your id"""
  ID_NOT_FOUND

  """The campaign cannot be canceled, it may not be planned"""
  CANNOT_BE_CANCELED
}

input CancelEmailingCampaignInput {
  """Global id of the planned campaign to cancel"""
  id: ID!
  clientMutationId: String
}

type CancelEmailingCampaignPayload {
  """The campaign cancelled"""
  emailingCampaign: EmailingCampaign

  """The error code, if any"""
  error: CancelEmailingCampaignErrorCode
  clientMutationId: String
}

input CancelUserInvitationsInput {
  """The list of invitations to cancel"""
  invitationsIds: [ID!]!
  clientMutationId: String
}

type CancelUserInvitationsPayload {
  """The cancelled invitations IDs"""
  cancelledInvitationsIds: [ID!]!
  clientMutationId: String
}

"""A category image"""
type CategoryImage {
  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!

  """The associated media of the site image"""
  image: Media

  """Is image a predefined image (true) or personalized image (false)"""
  isDefault: Boolean!
}

"""Ordering options for categories returned from the connection."""
enum CategoryOrderField {
  """Allows ordering a list of categories in an alphabetical order."""
  ALPHABETICAL
}

input ChangeArgumentInput {
  """The argument Node id."""
  argumentId: ID!

  """The contents of the argument body."""
  body: String!
  clientMutationId: String
}

type ChangeArgumentPayload {
  argument: Argument!
  clientMutationId: String
}

input ChangeCollectStatusInput {
  statusId: ID

  """The proposal id"""
  proposalId: ID!
  clientMutationId: String
}

type ChangeCollectStatusPayload {
  proposal: Proposal!
  clientMutationId: String
}

input ChangeDistrictInput {
  """The district id"""
  districtId: ID!
  geojson: GeoJSON
  displayedOnMap: Boolean
  name: String
  clientMutationId: String
}

type ChangeDistrictPayload {
  district: ProposalDistrict!
  clientMutationId: String
}

input ChangeEventInput {
  """When the event start."""
  startAt: DateTime!

  """When the event end."""
  endAt: DateTime
  translations: [EventTranslationInput!]!
  clientMutationId: String

  """Whether or not this event is published."""
  enabled: Boolean = true

  """The media to illustrate the event."""
  media: ID

  """Whether or not this event is commentable."""
  commentable: Boolean = true

  """The contents of the event addressJson."""
  addressJson: String

  """The contents of the event customCode."""
  customCode: String

  """An array of Node IDs of projects associated to this event."""
  projects: [ID]

  """An array of Node IDs of themes associated to this event."""
  themes: [ID]

  """Whether or not this event is allow registrations."""
  guestListEnabled: Boolean! = false

  """The Node ID of the author for this event."""
  author: ID

  """Author of event agree to use personal data for event only"""
  authorAgreeToUsePersonalDataForEventOnly: Boolean

  """Admin authorize data transfer"""
  adminAuthorizeDataTransfer: Boolean

  """An array of Node IDs of steps associated to this event."""
  steps: [ID!]

  """Is the event presential or remotely accessible"""
  isPresential: Boolean

  """Should the event be recorded or not"""
  isRecordingPublished: Boolean

  """The Node ID of the animator for this event if there is one."""
  animator: ID

  """The ID of the Event to modify."""
  id: ID!
}

type ChangeEventPayload {
  """The edge from the events connection."""
  event: Event

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input ChangeFontInput {
  """The new heading font ID."""
  heading: ID!

  """The new body font ID."""
  body: ID!
  clientMutationId: String
}

type ChangeFontPayload {
  """Return the available platform fonts."""
  fonts: [Font!]!
  headingFont: Font!
  bodyFont: Font!
  clientMutationId: String
}

input ChangeMapProviderTokenInput {
  """The name of the provider the new token will be set"""
  provider: MapTokenProvider!

  """The new public token"""
  publicToken: String

  """The new secret token"""
  secretToken: String
  clientMutationId: String
}

type ChangeMapProviderTokenPayload {
  """The newly map token"""
  mapToken: MapToken
  clientMutationId: String
}

input ChangeMapStyleInput {
  """The ID of the map token to modify the style"""
  mapTokenId: ID!

  """The new style owner"""
  styleOwner: String!

  """The new style ID"""
  styleId: ID!
  clientMutationId: String
}

type ChangeMapStylePayload {
  """The newly map token"""
  mapToken: MapToken
  clientMutationId: String
}

input ChangeProposalAnalysisInput {
  """The id of the proposal to analyse."""
  proposalId: ID!

  """The responses from the evaluation form."""
  responses: [ResponseInput!]!

  """The comment related to the analysis."""
  comment: String
  clientMutationId: String
}

type ChangeProposalAnalysisPayload {
  """The changed proposal analysis."""
  analysis: ProposalAnalysis

  """Contains the error code if one occurred."""
  errorCode: ProposalStatementErrorCode
  clientMutationId: String
}

input ChangeProposalAssessmentInput {
  """The id of the proposal to evaluate."""
  proposalId: ID!

  """The proposal assessment's body."""
  body: String

  """The estimated budget for the proposal."""
  estimatedCost: Int

  """The proposal assessment's official response."""
  officialResponse: String
  clientMutationId: String
}

type ChangeProposalAssessmentPayload {
  """The changed proposal assessment."""
  assessment: ProposalAssessment

  """Contains the error code if one occurred."""
  errorCode: ProposalStatementErrorCode
  clientMutationId: String
}

input ChangeProposalContentInput {
  """Link of Web page."""
  webPageUrl: URI

  """Link of Facebook page."""
  facebookUrl: URI

  """Link of Twitter page."""
  twitterUrl: URI

  """Link of Instagram page."""
  instagramUrl: URI

  """Link of LinkedIn profile."""
  linkedInUrl: URI

  """Link of Youtube channel."""
  youtubeUrl: URI

  """The proposal id"""
  id: ID!

  """
  Pass 'true' to keep your proposal in draft state, otherwise we admit that you want to publish it.
  """
  draft: Boolean

  """The new proposal title"""
  title: String

  """The new proposal body"""
  body: HTML

  """The new proposal summary"""
  summary: String

  """The author id (ROLE_SUPER_ADMIN allowed only)"""
  author: ID

  """The theme id (feature themes enabled)"""
  theme: String

  """The category id"""
  category: String

  """The district id (feature districts enabled)"""
  district: String

  """The address geocoded by google"""
  address: String

  """The custom fields responses"""
  responses: [ResponseInput]

  """Current media id"""
  media: ID

  """The ID of tipsmeee"""
  tipsmeeeId: String
  estimation: Float
  likers: [ID!]
  clientMutationId: String
}

type ChangeProposalContentPayload {
  proposal: Proposal!
  clientMutationId: String
}

input ChangeProposalDecisionInput {
  """The id of the proposal to evaluate."""
  proposalId: ID!

  """The proposal assessment's body."""
  body: String

  """The estimated budget for the proposal."""
  estimatedCost: Int

  """The official response related authors."""
  authors: [ID!]

  """The decision given for the proposal."""
  isApproved: Boolean

  """The status in the step to assign to the proposal"""
  refusedReason: ID

  """Is decision making complete."""
  isDone: Boolean
  clientMutationId: String
}

type ChangeProposalDecisionPayload {
  """The changed proposal decision."""
  decision: ProposalDecision

  """Contains the error code if one occurred."""
  errorCode: ProposalStatementErrorCode

  """The changed proposal."""
  proposal: Proposal

  """The changed post."""
  post: Post
  clientMutationId: String
}

input ChangeProposalNotationInput {
  """The proposal id"""
  proposalId: ID!
  estimation: Float
  likers: [ID!]
  clientMutationId: String
}

type ChangeProposalNotationPayload {
  proposal: Proposal!
  clientMutationId: String
}

input ChangeProposalProgressStepsInput {
  progressSteps: [ProgressStepInput!]!
  proposalId: String!
  clientMutationId: String
}

type ChangeProposalProgressStepsPayload {
  proposal: Proposal!
  clientMutationId: String
}

input ChangeProposalPublicationStatusInput {
  """The new publication status"""
  publicationStatus: ProposalPublicationStatus!

  """Added if you set publicationStatus to TRASHED"""
  trashedReason: String

  """The proposal id"""
  proposalId: ID!
  clientMutationId: String
}

type ChangeProposalPublicationStatusPayload {
  proposal: Proposal!
  clientMutationId: String
}

input ChangeSelectionStatusInput {
  stepId: ID!
  proposalId: ID!
  statusId: ID
  clientMutationId: String
}

type ChangeSelectionStatusPayload {
  proposal: Proposal!
  clientMutationId: String
}

input ChangeSiteFaviconInput {
  """The media id to associate for the website favicon"""
  mediaId: ID!
  clientMutationId: String
}

type ChangeSiteFaviconPayload {
  """The newly updated site image favicon"""
  siteFavicon: SiteImage!
  clientMutationId: String
}

input ChangeSourceInput {
  """The source id."""
  sourceId: ID!

  """The contents of the source body."""
  body: String

  """The contents of the source category."""
  category: ID

  """The contents of the source title."""
  title: String

  """The contents of the source link."""
  link: URI
  clientMutationId: String
}

type ChangeSourcePayload {
  source: Source
  clientMutationId: String
}

input ChangeUserNotificationsConfigurationInput {
  """The new proposal comment notification value"""
  onProposalCommentMail: Boolean!

  """The new external consent for communication"""
  consentExternalCommunication: Boolean!

  """The new internal consent for communication"""
  consentInternalCommunication: Boolean!
  clientMutationId: String
}

type ChangeUserNotificationsConfigurationPayload {
  user: User!
  clientMutationId: String
}

input ChangeVersionInput {
  """The version Node id."""
  versionId: ID!

  """Updated version body."""
  body: String

  """Updated version title."""
  title: String

  """Updated version comment."""
  comment: String
  clientMutationId: String
}

type ChangeVersionPayload {
  version: Version
  clientMutationId: String
}

"""Requires the viewer to check a box"""
type CheckboxRequirement implements Node & Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!

  """The condition set by the requirement."""
  label: String!
}

"""A proposal step"""
type CollectStep implements Node & Step & ProposalStep & RequirementStep {
  """The ID of an object."""
  id: ID!

  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI

  """A list of proposals associated to the object."""
  proposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    If non-null, filters proposals with the given trashed status (eg: visible, not visible).
    """
    trashedStatus: ProposalTrashedStatus = NOT_TRASHED

    """
    ID of a User to filter by. If non-null, only proposals authored by this user will be returned.
    """
    author: ID

    """Ordering options for proposals returned from the connection."""
    orderBy: ProposalOrder = {field: PUBLISHED_AT, direction: ASC}

    """(ROLE_ADMIN only) Select also draft proposals."""
    includeDraft: Boolean = false

    """
    The state of the proposals to filter by. If non-null, filters proposals with the given state.
    """
    state: ProposalsState

    """
    ID of a ProposalDistrict to filter by. If non-null, filters proposals with the given district.
    """
    district: ID

    """
    ID of a UserType to filter by. If non-null, filters proposals with the given type of author.
    """
    userType: ID

    """
    ID of a ProposalCategory to filter by. If non-null, filters proposals with the given category.
    """
    category: ID

    """
    ID of a ProposalStatus to filter by. If non-null, filters proposals with the given status.
    """
    status: ID

    """
    ID of a Theme to filter by. If non-null, filters proposals with the given theme.
    """
    theme: ID

    """If non-null, filters proposals with the given string to look for."""
    term: String

    """Affiliation options for proposals returned from the connection."""
    affiliations: [ProposalAffiliation]

    """(ROLE_SUPER_ADMIN only) Select also unpublished proposals."""
    includeUnpublished: Boolean = false

    """The global progress status of the proposal."""
    progressStatus: ProposalProgressState

    """The analysts's ids assigned to the proposal"""
    analysts: [ID!]

    """The supervisor's id assigned to the proposal"""
    supervisor: ID

    """The decision-maker's id assigned to the proposal"""
    decisionMaker: ID
  ): ProposalConnection!

  """The viewer unpublished proposals (only visible by viewer)."""
  viewerProposalsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection

  """The requirements to vote on this step."""
  requirements(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): RequirementConnection!

  """
  If votesRanking enabled, votesLimit is the reference value for the points scale.
  """
  votesLimit: Int

  """
  Minimum number of votes a user must submit for his votes to be counted.
  """
  votesMin: Int
  budget: Int
  voteType: ProposalStepVoteType!
  votable: Boolean!
  votesHelpText: String
  voteThreshold: Int
  statuses: [ProposalStepStatus!]!
  defaultSort: String
  open: Boolean!

  """If enabled, allow voters to order their votes by point"""
  votesRanking: Boolean!

  """A list of viewer votes associated with the step."""
  viewerVotes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ProposalVoteOrder = {direction: DESC}
  ): ProposalVoteConnection!
  form: ProposalForm
  private: Boolean!
  defaultStatus: ProposalStepStatus

  """A list of contributor associated with the step."""
  contributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!
  viewerProposalDrafts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection!

  """The main view : grid, list or map"""
  mainView: String!

  """
  Whether or not authors can add news on proposals collected in this step
  """
  allowAuthorsToAddNews: Boolean!
}

"""A color on hexadecimal format (#DDDDDD)."""
scalar Color

"""A comment"""
type Comment implements Node & Publishable & Reportable & Contribution & Commentable & UniformResourceLocatable {
  """The ID of an object"""
  id: ID!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Does the viewer already submitted a report ?"""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The URL to this resource."""
  url: URI!

  """The comments related to the commentable."""
  comments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: CommentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): CommentConnection!

  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!

  """The kind of contribution."""
  kind: String!
  body: String!
  createdAt: DateTime!
  updatedAt: DateTime
  author: User
  parent: Comment
  pinned: Boolean!
  contribuable: Boolean!
  answers: [Comment!]!
  authorName: String
  authorEmail: String
  authorIp: IP
  publicationStatus: CommentPublicationStatus!
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: VoteOrder = {field: PUBLISHED_AT, direction: DESC}
  ): CommentVoteConnection!
  viewerHasVote: Boolean!
  viewerVote: CommentVote
  editUrl: URI
  commentable: Commentable
}

"""A connection to a list of items."""
type CommentConnection {
  totalCount: Int!
  totalCountWithAnswers: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [CommentEdge]
}

"""An edge in a connection."""
type CommentEdge {
  """The item at the end of the edge."""
  node: Comment!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of comments can be ordered upon return."""
input CommentOrder {
  """The field in which to order nodes by."""
  field: CommentOrderField! = PUBLISHED_AT

  """The direction in which to order nodes."""
  direction: OrderDirection! = DESC
}

"""Ordering options for comments returned from the connection."""
enum CommentOrderField {
  """Allows ordering a list of comments by when they were published."""
  PUBLISHED_AT

  """Allows ordering a list of comments by when they were updated."""
  UPDATED_AT

  """Allows ordering a list of comments by there likes."""
  POPULARITY
}

"""Available statuses"""
enum CommentPublicationStatus {
  """Visible by author only."""
  UNPUBLISHED

  """Normal status, Publicly visible"""
  PUBLISHED

  """Publicly visible in the trash bin"""
  TRASHED

  """In the trash bin, content not visible"""
  TRASHED_NOT_VISIBLE
}

"""Entities that can be published."""
type CommentVote implements Node & Vote & Publishable {
  """The ID of an object"""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution."""
  author: User

  """The contribution that was voted."""
  related: Contribution

  """Returns 'commentVote'."""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason
  contribution: Comment!
}

"""A connection to a list of items."""
type CommentVoteConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [CommentVoteEdge]
}

"""An edge in a connection."""
type CommentVoteEdge {
  """The item at the end of the edge."""
  node: CommentVote!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A commentable"""
interface Commentable {
  """The ID of an object"""
  id: ID!

  """The comments related to the commentable."""
  comments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: CommentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): CommentConnection!
}

"""The different available types of step."""
enum ConcreteStepType {
  """Represent a collect step."""
  COLLECT

  """Represent a selection step."""
  SELECTION

  """Represent a consultation step."""
  CONSULTATION

  """Represent a step with no particular behaviour."""
  OTHER

  """Represent a presentation step, mainly used to show an introduction."""
  PRESENTATION

  """Represent a questionnaire step."""
  QUESTIONNAIRE

  """Represent a ranking step."""
  RANKING

  """Represent a debate step."""
  DEBATE
}

input ConfigureAnalysisInput {
  """The related proposal form id."""
  proposalFormId: ID!

  """The related evaluation form id."""
  evaluationFormId: ID

  """The step on which the analysis is based on."""
  analysisStepId: ID!

  """The effective date of the taken decision."""
  effectiveDate: DateTime

  """A text to explain the analysis process."""
  body: HTML

  """Activate the cost estimation on the evaluation form."""
  costEstimationEnabled: Boolean!

  """The favourable status to apply on contributions."""
  favourableStatus: ID

  """The available unfavourable statuses to, apply on contributions."""
  unfavourableStatuses: [ID!]

  """The selection step on which the contributions are moved on."""
  moveToSelectionStepId: ID

  """The status to apply on the contributions for the next step."""
  selectionStepStatusId: ID
  clientMutationId: String
}

type ConfigureAnalysisPayload {
  """The analysis configuration."""
  analysisConfiguration: AnalysisConfiguration
  clientMutationId: String
}

"""A consultation"""
type Consultation implements Node {
  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!

  """The ID of an object."""
  id: ID!

  """The title of the consultation."""
  title: String!

  """A list of contributor associated with the consultation."""
  contributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!

  """
  Whether the user has vote for a contribution in the related step of this consultation.
  """
  userHasVote(
    """The user's login (for example, an email)."""
    login: String!
  ): Boolean!

  """The number of votes in the related step of this consultation."""
  votesCount: Int @deprecated(reason: "Field `votesCount` will be removed. Use `votes.totalCount` instead. In preparation for an upcoming change to the way we expose counters, this field will only be available inside a connection. Removal on 2022-01-01 UTC.")

  """The votes in the related step of this consultation."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): VoteConnection!

  """Get the associated description of the consultation"""
  description: HTML

  """Get the associated illustration of the consultation"""
  illustration: Media

  """Get the url of the consultation"""
  url: URI!

  """List of sections."""
  sections: [Section]

  """The viewer's unpublished opinions."""
  viewerOpinionsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): OpinionConnection

  """Contributions are allowed right now."""
  contribuable: Boolean!

  """The number of opinions shown by section."""
  opinionCountShownBySection: Int
  titleHelpText: String

  """The help text description."""
  descriptionHelpText: String

  """The associated consultation step in which belongs this consultation"""
  step: ConsultationStep!

  """Retrieves all the contributions of the current consultation."""
  contributions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for contributions returned from the connection."""
    orderBy: ContributionOrder = {field: POSITION, direction: DESC}

    """The connection will return the trashed results too."""
    includeTrashed: Boolean = false
  ): ContributionConnection
}

"""A connection to a list of items."""
type ConsultationConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ConsultationEdge]
}

"""An edge in a connection."""
type ConsultationEdge {
  """The item at the end of the edge."""
  node: Consultation!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A consultation step"""
type ConsultationStep implements Node & Step & RequirementStep {
  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!

  """The ID of an object."""
  id: ID!

  """The requirements to vote on this step."""
  requirements(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): RequirementConnection!

  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The type of step. Returns "consultation"."""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!

  """The project"""
  project: Project!
  exportStepUrl: URI
  exportContributorsUrl: URI

  """A list of contributor associated with the consultation step."""
  contributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!

  """The number of votes in this consultation."""
  votesCount: Int @deprecated(reason: "Field `votesCount` will be removed. Use `votes.totalCount` instead. In preparation for an upcoming change to the way we expose counters, this field will only be available inside a connection. Removal on 2022-01-01 UTC.")
  votes: VoteConnection!

  """
  Whether the user has vote for a contribution in this consultation step.
  """
  userHasVote(
    """The user's login (for example, an email)."""
    login: String!
  ): Boolean!

  """Contributions are allowed right now."""
  contribuable: Boolean!

  """Get the associated consultations of this consultation step"""
  consultations(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ConsultationConnection!

  """Search a consultation in this step by it's slug"""
  consultation(
    """Returns the consultation that match the given slug"""
    slug: String!
  ): Consultation
  contributions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for contributions returned from the connection."""
    orderBy: ContributionOrder = {field: POSITION, direction: DESC}

    """The connection will return the trashed results too."""
    includeTrashed: Boolean = false
  ): ContributionConnection
}

"""Fetches an object given its ID"""
type ContactForm implements Node {
  """The title of the contact Form"""
  id: ID!

  """The title of the contact Form"""
  title(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String!

  """The body of the contact Form"""
  body(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String!

  """The mail to send the contact Form"""
  email: String!

  """The confidentiality text for the contact Form"""
  confidentiality(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String
  translations: [ContactFormTranslation!]!
}

"""A translation of a contactForm"""
type ContactFormTranslation {
  locale: String!

  """The translated title of the contact Form"""
  title: String!

  """The translated body of the contact Form"""
  body: String!

  """The translated confidentiality text for the contact Form"""
  confidentiality: String
}

input ContactFormTranslationInput {
  id: ID
  locale: String!
  title: String!
  body: String!
  confidentiality: String
  clientMutationId: String
}

input ContactProposalAuthorInput {
  """id of the proposal"""
  proposalId: ID!

  """the email of the viewer"""
  replyEmail: String!

  """the name of the viewer"""
  senderName: String!

  """the message to be sent"""
  message: String!

  """The captcha verification."""
  captcha: String!
  clientMutationId: String
}

type ContactProposalAuthorPayload {
  """the error message, if any"""
  error: String
  clientMutationId: String
}

"""A contribution with an author"""
interface Contribution {
  """The ID of an object"""
  id: ID!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """Url of the contribution"""
  url: URI!
}

"""A connection to a list of items."""
type ContributionConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ContributionEdge]
}

"""An edge in a connection."""
type ContributionEdge {
  """The item at the end of the edge."""
  node: Contribution!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of contributions can be ordered upon return."""
input ContributionOrder {
  field: ContributionOrderField! = POSITION
  direction: OrderDirection! = DESC
}

"""Ordering options for contributions connections."""
enum ContributionOrderField {
  """Allows ordering a list of contributions by when they were created."""
  CREATED_AT

  """Allows ordering a list of contributions by there number of comments."""
  COMMENT_COUNT

  """Allows ordering a list of contributions by there number of votes ok."""
  POPULAR

  """Allows ordering a list of contributions by there position."""
  POSITION

  """Allows ordering a list of contributions by when they were published."""
  PUBLISHED_AT

  """Allows ordering a list of contributions randomly."""
  RANDOM

  """Allows ordering a list of contributions by there number of votes."""
  VOTE_COUNT
}

"""The origin of a contribution"""
enum ContributionOrigin {
  """Created on the platform"""
  INTERNAL

  """Created through a widget"""
  WIDGET

  """Created through email"""
  MAIL
}

"""Different contribution type"""
enum ContributionType {
  """Get contributions that are an opnion"""
  OPINION

  """Get contributions that are an opnion version"""
  OPINIONVERSION

  """Get contributions that are a comment"""
  COMMENT

  """Get contributions that are an argument"""
  ARGUMENT

  """Get contributions that are a source"""
  SOURCE

  """Get contributions that are a proposal"""
  PROPOSAL

  """Get contributions that are a reply"""
  REPLY

  """Get contributions that are debate argument."""
  DEBATEARGUMENT
}

"""A contribution with an author"""
interface ContributionWithAuthor {
  """The author of the contribution."""
  author: User!
}

input CreateAlphaProjectInput {
  """The project title"""
  title: String!

  """The project authors IDs"""
  authors: [ID!]!

  """The project type ID"""
  projectType: ID

  """The project cover"""
  Cover: ID

  """The project video link"""
  video: String

  """The project themes IDs"""
  themes: [ID!]!

  """The project districts IDs"""
  districts: [ID!]!

  """The project metadescription"""
  metaDescription: String

  """Is the project external"""
  isExternal: Boolean!

  """The project external link"""
  externalLink: String

  """The project external participants count"""
  externalParticipantsCount: Int

  """The project external contributions count"""
  externalContributionsCount: Int

  """The project external votes count"""
  externalVotesCount: Int

  """The project publication date"""
  publishedAt: DateTime!

  """The project visibility"""
  visibility: ProjectVisibility!
  opinionCanBeFollowed: Boolean!
  steps: [ProjectStepInput!]!
  headerType: ProjectHeaderType
  coverFilterOpacityPercent: Int

  """The locale id of the project. Null if visible by all languages"""
  locale: ID

  """Groups id."""
  restrictedViewerGroups: [ID!]

  """if it is archived"""
  archived: Boolean!
  clientMutationId: String
}

type CreateAlphaProjectPayload {
  """The created project"""
  project: Project
  clientMutationId: String
}

"""Available errors for a `createDebateAnonymousArgument` mutation."""
enum CreateDebateAnonymousArgumentErrorCode {
  """No `Debate` match your id."""
  UNKNOWN_DEBATE

  """There already is an argument with that email."""
  ALREADY_HAS_ARGUMENT
}

input CreateDebateAnonymousArgumentInput {
  """The id of the `Debate` where the argument belongs."""
  debate: ID!

  """The body value of the argument."""
  body: String!

  """Whether the argument will be `FOR` or `AGAINST`."""
  type: ForOrAgainstValue!

  """
  The URL of widget from which the debate argument's vote was added, if any.
  """
  widgetOriginURI: URI = null

  """The email of the author"""
  email: Email! = 

  """The username of the author if no account"""
  username: String = null

  """Does consent to receive internal email."""
  consentInternalCommunication: Boolean = false
  clientMutationId: String
}

type CreateDebateAnonymousArgumentPayload {
  """The argument that had just been created."""
  debateArgument: DebateAnonymousArgument

  """An unsuccessful mutation will return an error."""
  errorCode: CreateDebateAnonymousArgumentErrorCode

  """The token of the argument."""
  token: String
  clientMutationId: String
}

"""Available errors for an `createDebateArgument` mutation."""
enum CreateDebateArgumentErrorCode {
  """No `Debate` match your id."""
  UNKNOWN_DEBATE

  """User has already created an argument."""
  ALREADY_HAS_ARGUMENT
}

input CreateDebateArgumentInput {
  """The id of the `Debate` where the argument belongs."""
  debate: ID!

  """The body value of the argument."""
  body: String!

  """Whether the argument will be `FOR` or `AGAINST`."""
  type: ForOrAgainstValue!

  """
  The URL of widget from which the debate argument's vote was added, if any.
  """
  widgetOriginURI: URI = null
  clientMutationId: String
}

type CreateDebateArgumentPayload {
  """The argument that had just been created."""
  debateArgument: DebateArgument

  """An unsuccessful mutation will return an error."""
  errorCode: CreateDebateArgumentErrorCode
  clientMutationId: String
}

"""Available errors on campaign creation"""
enum CreateEmailingCampaignErrorCode {
  """No mailing list match your id"""
  ID_NOT_FOUND_MAILING_LIST
}

input CreateEmailingCampaignInput {
  """Optional. The mailing list to build the campaign."""
  mailingList: ID
  clientMutationId: String
}

type CreateEmailingCampaignPayload {
  """The campaign created"""
  emailingCampaign: EmailingCampaign

  """The error code, if any"""
  error: CreateEmailingCampaignErrorCode
  clientMutationId: String
}

input CreateGroupInput {
  """The title of the group"""
  title: String!

  """The description of the group"""
  description: String
  clientMutationId: String
}

type CreateGroupPayload {
  group: Group!
  clientMutationId: String
}

input CreateMailingListInput {
  """The name of the list"""
  name: String!

  """The list of the users to put in the list"""
  userIds: [ID!]!

  """Optionnal. The list from which the list is built"""
  project: ID
  clientMutationId: String
}

type CreateMailingListPayload {
  """The mailing list created"""
  mailingList: MailingList

  """The error code, if any"""
  error: String
  clientMutationId: String
}

input CreateOauth2SSOConfigurationInput {
  """Client ID."""
  clientId: String!

  """Secret key."""
  secret: String!

  """Authorization URL."""
  authorizationUrl: URI!

  """Access token URL."""
  accessTokenUrl: URI!

  """User info URL."""
  userInfoUrl: URI!

  """Logout URL."""
  logoutUrl: URI

  """Profile URL on the SSO side."""
  profileUrl: URI

  """Specify if this SSO configuration is active or not."""
  enabled: Boolean!

  """The name of your SSO provider."""
  name: String!

  """Color in hexadecimal of SSO button."""
  buttonColor: Color!

  """Color in hexadecimal of label SSO button."""
  labelColor: Color!
  clientMutationId: String
}

type CreateOauth2SSOConfigurationPayload {
  """The created oauth2 configuration."""
  ssoConfiguration: Oauth2SSOConfiguration
  clientMutationId: String
}

"""Available errors on opinion creation"""
enum CreateOpinionErrorCode {
  """this opinionType is not enabled"""
  OPINION_TYPE_NOT_ENABLED

  """the step is unknown"""
  UNKNOWN_STEP

  """the step is not contribuable"""
  STEP_NOT_CONTRIBUABLE

  """the viewer does not meet requirements"""
  REQUIREMENTS_NOT_MET

  """the viewer contributed too many times"""
  CONTRIBUTED_TOO_MANY_TIMES

  """the form is invalid"""
  INVALID_FORM

  """this opinionType is not found"""
  OPINION_TYPE_NOT_FOUND

  """this project is not found"""
  PROJECT_NOT_FOUND
}

input CreateOpinionInput {
  """the project id"""
  projectId: ID!

  """the step id"""
  stepId: ID!

  """the opinionType id"""
  opinionTypeId: ID!

  """the opinion title"""
  title: String!

  """the opinion body"""
  body: String!

  """the opinion appendices"""
  appendices: [AppendixInput]!
  clientMutationId: String
}

type CreateOpinionPayload {
  """the created opinion"""
  opinion: Opinion

  """available errors if mutation fails"""
  errorCode: CreateOpinionErrorCode
  clientMutationId: String
}

"""Available errors on createPost mutation"""
enum CreatePostErrorCode {
  """Submitted form is invalid"""
  INVALID_FORM
}

input CreatePostInput {
  translations: [CreatePostTranslationInput!]

  """post authors"""
  authors: [ID!]!

  """post customCode"""
  customCode: String

  """related projects related to the post"""
  projects: [ID]!

  """proposals related to the post"""
  proposals: [ID]!

  """themes related to the post"""
  themes: [ID]!

  """Whether or not the post should be displayed on blog"""
  displayedOnBlog: Boolean!

  """When the post should be pusblished"""
  publishedAt: DateTime!

  """Whether or not the post should be published"""
  isPublished: Boolean!

  """Whether or not the post should be commentable"""
  commentable: Boolean!

  """The media attached to the post"""
  media: ID
  clientMutationId: String
}

type CreatePostPayload {
  """The created post"""
  post: Post

  """Available errorCode for createPost mutation"""
  errorCode: CreatePostErrorCode
  clientMutationId: String
}

input CreatePostTranslationInput {
  """post title"""
  title: String!

  """post body"""
  body: HTML!

  """post abstract"""
  abstract: String

  """post metadescription"""
  metaDescription: String

  """the locale of the translation"""
  locale: TranslationLocale!
  clientMutationId: String
}

input CreateProjectDistrictInput {
  geojson: GeoJSON
  displayedOnMap: Boolean = false
  border: BorderStyleInput
  background: BackgroundStyleInput
  translations: [DistrictTranslationInput!]!
}

type CreateProjectDistrictPayload {
  district: ProjectDistrict

  """The edge from the project district connection."""
  districtEdge: ProjectDistrictEdge

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input CreateProjectInput {
  """The project's title"""
  title: String!

  """The project's authors, accept IDs of User"""
  authors: [ID!]!

  """The project's type"""
  projectType: String

  """The uuid of the locale of this project, null if none"""
  locale: ID
  clientMutationId: String
}

type CreateProjectPayload {
  """The created project"""
  project: Project
  clientMutationId: String
}

input CreateProposalFormInput {
  """The proposal form title"""
  title: String!
  clientMutationId: String
}

type CreateProposalFormPayload {
  proposalForm: ProposalForm!
  clientMutationId: String
}

input CreateProposalFromBackOfficeInput {
  """Link of Web page."""
  webPageUrl: URI

  """Link of Facebook page."""
  facebookUrl: URI

  """Link of Twitter page."""
  twitterUrl: URI

  """Link of Instagram page."""
  instagramUrl: URI

  """Link of LinkedIn profile."""
  linkedInUrl: URI

  """Link of Youtube channel."""
  youtubeUrl: URI

  """The id of the form form proposal"""
  proposalFormId: ID!

  """If true will create a draft proposal, otherwise a published proposal."""
  draft: Boolean

  """The proposal title"""
  title: String

  """The proposal body"""
  body: HTML

  """The proposal summary"""
  summary: String

  """The theme id (feature themes must be enabled)"""
  theme: ID

  """The category id"""
  category: ID

  """The district id (feature districts must be enabled)"""
  district: ID

  """The address geocoded by google"""
  address: String

  """The responses to the form questions"""
  responses: [ResponseInput]

  """The media id to illustrate"""
  media: ID

  """The ID of tipsmeee"""
  tipsmeeeId: String
  clientMutationId: String

  """The proposal author"""
  author: ID!

  """The proposal published date"""
  publishedAt: DateTime!
}

input CreateProposalFusionInput {
  """Proposal ids from which the fusion is created"""
  fromProposals: [ID!]!

  """Proposal title for newly created proposal"""
  title: String

  """Proposal body for newly created proposal"""
  description: String
  clientMutationId: String
}

type CreateProposalFusionPayload {
  proposal: Proposal
  clientMutationId: String
}

input CreateProposalInput {
  """Link of Web page."""
  webPageUrl: URI

  """Link of Facebook page."""
  facebookUrl: URI

  """Link of Twitter page."""
  twitterUrl: URI

  """Link of Instagram page."""
  instagramUrl: URI

  """Link of LinkedIn profile."""
  linkedInUrl: URI

  """Link of Youtube channel."""
  youtubeUrl: URI

  """The id of the form form proposal"""
  proposalFormId: ID!

  """If true will create a draft proposal, otherwise a published proposal."""
  draft: Boolean

  """The proposal title"""
  title: String

  """The proposal body"""
  body: HTML

  """The proposal summary"""
  summary: String

  """The theme id (feature themes must be enabled)"""
  theme: ID

  """The category id"""
  category: ID

  """The district id (feature districts must be enabled)"""
  district: ID

  """The address geocoded by google"""
  address: String

  """The responses to the form questions"""
  responses: [ResponseInput]

  """The media id to illustrate"""
  media: ID

  """The ID of tipsmeee"""
  tipsmeeeId: String
  clientMutationId: String
}

type CreateProposalPayload {
  """The created proposal, if everything goes well !"""
  proposal: Proposal

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]
  clientMutationId: String
}

input CreateQuestionnaireInput {
  """The questionnaire form title"""
  title: String!

  """The questionnaire type"""
  type: QuestionnaireType! = QUESTIONNAIRE
  clientMutationId: String
}

type CreateQuestionnairePayload {
  questionnaire: Questionnaire
  clientMutationId: String
}

"""Possible errors on createSenderEmailDomain mutation."""
enum CreateSenderEmailDomainErrorCode {
  """There is already a SenderEmailDomain matching service and value."""
  ALREADY_EXIST
}

input CreateSenderEmailDomainInput {
  """The service used by the domain."""
  service: SenderEmailDomainService!

  """The domain, eg cap-collectif.com"""
  value: String!
  clientMutationId: String
}

type CreateSenderEmailDomainPayload {
  """The created SenderEmailDomain."""
  senderEmailDomain: SenderEmailDomain

  """The error generated, if any."""
  errorCode: CreateSenderEmailDomainErrorCode
  clientMutationId: String
}

"""Possible errors on createSenderDomain mutation."""
enum CreateSenderEmailErrorCode {
  """There is already a SenderEmail matching locale and domain."""
  ALREADY_EXIST

  """The domain is not in the list of domains."""
  INVALID_DOMAIN
}

input CreateSenderEmailInput {
  """The first part of the address, before the @."""
  locale: String!

  """The second part of the address, after the @."""
  domain: String!
  clientMutationId: String
}

type CreateSenderEmailPayload {
  """The created SenderEmail."""
  senderEmail: SenderEmail

  """The error generated, if any."""
  errorCode: CreateSenderEmailErrorCode
  clientMutationId: String
}

input CreateUserInput {
  """The user's username"""
  username: String!

  """The user's email"""
  email: String!

  """The user's password"""
  plainPassword: String

  """Unattended roles as array."""
  roles: [UserRole]
  locked: Boolean
  vip: Boolean
  enabled: Boolean
  clientMutationId: String
}

type CreateUserPayload {
  """The created user, if everything goes well !"""
  user: User
  clientMutationId: String
}

input CropMediaInput {
  """The media id."""
  mediaId: ID!

  """An object containing the size and start options for cropping a media."""
  filters: CroppingOptionInput!
  clientMutationId: String
}

type CropMediaPayload {
  """The cropped media."""
  media: Media!
  clientMutationId: String
}

"""The required values to apply a cropping on a media."""
input CroppingOptionInput {
  """
  Sets the crop size as an integer array containing the dimensions as width and height values.
  """
  size: CroppingSizeOptionInput!

  """
  Sets the top, left-post anchor coordinates where the crop operation starts.
  """
  start: CroppingStartOptionInput!
}

"""An object containing the width and height of the media."""
input CroppingSizeOptionInput {
  """The width of the media."""
  width: Int!

  """The height of the media."""
  height: Int!
}

"""An object containing the coordinates for media cropping."""
input CroppingStartOptionInput {
  """The x (left) coordinates for media cropping."""
  x: Int!

  """The y (top) coordinates for media cropping."""
  y: Int!
}

"""A string containing CSS."""
scalar CssJSON

"""Require a date of birth"""
type DateOfBirthRequirement implements Node & Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!

  """The date of birth of the viewer."""
  viewerDateOfBirth: DateTime
}

"""A string containing a datetime."""
scalar DateTime

"""A debate on a subject."""
type Debate implements Node {
  """The ID of an object."""
  id: ID!

  """The opinions from experts of the debate."""
  opinions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): DebateOpinionConnection!

  """The arguments from non-experts of the debate, in alternate way."""
  alternateArguments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    (ROLE_ADMIN only) True to see only published arguments, false to see only unpublished, null to see both.
    """
    isPublished: Boolean = null

    """
    (ROLE_ADMIN only) True to see only trashed arguments, false to not see trashed, null to see both.
    """
    isTrashed: Boolean = false

    """Order by."""
    orderBy: DebateArgumentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): DebateArgumentAlternateConnection!

  """The arguments from non-experts of the debate."""
  arguments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Filter by an argument's stand."""
    value: ForOrAgainstValue = null

    """
    (ROLE_ADMIN only) True to see only published arguments, false to see only unpublished, null to see both.
    """
    isPublished: Boolean = null

    """
    (ROLE_ADMIN only) True to see only trashed arguments, false to not see trashed, null to see both.
    """
    isTrashed: Boolean = null

    """Order by."""
    orderBy: DebateArgumentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): DebateArgumentConnection!

  """True if the viewer has created an argument."""
  viewerHasArgument: Boolean!

  """The votes from contributors of the debate."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Filter by a vote's type."""
    type: ForOrAgainstValue = null

    """
    (ROLE_ADMIN only) `true` to see only published votes, `false` to see only unpublished, `null` to see both.
    """
    isPublished: Boolean = null

    """The ordering options for votes."""
    orderBy: DebateVoteOrder = {field: PUBLISHED_AT, direction: DESC}
  ): DebateVoteConnection!

  """True if the viewer has upvoted the argument."""
  viewerHasVote: Boolean!

  """True if the viewer has upvoted the argument."""
  viewerVote: DebateVote

  """The associated articles of the debate."""
  articles(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): DebateArticleConnection!

  """The url of the debate"""
  url: URI!

  """The viewer's unpublished votes."""
  viewerUnpublishedVotes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): DebateVoteConnection!

  """The viewer's unpublished argument."""
  viewerUnpublishedArgument: DebateArgument

  """The step of the debate."""
  step: DebateStep!
}

"""A debate argument from anonymous."""
type DebateAnonymousArgument implements Node & AbstractDebateArgument & Trashable & Contribution {
  """The ID of an object."""
  id: ID!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """True if the viewer has reported the argument."""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The url of the debate"""
  url: URI!

  """The content of the argument."""
  body: String!

  """The debate related to the argument."""
  debate: Debate!

  """Whether the argument is for or against."""
  type: ForOrAgainstValue!

  """IP of the author"""
  ipAddress: IP

  """The origin of a debate's argument"""
  origin: ContributionOrigin!

  """The URL of widget from which the debate's argument was added, if any."""
  widgetOriginUrl: URI

  """The formatted geolocalization informations."""
  geoip: FormattedGeolocalization

  """True if the viewer has upvoted the argument."""
  viewerHasVote: Boolean!

  """The upvotes on the argument."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Order by."""
    orderBy: DebateArgumentVoteOrder = {field: PUBLISHED_AT, direction: DESC}
  ): DebateArgumentVoteConnection!

  """Did the viewer author this entity."""
  viewerDidAuthor: Boolean

  """Email"""
  email: Email!

  """Username (not mandatory)"""
  username: String

  """
  Whether or not the author of the argument consents to receive emails from us.
  """
  consentInternalCommunication: Boolean!
}

"""An anonymous debate vote."""
type DebateAnonymousVote implements Node & AbstractDebateVote {
  """The ID of an object."""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """Whether or not the vote is published."""
  published: Boolean!

  """The date when the vote was published at."""
  publishedAt: DateTime

  """The value of the vote."""
  type: ForOrAgainstValue!

  """The debate of the vote."""
  debate: Debate!

  """IP of the voter"""
  ipAddress: IP

  """The origin of a debate argument's vote"""
  origin: ContributionOrigin!

  """
  The URL of widget from which the debate argument's vote was added, if any.
  """
  widgetOriginUrl: URI

  """Navigator of the voter"""
  navigator: String

  """The formatted geolocalization informations."""
  geoip: FormattedGeolocalization
}

"""A debate argument from non expert."""
type DebateArgument implements Node & AbstractDebateArgument & Trashable & Contribution {
  """The ID of an object."""
  id: ID!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """True if the viewer has reported the argument."""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The url of the debate"""
  url: URI!

  """The content of the argument."""
  body: String!

  """The debate related to the argument."""
  debate: Debate!

  """Whether the argument is for or against."""
  type: ForOrAgainstValue!

  """IP of the author"""
  ipAddress: IP

  """The origin of a debate's argument"""
  origin: ContributionOrigin!

  """The URL of widget from which the debate's argument was added, if any."""
  widgetOriginUrl: URI

  """The formatted geolocalization informations."""
  geoip: FormattedGeolocalization

  """True if the viewer has upvoted the argument."""
  viewerHasVote: Boolean!

  """The upvotes on the argument."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Order by."""
    orderBy: DebateArgumentVoteOrder = {field: PUBLISHED_AT, direction: DESC}
  ): DebateArgumentVoteConnection!

  """Did the viewer author this entity."""
  viewerDidAuthor: Boolean

  """The non-expert giving his argument."""
  author: User!
}

"""Two debate arguments from non expert, one for and one against."""
type DebateArgumentAlternate {
  """The FOR argument."""
  for: AbstractDebateArgument

  """The AGAINST argument."""
  against: AbstractDebateArgument
}

"""A connection to a list of items."""
type DebateArgumentAlternateConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [DebateArgumentAlternateEdge]
}

"""An edge in a connection."""
type DebateArgumentAlternateEdge {
  """The item at the end of the edge."""
  node: DebateArgumentAlternate!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A connection to a list of items."""
type DebateArgumentConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [DebateArgumentEdge]
}

"""An edge in a connection."""
type DebateArgumentEdge {
  """The item at the end of the edge."""
  node: AbstractDebateArgument!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of arguments can be ordered upon return."""
input DebateArgumentOrder {
  """The field to order arguments by."""
  field: DebateArgumentOrderField! = PUBLISHED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Ordering options for arguments returned from the connection."""
enum DebateArgumentOrderField {
  PUBLISHED_AT
  VOTE_COUNT
}

"""A debate vote."""
type DebateArgumentVote implements Node & Publishable & Vote & Contribution {
  """The ID of an object."""
  id: ID!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the vote."""
  author: User!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """Returns Type of vote"""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Url of the contribution"""
  url: URI!

  """The debate of the vote."""
  debateArgument: AbstractDebateArgument!

  """IP of the voter"""
  ipAddress: IP

  """The origin of a debate argument's vote"""
  origin: ContributionOrigin!

  """
  The URL of widget from which the debate argument's vote was added, if any.
  """
  widgetOriginUrl: URI
}

"""A connection to a list of items."""
type DebateArgumentVoteConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [DebateArgumentVoteEdge]
}

"""An edge in a connection."""
type DebateArgumentVoteEdge {
  """The item at the end of the edge."""
  node: DebateArgumentVote

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of votes can be ordered upon return."""
input DebateArgumentVoteOrder {
  """The field to order votes by."""
  field: DebateArgumentVoteOrderField! = PUBLISHED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Ordering options for votes returned from the connection."""
enum DebateArgumentVoteOrderField {
  PUBLISHED_AT
}

"""A debate article."""
type DebateArticle implements Node {
  """The ID of an object."""
  id: ID!

  """The url of the article."""
  url: URI!

  """The title of the article."""
  title: String

  """The description of the article."""
  description: String

  """The url of the article's cover."""
  coverUrl: URI

  """The origin of the article."""
  origin: String

  """The article publication date."""
  publishedAt: DateTime

  """Whether or not the article has been successfully crawled."""
  hasBeenCrawled: Boolean!

  """The debate related to the article."""
  debate: Debate!
}

"""A connection to a list of items."""
type DebateArticleConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [DebateArticleEdge]
}

"""An edge in a connection."""
type DebateArticleEdge {
  """The item at the end of the edge."""
  node: DebateArticle!

  """A cursor for use in pagination."""
  cursor: String!
}

input DebateArticleInput {
  id: ID
  url: URI!
}

"""A debate opinion."""
type DebateOpinion implements Node {
  """The ID of an object."""
  id: ID!

  """The title of the opinion."""
  title: String!

  """The content of the opinion."""
  body: HTML!

  """The expert giving his opinion."""
  author: User!

  """The debate related to the opinion."""
  debate: Debate!

  """Whether the opinion is for or against."""
  type: ForOrAgainstValue!
}

"""A connection to a list of items."""
type DebateOpinionConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [DebateOpinionEdge]
}

"""An edge in a connection."""
type DebateOpinionEdge {
  """The item at the end of the edge."""
  node: DebateOpinion!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A step with a debate."""
type DebateStep implements Step & Node {
  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The ID of an object."""
  id: ID!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI

  """The debate of the step."""
  debate: Debate!

  """A list of contributor associated with the step."""
  contributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!

  """the type of the debate"""
  debateType: DebateType!

  """the content of the debate"""
  debateContent: HTML

  """Does the debate allow anonymous users to participate?"""
  isAnonymousParticipationAllowed: Boolean!
}

enum DebateType {
  """
  add a wysiwyg to allow the author to add additional content to the debate
  """
  WYSIWYG

  """remove the wysiwyg to only let the face to face debate"""
  FACE_TO_FACE
}

"""A debate vote."""
type DebateVote implements Node & AbstractDebateVote & Publishable {
  """The ID of an object."""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """The value of the vote."""
  type: ForOrAgainstValue!

  """The debate of the vote."""
  debate: Debate!

  """IP of the voter"""
  ipAddress: IP

  """The origin of a debate's vote"""
  origin: ContributionOrigin!

  """The URL of widget from which the debate's vote was added, if any."""
  widgetOriginUrl: URI

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """The author of the vote."""
  author: User!

  """The formatted geolocalization informations."""
  geoip: FormattedGeolocalization
}

"""A connection to a list of items."""
type DebateVoteConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [DebateVoteEdge]
}

"""An edge in a connection."""
type DebateVoteEdge {
  """The item at the end of the edge."""
  node: AbstractDebateVote

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of votes can be ordered upon return."""
input DebateVoteOrder {
  """The field to order votes by."""
  field: DebateVoteOrderField! = PUBLISHED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Ordering options for votes returned from the connection."""
enum DebateVoteOrderField {
  PUBLISHED_AT
  CREATED_AT
}

"""Entities that can be deleted."""
interface Deletable {
  """The ID of an object"""
  id: ID!

  """Check if the current viewer can delete this object"""
  viewerCanDelete: Boolean!
}

"""Available errors on DeleteAccountByEmail mutation."""
enum DeleteAccountByEmailErrorCode {
  """The given email does not correspond to an existing user."""
  NON_EXISTING_EMAIL

  """You can't delete a user that has role 'ROLE_SUPER_ADMIN'."""
  DELETION_DENIED
}

input DeleteAccountByEmailInput {
  """The user's email to delete"""
  email: String!
  clientMutationId: String
}

type DeleteAccountByEmailPayload {
  """The deleted user's email."""
  email: String

  """Contains the error code if one occurred."""
  errorCode: DeleteAccountByEmailErrorCode
  clientMutationId: String
}

input DeleteAccountInput {
  """You must chose a strategy to delete your account"""
  type: DeleteAccountType!

  """(ROLE_SUPER_ADMIN only) The user to delete"""
  userId: ID
  clientMutationId: String
}

type DeleteAccountPayload {
  """user id"""
  userId: ID!
  clientMutationId: String
}

"""Differents strategies to delete an account"""
enum DeleteAccountType {
  """Anonymize the user and delete his content only on active steps"""
  SOFT

  """Anonymize the user and delete his content"""
  HARD
}

input DeleteArgumentInput {
  argumentId: ID!
  clientMutationId: String
}

type DeleteArgumentPayload {
  deletedArgumentId: ID
  argumentable: Argumentable!
  clientMutationId: String
}

input DeleteCommentInput {
  """The ID of the comment to delete."""
  id: ID!
  clientMutationId: String
}

type DeleteCommentPayload {
  deletedCommentId: ID
  commentable: Commentable

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError]
  clientMutationId: String
}

"""Available errors for an `deleteDebateAnonymousArgument` mutation."""
enum DeleteDebateAnonymousArgumentErrorCode {
  """No `Debate` match your `id`."""
  UNKNOWN_DEBATE

  """The debate is closed and removing an argument cannot be done."""
  CLOSED_DEBATE

  """The given hash is not valid."""
  INVALID_HASH

  """The user has no argument on this debate."""
  UNKNOWN_DEBATE_ARGUMENT
}

input DeleteDebateAnonymousArgumentInput {
  """The Node ID of the `Debate` to remove the argument on."""
  debate: ID!

  """The cookie hash needed to remove anonymous argument."""
  hash: String!
  clientMutationId: String
}

type DeleteDebateAnonymousArgumentPayload {
  """The id that had just been deleted."""
  deletedDebateAnonymousArgumentId: ID

  """An unsuccessful mutation will return an error."""
  errorCode: DeleteDebateAnonymousArgumentErrorCode

  """The deleted argument associated debate."""
  debate: Debate
  clientMutationId: String
}

"""Available errors for an `deleteDebateArgument` mutation."""
enum DeleteDebateArgumentErrorCode {
  """No `DebateArgument` match your `id`."""
  UNKNOWN_DEBATE_ARGUMENT

  """You are neither an admin nor the author of the `DebateArgument`."""
  CANNOT_DELETE_DEBATE_ARGUMENT
}

input DeleteDebateArgumentInput {
  """The Node ID of the `DebateArgument`."""
  id: ID!
  clientMutationId: String
}

type DeleteDebateArgumentPayload {
  """The id that had just been deleted."""
  deletedDebateArgumentId: ID

  """An unsuccessful mutation will return an error."""
  errorCode: DeleteDebateArgumentErrorCode

  """The deleted argument associated debate."""
  debate: Debate
  clientMutationId: String
}

"""Available errors for an `deleteDebateOpinion` mutation."""
enum DeleteDebateOpinionErrorCode {
  """No `DebateOpinion` match your `debateOpinionId`."""
  UNKNOWN_DEBATE_OPINION
}

input DeleteDebateOpinionInput {
  """The Node ID of the `DebateOpinion`."""
  debateOpinionId: ID!
  clientMutationId: String
}

type DeleteDebateOpinionPayload {
  """The id just deleted."""
  deletedDebateOpinionId: ID

  """The debate of the deleted opinion."""
  debate: Debate

  """An unsuccessful mutation will return an error."""
  errorCode: DeleteDebateOpinionErrorCode
  clientMutationId: String
}

"""Available errors on campaign deletion"""
enum DeleteEmailingCampaignsErrorCode {
  """No campaign match your id"""
  ID_NOT_FOUND

  """No campaign in request"""
  EMPTY
}

input DeleteEmailingCampaignsInput {
  """The campaigns to delete"""
  ids: [ID!]!
  clientMutationId: String
}

type DeleteEmailingCampaignsPayload {
  """The mailing lists deleted"""
  deletedIds: [ID!]!

  """The mailing lists archived"""
  archivedIds: [ID!]!

  """The error code, if any"""
  error: DeleteEmailingCampaignsErrorCode
  clientMutationId: String
}

input DeleteEventInput {
  """The ID of the event to delete."""
  eventId: ID!
  clientMutationId: String
}

type DeleteEventPayload {
  deletedEventId: ID

  """The event."""
  event: Event
  clientMutationId: String
}

input DeleteFontInput {
  """The ID of the font to delete."""
  id: ID!
  clientMutationId: String
}

type DeleteFontPayload {
  deletedFontId: ID
  bodyFont: Font!
  headingFont: Font!

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError]
  clientMutationId: String
}

input DeleteGroupInput {
  """The group id"""
  groupId: ID!
  clientMutationId: String
}

type DeleteGroupPayload {
  deletedGroupTitle: String!
  clientMutationId: String
}

input DeleteMailingListInput {
  """The mailing lists list to delete"""
  ids: [ID!]!
  clientMutationId: String
}

type DeleteMailingListPayload {
  """The mailing lists deleted"""
  deletedIds: [ID!]!

  """The error code, if any"""
  error: String
  clientMutationId: String
}

input DeleteMediaAdminInput {
  """List of media ID to delete."""
  ids: [ID!]!
}

type DeleteMediaAdminPayload {
  deletedMediaIds: [ID]!

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

"""Available errors on OfficialResponse removal"""
enum DeleteOfficialResponseErrorCode {
  """No OfficialResponse match your id"""
  ID_NOT_FOUND
}

input DeleteOfficialResponseInput {
  """The id of the OfficialResponse to delete."""
  id: ID!
  clientMutationId: String
}

type DeleteOfficialResponsePayload {
  """The id of the OfficialResponse who just have been deleted."""
  id: ID

  """The error, if any."""
  error: DeleteOfficialResponseErrorCode
  clientMutationId: String
}

input DeleteOpinionInput {
  """The opinion id"""
  opinionId: ID!
  clientMutationId: String
}

type DeleteOpinionPayload {
  """The deleted ID."""
  deletedOpinionId: ID
  clientMutationId: String
}

input DeletePostInput {
  """The id of the post to delete"""
  id: ID!
  clientMutationId: String
}

type DeletePostPayload {
  """The deleted post id"""
  deletedPostId: ID
  clientMutationId: String
}

input DeleteProjectDistrictInput {
  id: ID!
}

type DeleteProjectDistrictPayload {
  deletedDistrictId: ID

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input DeleteProjectInput {
  """The id of the project to delete"""
  id: ID!
  clientMutationId: String
}

type DeleteProjectPayload {
  """The deleted project id"""
  deletedProjectId: ID
  clientMutationId: String
}

input DeleteProposalFormInput {
  """The id of the `ProposalForm` to delete."""
  id: ID!
  clientMutationId: String
}

type DeleteProposalFormPayload {
  """The deleted `ProposalForm` id."""
  deletedProposalFormId: ID
  clientMutationId: String
}

input DeleteProposalInput {
  """The proposal id"""
  proposalId: ID!
  clientMutationId: String
}

input DeleteProposalNewsInput {
  """The Node ID of the proposal news."""
  postId: ID!
  clientMutationId: String
}

type DeleteProposalNewsPayload {
  """The Node ID of the proposal news."""
  postId: ID

  """The url of proposal to be redirect."""
  proposalUrl: URI

  """An unsuccessful mutation will return an error message"""
  errorCode: ProposalNewsErrorCode
  clientMutationId: String
}

type DeleteProposalPayload {
  proposal: Proposal!
  step: CollectStep!
  clientMutationId: String
}

input DeleteQuestionnaireInput {
  """The id of the Questionnaire to delete"""
  id: ID!
  clientMutationId: String
}

type DeleteQuestionnairePayload {
  """The deleted questionnaire id"""
  deletedQuestionnaireId: ID
  clientMutationId: String
}

input DeleteReplyInput {
  """The id of the reply"""
  id: ID!
  clientMutationId: String
}

type DeleteReplyPayload {
  questionnaire: Questionnaire!
  clientMutationId: String
}

input DeleteSSOConfigurationInput {
  """The ID of SSO Configuration that needs to be deleted."""
  id: ID!
  clientMutationId: String
}

type DeleteSSOConfigurationPayload {
  deletedSsoConfigurationId: ID
  userErrors: [UserError]
  clientMutationId: String
}

"""Possible errors on createSenderEmailDomain mutation."""
enum DeleteSenderEmailDomainErrorCode {
  """No SenderEmailDomain match your id"""
  NOT_FOUND

  """SenderEmailDomain is used by a SenderEmail"""
  DOMAIN_USED
}

input DeleteSenderEmailDomainInput {
  """The SenderEmailDomain to delete."""
  id: ID!
  clientMutationId: String
}

type DeleteSenderEmailDomainPayload {
  """The deleted SenderEmailDomain."""
  deletedId: ID

  """The error generated, if any."""
  errorCode: DeleteSenderEmailDomainErrorCode
  clientMutationId: String
}

input DeleteSourceInput {
  """The ID to delete."""
  sourceId: ID!
  clientMutationId: String
}

type DeleteSourcePayload {
  """The deleted ID."""
  deletedSourceId: ID

  """The parent of the deleted source."""
  sourceable: Sourceable
  clientMutationId: String
}

input DeleteUserInGroupInput {
  """The user id"""
  userId: ID!

  """The group id"""
  groupId: ID!
  clientMutationId: String
}

type DeleteUserInGroupPayload {
  group: Group!
  clientMutationId: String
}

input DeleteVersionInput {
  """The version id"""
  versionId: ID!
  clientMutationId: String
}

type DeleteVersionPayload {
  """The deleted ID."""
  deletedVersionId: ID

  """The parent of the deleted `Version`."""
  opinion: Opinion
  clientMutationId: String
}

"""A district"""
interface District {
  id: ID!
  name(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String!
  geojson: GeoJSON
  geojsonStyle: CssJSON
  displayedOnMap: Boolean!
  border: Style
  background: Style
  translations: [DistrictTranslation!]!
}

input DistrictInput {
  id: ID

  """A GeoJSON format to display in map after."""
  geojson: GeoJSON

  """Should I display this on map?"""
  displayedOnMap: Boolean = false

  """The border style attached to this district."""
  border: BorderStyleInput

  """The background style attached to this district."""
  background: BackgroundStyleInput

  """The names of the district for each language"""
  translations: [DistrictTranslationInput!]!
}

"""Ordering options for districts returned from the connection."""
enum DistrictOrderField {
  """Allows ordering a list of districts in an alphabetical order."""
  ALPHABETICAL

  """Allows ordering a list of districts by when they were created."""
  CREATED_AT
}

"""A translation of a District."""
type DistrictTranslation {
  locale: String!
  name: String!
}

input DistrictTranslationInput {
  id: ID
  locale: String!
  name: String
}

"""Entities that can be drafted."""
interface Draftable {
  """The ID of an object"""
  id: ID!

  """Whether or not the entity is a draft."""
  draft: Boolean!

  """Identifies when the entity was undraft at."""
  undraftAt: DateTime
}

input DuplicateProjectInput {
  id: ID!
  clientMutationId: String
}

type DuplicateProjectPayload {
  """The old project."""
  oldProject: Project

  """The new cloned project."""
  newProject: Project
  clientMutationId: String
}

"""Available errors on duplicateProposalForm mutation."""
enum DuplicateProposalFormErrorCode {
  """
  The requested `ProposalForm` does not exist or you have no rights on it.
  """
  NOT_FOUND
}

input DuplicateProposalFormInput {
  """The id of the `ProposalForm` to duplicate."""
  id: ID!
  clientMutationId: String
}

type DuplicateProposalFormPayload {
  """Available errors on duplicateProposalForm mutation."""
  error: DuplicateProposalFormErrorCode

  """The cloned `ProposalForm`."""
  duplicatedProposalForm: ProposalForm
  clientMutationId: String
}

"""A contribution with an author"""
interface EditableContribution {
  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime
}

"""A string containing an email."""
scalar Email

"""Fetches an object given its ID"""
type EmailDomain implements Node {
  """The ID of an object"""
  id: ID!

  """The email domain value"""
  value: String!

  """The associated registration form for this email domain"""
  registrationForm: RegistrationForm
}

input EmailDomainInput {
  """The email domain value"""
  value: String!
}

"""An emailing campaign"""
type EmailingCampaign implements Node {
  """uuid of the emailing campaign"""
  id: ID!

  """name of the emailing campaign"""
  name: String!

  """the email of the sender"""
  senderEmail: Email!

  """the name displayed of the sender"""
  senderName: String!

  """the object of the email"""
  object: String!

  """the content of the email"""
  content: HTML!

  """Unlayer configuration in json format."""
  unlayerConf: JSON

  """the list of users who shall receive the email"""
  mailingList: MailingList

  """an internal list used instead of a mailing list"""
  mailingInternal: EmailingCampaignInternalList

  """the date when the email has been sent or shall be"""
  sendAt: DateTime

  """the status of the campaign"""
  status: EmailingCampaignStatus!

  """preview of the email"""
  preview: HTML
}

"""A connection to a list of items."""
type EmailingCampaignConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [EmailingCampaignEdge]
}

"""An edge in a connection."""
type EmailingCampaignEdge {
  """The item at the end of the edge."""
  node: EmailingCampaign!

  """A cursor for use in pagination."""
  cursor: String!
}

"""The available automated emailing lists"""
enum EmailingCampaignInternalList {
  """All users registered."""
  REGISTERED

  """Users registered but with email not confirmed."""
  NOT_CONFIRMED

  """Only confirmed users."""
  CONFIRMED
}

"""Ways in which lists of campaigns can be ordered upon return."""
input EmailingCampaignOrder {
  """The field to order users by."""
  field: EmailingCampaignOrderField! = SEND_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Properties by which campaigns can be ordered"""
enum EmailingCampaignOrderField {
  """
  Allows ordering a list of campaign by when they have been sent or shall be sent.
  """
  SEND_AT
}

"""The possible status of an emailing campaign"""
enum EmailingCampaignStatus {
  """not scheduled"""
  DRAFT

  """already sent"""
  SENT

  """scheduled"""
  PLANNED

  """archived"""
  ARCHIVED
}

"""3 possible values"""
enum EmailingCampaignStatusFilter {
  """campaigns not scheduled"""
  DRAFT

  """campaigns already sent"""
  SENT

  """campaigns scheduled"""
  PLANNED
}

input EvaluateProposalAssessmentInput {
  """The id of the proposal to evaluate."""
  proposalId: ID!

  """The proposal assessment's body."""
  body: String

  """The estimated budget for the proposal."""
  estimatedCost: Int

  """The proposal assessment's official response."""
  officialResponse: String!
  clientMutationId: String

  """The decision about the proposal assessment."""
  decision: ProposalAssessmentDecision!
}

type EvaluateProposalAssessmentPayload {
  """The evaluated proposal."""
  assessment: ProposalAssessment

  """Contains the error code if one occurred."""
  errorCode: ProposalStatementErrorCode
  clientMutationId: String
}

"""A Evaluation form (question)"""
type EvaluationForm {
  """The ID of an object"""
  id: ID! @deprecated(reason: "Type `EvaluationForm` will be removed. TODO This type belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")

  """The title of evaluation form (question)"""
  title: String! @deprecated(reason: "Type `EvaluationForm` will be removed. TODO This type belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")

  """The description of evaluation form"""
  description: String @deprecated(reason: "Type `EvaluationForm` will be removed. TODO This type belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")

  """List of questions in the evaluation form"""
  questions: [Question!]! @deprecated(reason: "Type `EvaluationForm` will be removed. TODO This type belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")
}

"""An event."""
type Event implements Node & UniformResourceLocatable & Commentable {
  """The ID of an object."""
  id: ID!

  """The url of the event"""
  url: URI!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """Did the viewer author this entity."""
  viewerDidAuthor: Boolean

  """Identifies the author of the event."""
  author: User

  """The start date of the event."""
  startAt: DateTime! @deprecated(reason: "Field `startAt` will be removed. Use `timeRange.startAt` instead. This field has been moved. Removal on 2020-03-01 UTC.")

  """The end date of the event."""
  endAt: DateTime @deprecated(reason: "Field `endAt` will be removed. Use `timeRange.endAt` instead. This field has been moved. Removal on 2020-03-01 UTC.")

  """Whether or not this event is published."""
  enabled: Boolean!

  """Identifies the latitude of the event."""
  lat: Float @deprecated(reason: "Field `lat` will be removed. Use `googleMapsAddress.lat`  instead. This field use our legacy address format. Removal on 2020-03-01 UTC.")

  """Identifies the longitude of the event."""
  lng: Float @deprecated(reason: "Field `lng` will be removed. Use `googleMapsAddress.lng` instead. This field use our legacy address format. Removal on 2020-03-01 UTC.")

  """Identifies the zip code of the event."""
  zipCode: String @deprecated(reason: "Field `zipCode` will be removed. Use `googleMapsAddress` instead. This field use our legacy address format. Removal on 2020-03-01 UTC.")

  """Identifies the address of the event."""
  fullAddress: String @deprecated(reason: "will be deleted Removal on 2020-03-01 UTC.")

  """Identifies the address of the event in google Maps format."""
  googleMapsAddress: GoogleMapsAddress

  """The translations availables for this event"""
  translations: [EventTranslation!]!

  """Identifies the title of the event."""
  title: String!

  """Identifies the body of the event."""
  body: HTML!

  """Identifies the registration link of the event."""
  link: URI

  """The comments related to the commentable."""
  comments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: CommentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): CommentConnection!

  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!

  """The event admin edit url"""
  adminUrl: URI!

  """A list of Users that are participating to the event."""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ParticipantConnection!
  themes: [Theme!]!
  projects: [Project!]!
  commentable: Boolean!
  media: Media
  address: String @deprecated(reason: "will be deleted Removal on 2020-03-01 UTC.")
  addressJson: String
  guestListEnabled: Boolean!
  customCode: String
  city: String @deprecated(reason: "will be deleted Removal on 2020-03-01 UTC.")
  country: String @deprecated(reason: "will be deleted Removal on 2020-03-01 UTC.")

  """User submitted events must be reviewed by an admin"""
  review: EventReview

  """The delete date."""
  deletedAt: DateTime

  """The jitsi admin/animator token if there is one"""
  jitsiToken: String

  """Whether or not this event is presential."""
  isPresential: Boolean!

  """Whether or not this event has a public recording URL."""
  isRecordingPublished: Boolean!

  """The jitsi room name available on remote events only."""
  roomName: String

  """The URL used to stream this event recording."""
  recordingUrl: URI

  """The slug of event"""
  slug: String!
  metaDescription: String

  """Author of event agree to use personal data for event only"""
  authorAgreeToUsePersonalDataForEventOnly: Boolean

  """Admin authorize data transfer"""
  adminAuthorizeDataTransfer: Boolean

  """Show if user is already participating at event"""
  isViewerParticipatingAtEvent: Boolean!

  """The jitsi room animator available on remote events only."""
  animator: User

  """The steps corresponding to this event."""
  steps: [Step!]!

  """Wheter or not registration is enabled on this event."""
  isRegistrationPossible: Boolean

  """Wheter or not the viewer can join the room before it starts."""
  viewerIsRoomAnimator: Boolean!

  """The owner of the event."""
  owner: EventOwner

  """The event status."""
  reviewStatus: EventReviewStatus

  """The url to export participants"""
  exportParticipantsUrl: URI
}

"""The affiliation of a user to a event"""
enum EventAffiliation {
  """Events that are owned by the authenticated user."""
  OWNER
}

"""A connection to a list of items."""
type EventConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [EventEdge]
}

"""An edge in a connection."""
type EventEdge {
  """The item at the end of the edge."""
  node: Event!

  """A cursor for use in pagination."""
  cursor: String!
}

input EventInput {
  startAt: String
  endAt: String
  authorEmail: String!
  themes: [ID!]!
  projects: [ID!]!
  guestListEnabled: Boolean!
  enabled: Boolean!
  commentable: Boolean!
  zipCode: String
  address: String
  customCode: String
  city: String
  country: String
  translations: [EventTranslationInput]
  title: String
  body: HTML
  link: URI
  metaDescription: String
}

"""Ways in which lists of events can be ordered upon return."""
input EventOrder {
  """The field in which to order nodes by."""
  field: EventOrderField! = START_AT

  """The direction in which to order nodes."""
  direction: OrderDirection! = DESC
}

"""Ordering options for events returned from the connection."""
enum EventOrderField {
  """Order by the end date of the time range."""
  END_AT

  """Order by the start date of the time range."""
  START_AT
}

"""Represent an owner of a Event."""
interface EventOwner {
  """User ID"""
  id: ID!

  """User username"""
  username: String

  """Get all events that the user owns."""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for events returned from the connection.
    For example, OWNER will include only events that the current viewer owns.
    
    """
    affiliations: [EventAffiliation!]

    """the search query"""
    search: String

    """The ordering direction for events."""
    orderBy: EventOrder = {field: START_AT, direction: DESC}

    """Filter events by a given status."""
    status: EventStatus = null

    """only fetch where user is author"""
    onlyWhenAuthor: Boolean = false
  ): EventConnection!
}

"""Type of refused event reason"""
enum EventRefusedReason {
  """The associated event review has been flagged as sexual content"""
  SEX

  """The associated event review has been flagged as offending content"""
  OFFENDING

  """The associated event review has been flagged as spam"""
  SPAM

  """The associated event review has been flagged as syntax error"""
  SYNTAX_ERROR

  """The associated event review has been flagged as wrong content"""
  WRONG_CONTENT

  """The associated event review has been flagged as off topic"""
  OFF_TOPIC

  """The associated event review has not been flagged"""
  NONE
}

"""A Review on an event."""
type EventReview {
  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!

  """The ID of an object."""
  id: ID!

  """Identifies the user who review"""
  reviewer: User

  """The details of reason why the review is refused"""
  comment: String

  """Kind of review is refused."""
  refusedReason: EventRefusedReason

  """The status of review."""
  status: EventReviewStatus!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """Identifies the date and time when the object was updated."""
  updatedAt: DateTime
}

"""Event Review status"""
enum EventReviewStatus {
  """The review is in approved status."""
  APPROVED

  """The review is in awaiting status."""
  AWAITING

  """The review is in refused status."""
  REFUSED

  """The event is published"""
  PUBLISHED

  """The event is not published"""
  NOT_PUBLISHED

  """The event deleted"""
  DELETED
}

"""List of available filters to filter `Event`"""
enum EventStatus {
  """Filter by approved status."""
  APPROVED

  """Filter by awaiting status."""
  AWAITING

  """Filter by refused status."""
  REFUSED

  """Filter by deleted status."""
  DELETED
}

"""Translation of an event."""
type EventTranslation {
  """IETF code of the translation of the event."""
  locale: String!
  title: String!

  """Identifies the body of the event."""
  body: HTML!

  """Identifies the registration link of the event."""
  link: URI

  """The slug of event"""
  slug: String!
  metaDescription: String
}

input EventTranslationInput {
  """the id of the event"""
  id: ID

  """the locale of the translation"""
  locale: String!

  """the translated title of the event"""
  title: String

  """the translated body of the event"""
  body: HTML!

  """the localized link of the event"""
  link: URI
  metaDescription: String
}

"""A configuration of an external service used by platform"""
type ExternalServiceConfiguration {
  """type of the configuration."""
  type: ExternalServiceConfigurationType!

  """value of the configuration."""
  value: String!
}

"""possible types for ExternalServiceConfiguration."""
enum ExternalServiceConfigurationType {
  """Choice of the external mailer client : mandrill or mailjet."""
  MAILER
}

"""Facebook SSO Configuration."""
type FacebookSSOConfiguration implements Node & SSOConfiguration {
  """The ID of an object."""
  id: ID!

  """The name of configured SSO."""
  name: String!

  """Does this configuration is enabled?"""
  enabled: Boolean!

  """Profile URL on the SSO side."""
  profileUrl: URI

  """Color in hexadecimal of SSO button."""
  buttonColor: Color!

  """Color in hexadecimal of label SSO button."""
  labelColor: Color!

  """Client ID."""
  clientId: String

  """Secret key."""
  secret: String
}

"""A feature flag."""
type FeatureFlag {
  type: FeatureFlagType!
  enabled: Boolean!
}

"""The possible types for a feature flag."""
enum FeatureFlagType {
  graphql_query_analytics
  new_feature_questionnaire_result
  blog
  calendar
  captcha
  consent_external_communication
  developer_documentation
  public_api
  login_facebook
  login_paris
  privacy_policy
  members_list
  newsletter
  profiles
  projects_form
  project_trash
  search
  share_buttons
  shield_mode
  registration
  restrict_registration_via_email_domain
  themes
  export
  districts
  user_type
  votes_evolution
  server_side_rendering
  zipcode_at_register
  indexation
  consultation_plan
  consent_internal_communication
  disconnect_openid
  sso_by_pass_auth
  allow_users_to_propose_events
  login_franceconnect
  restrict_connection
  secure_password
  read_more
  remind_user_account_confirmation
  display_pictures_in_depository_proposals_list
  display_pictures_in_event_list
  external_project
  app_news
  sentry_log
  multilangue
  unstable__admin_editor
  unstable__analysis
  http_redirects
  report_browers_errors_to_sentry
  login_saml
  login_cas
  login_openid
  phone_confirmation
  reporting
  display_map
  unstable__remote_events
  votes_min
  majority_vote_question
  unstable__emailing
  unstable__emailing_parameters

  """Whether or not an admin can use `DebateStep`. Used in dev only."""
  unstable__debate
  proposal_revisions

  """Whether or not an admin can use `TIPSmeee`. Used in dev only."""
  unstable__tipsmeee

  """Whether or not the new consultation page is active."""
  unstable__new_consultation_page

  """Whether or not the new project card is active."""
  unstable__new_project_card

  """Secret export of users."""
  export_legacy_users

  """Whether or not admin can mass import proposals in BO."""
  import_proposals

  """Whether or not the analytics page is visible in BO."""
  unstable__analytics_page

  """Whether or not admin can use the project administrator feature."""
  unstable_project_admin
}

"""Require a firstname"""
type FirstnameRequirement implements Node & Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!

  """The firstname of the viewer."""
  viewerValue: String
}

input FollowOpinionInput {
  """The opinion id"""
  opinionId: ID!

  """The type of notification"""
  notifiedOf: SubscriptionTypeValue!
  clientMutationId: String
}

type FollowOpinionPayload {
  opinion: OpinionOrVersion
  followerEdge: FollowerEdge
  clientMutationId: String
}

input FollowProposalInput {
  """The proposal id"""
  proposalId: ID!

  """The type of notification"""
  notifiedOf: SubscriptionTypeValue!
  clientMutationId: String
}

type FollowProposalPayload {
  proposal: Proposal
  followerEdge: FollowerEdge
  clientMutationId: String
}

"""A follower"""
type Follower {
  proposal: Proposal
  opinion: Opinion
  user: User!
  notifiedOf: SubscriptionTypeValue
}

"""A connection to a list of items."""
type FollowerConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [FollowerEdge]
}

"""An edge in a connection."""
type FollowerEdge {
  """The item at the end of the edge."""
  node: User!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which follower connections can be ordered."""
input FollowerOrder {
  """The field in which to order nodes by."""
  field: FollowerOrderField!

  """The direction in which to order nodes."""
  direction: OrderDirection! = ASC
}

"""Properties by which follower connections can be ordered"""
enum FollowerOrderField {
  """Allows ordering a list of followers namely."""
  NAME

  """Allows ordering a list of followers by when they were followed."""
  FOLLOWED_AT

  """Allows ordering a list of followers randomly."""
  RANDOM
}

"""Fetches an object given its ID"""
type Font {
  """The ID of an object."""
  id: ID!

  """The font name"""
  name: String!

  """The associated font file"""
  file: Media

  """Is the font used for headings?"""
  useAsHeading: Boolean!

  """Is the font used for body?"""
  useAsBody: Boolean!

  """Is the font uploaded by user?"""
  isCustom: Boolean!
}

"""For or against."""
enum ForOrAgainstValue {
  """An against value"""
  AGAINST

  """A for value"""
  FOR
}

"""Geolocalization formatted informations."""
type FormattedGeolocalization {
  """The author country name."""
  countryName: String

  """The author region name."""
  regionName: String

  """The author city name."""
  cityName: String
}

"""Many possible values"""
enum FranceConnectAllowedData {
  """Fields firstname"""
  given_name

  """Fields lastname"""
  family_name

  """Fields birth date"""
  birthdate

  """Fields birth place"""
  birthplace

  """Fields birth country"""
  birthcountry

  """Fields gender"""
  gender

  """Fields email"""
  email

  """Fields username"""
  preferred_username
}

"""France Connect SSO Configuration."""
type FranceConnectSSOConfiguration implements Node & SSOConfiguration {
  """The ID of an object."""
  id: ID!

  """The name of configured SSO."""
  name: String!

  """Does this configuration is enabled?"""
  enabled: Boolean!

  """Profile URL on the SSO side."""
  profileUrl: URI

  """Color in hexadecimal of SSO button."""
  buttonColor: Color!

  """Color in hexadecimal of label SSO button."""
  labelColor: Color!

  """Client ID."""
  clientId: String

  """Secret key."""
  secret: String

  """Authorization URL."""
  authorizationUrl: URI!

  """Access token URL."""
  accessTokenUrl: URI!

  """User info URL."""
  userInfoUrl: URI!

  """Logout URL."""
  logoutUrl: URI

  """Environment mode."""
  environment: SSOEnvironment!

  """Redirect URI callback."""
  redirectUri: URI!

  """Unattended DataChoice as array."""
  allowedData: [FranceConnectAllowedData!]!
}

"""3 possible values"""
enum GenderValue {
  MALE
  FEMALE
  OTHER
}

input GenerateJitsiRoomMutationInput {
  """Event id."""
  eventId: ID
  clientMutationId: String
}

type GenerateJitsiRoomMutationPayload {
  """The jitsi room name."""
  roomName: String!

  """The jitsi token"""
  jitsiToken: String!
  clientMutationId: String
}

"""A string containing GeoJSON code."""
scalar GeoJSON

"""An address from Google Maps."""
type GoogleMapsAddress {
  """The raw response from the Google Maps API that describes an address"""
  json: String!

  """A human-readable address string."""
  formatted: String

  """
  The available types for this address. A type indicate the accuracy of the address on Google Maps.
  """
  types: [GoogleMapsAddressType!]!

  """The latitude of this address."""
  lat: Float!

  """The longitude of this address."""
  lng: Float!
}

"""A list of possible types for a given address from Google Maps."""
enum GoogleMapsAddressType {
  """Returns only the addresses that are characterized as approximate"""
  APPROXIMATE

  """
  Returns only geometric centers of a location such as a polyline (for example, a street) or polygon (region).
  """
  GEOMETRIC_CENTER

  """
  Returns only the addresses that reflect an approximation (usually on a road)
  interpolated between two precise points (such as intersections). An
  interpolated range generally indicates that rooftop geocodes are unavailable
  for a street address.
  """
  RANGE_INTERPOLATED

  """
  Returns only the addresses for which Google has location information accurate down to street address precision.
  """
  ROOFTOP
}

"""A group of User"""
type Group implements Node {
  """The id of the group."""
  id: ID!

  """Identifies the group name."""
  title: String

  """Identifies the description of the group."""
  description: String

  """Get all users of the group."""
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!
  createdAt: DateTime!
  updatedAt: DateTime

  """Get all userInvite who are still pending"""
  pendingInvitations(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserInviteConnection!
}

"""A connection to a list of items."""
type GroupConnection {
  totalCount: Int!
  totalUserCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [GroupEdge]
}

"""An edge in a connection."""
type GroupEdge {
  """The item at the end of the edge."""
  node: Group!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A string containing HTML code."""
scalar HTML

"""Section projects page in admin"""
type HomePageProjectsSectionConfiguration {
  """The ID of an object."""
  id: ID!

  """The title of the section"""
  title: String

  """The subtitle of the section"""
  teaser: String

  """The position of the section in the homepage"""
  position: Int!

  """How to display the proposals"""
  displayMode: HomePageProjectsSectionConfigurationDisplayMode!

  """Number of objects to display"""
  nbObjects: Int!

  """Whether it is published or not"""
  enabled: Boolean!
  projects: ProjectConnection!
}

enum HomePageProjectsSectionConfigurationDisplayMode {
  """
  display the most recents projects in the projects section of the homepage
  """
  MOST_RECENT

  """
  allow the admin to choose which projects to display in the projects section of the homepage
  """
  CUSTOM
}

input HomePageProjectsSectionConfigurationTranslationInput {
  """The title of the section"""
  title: String!

  """The subtitle of the section"""
  teaser: String

  """the locale of the translation"""
  locale: String!
  clientMutationId: String
}

"""A string containing an IP address."""
scalar IP

"""Requires an identification code"""
type IdentificationCodeRequirement implements Node & Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!

  """Does viewer got identification code"""
  viewerHasCode: Boolean!
}

input InviteUsersInput {
  """Set the maximum results to return"""
  maxResults: Int = 100

  """The list of emails to invite"""
  emails: [String!]!

  """The newly invited users role"""
  role: InviteUsersRole!

  """Users will be invited to join these groups"""
  groups: [ID]!
  clientMutationId: String
}

type InviteUsersPayload {
  """The newly added user invitations edge"""
  newInvitations: [UserInviteEdge!]!

  """The updated user invitations edge"""
  updatedInvitations: [UserInviteEdge!]!
  clientMutationId: String
}

"""Available roles for an `inviteUsers` mutation."""
enum InviteUsersRole {
  """Give the user the `ROLE_USER` role."""
  ROLE_USER

  """Give the user the `ROLE_ADMIN` role."""
  ROLE_ADMIN

  """Give the user the `ROLE_PROJECT_ADMIN` role."""
  ROLE_PROJECT_ADMIN
}

"""A string containing JSON code."""
scalar JSON

"""Ways in which a question jump can be ordered."""
input JumpsOrder {
  """The field in which to order jumps by."""
  field: JumpsOrderField

  """The direction in which to order jumps."""
  direction: OrderDirection
}

"""Properties by which question jumps can be ordered"""
enum JumpsOrderField {
  """Allows ordering a list of question jumps by its position."""
  POSITION
}

"""Requires a lastname"""
type LastnameRequirement implements Node & Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!

  """The lastname of the viewer."""
  viewerValue: String
}

"""An available locale"""
type Locale {
  """uuid of the locale"""
  id: ID!

  """The key for translations of the title"""
  traductionKey: String!

  """The IETF reference code for the locale"""
  code: TranslationLocale!

  """True if admins can use this locale"""
  isEnabled: Boolean!

  """True if users can use this locale"""
  isPublished: Boolean!

  """True if the locale is used by default"""
  isDefault: Boolean!
}

"""A connection to a list of items."""
type LocaleConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [LocaleEdge]
}

"""An edge in a connection."""
type LocaleEdge {
  """The item at the end of the edge."""
  node: Locale

  """A cursor for use in pagination."""
  cursor: String!
}

input LocaleStatusInput {
  """locale ID."""
  id: ID!

  """Whether or not this locale is enabled"""
  isEnabled: Boolean

  """Whether or not this locale is published"""
  isPublished: Boolean
  clientMutationId: String
}

"""A logic jump in a question."""
type LogicJump {
  id: ID!

  """Return the question that trigger this logic jump."""
  origin: Question!

  """Return the question which this logic jump leads to."""
  destination: Question!

  """
  Return the necessited conditions that needs to be fullfiled to trigger this logic jump.
  """
  conditions: [MultipleChoiceQuestionLogicJumpCondition!]!

  """Return the position of this logic jump."""
  position: Int!
}

"""A particular condition in a logic jump."""
interface LogicJumpCondition {
  id: ID!

  """Return the operator for this condition."""
  operator: LogicJumpConditionOperator!

  """
  Return the question which is going to be tested against the condition.
  """
  question: Question!
}

"""A particular condition in a logic jump."""
input LogicJumpConditionInput {
  id: ID

  """The operator used to check the condition"""
  operator: LogicJumpConditionOperator!

  """The id of the question you want to have a condition"""
  question: ID!

  """The answer the selected question should have to trigger the condition"""
  value: String
}

"""Possible operator for a logic jump condition"""
enum LogicJumpConditionOperator {
  """Allows to test an equality."""
  IS

  """Allows to test the opposite of an equality test."""
  IS_NOT
}

input LogicJumpInput {
  id: ID
  always: Boolean

  """The id of the question where the logic jump start"""
  origin: ID!

  """
  The id of the question where the logic jump end if the conditions are fulfilled
  """
  destination: ID!

  """
  A collection of conditions that you have to fulfill for displaying the destination question
  """
  conditions: [LogicJumpConditionInput]
}

"""A list of users to send email"""
type MailingList implements Node {
  """uuid of the mailing list"""
  id: ID!

  """name of the mailing list"""
  name: String!

  """users in the mailing list"""
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Filter the list by consent to internal communication"""
    consentInternalCommunicationOnly: Boolean = false
  ): UserConnection!

  """the project from which the list has been built, if any"""
  project: Project

  """false if used in a planned or sent email campaign"""
  isDeletable: Boolean
}

"""A connection to a list of items."""
type MailingListConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [MailingListEdge]
}

"""An edge in a connection."""
type MailingListEdge {
  """The item at the end of the edge."""
  node: MailingList!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Data corresponding to one majority question choice"""
type MajorityChoice {
  choice: MajorityChoiceType!
  count: Int!
}

"""Majority choice type"""
enum MajorityChoiceType {
  """The review is in approved status."""
  VERY_WELL

  """The review is in awaiting status."""
  WELL

  """The review is in refused status."""
  WELL_ENOUGH

  """The review is in refused status."""
  PASSABLE

  """The review is in refused status."""
  NOT_PASSABLE

  """The review is in refused status."""
  REJECTED
}

"""A majority question"""
type MajorityQuestion implements Question & Node {
  """The ID of an object"""
  id: ID!

  """Identifies the question title."""
  title: String!

  """Return responses on this questions."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get responses with user not confirmed"""
    withNotConfirmedUser: Boolean = false

    """Get responses in which the term appears."""
    term: String
  ): ResponseConnection!
  number: Int!
  type: QuestionTypeValue!

  """The position of the question"""
  position: Int!
  private: Boolean!
  required: Boolean!
  helpText: String
  description: String
  kind: String!
  slug: String!

  """Return users who answered the question"""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get participant with user not confirmed"""
    withNotConfirmedUser: Boolean = false
  ): ParticipantConnection!

  """The associated logic jumps to this question."""
  jumps(
    """Ordering options for question jumps."""
    orderBy: JumpsOrder = {field: POSITION, direction: ASC}
  ): [LogicJump!]!

  """The jumps of which this question is the destination"""
  destinationJumps: [LogicJump!]!

  """The destination of the always jump (the else case) of this question."""
  alwaysJumpDestinationQuestion: Question

  """Boolean to decide whether the question will be rendered or not"""
  hidden: Boolean!

  """
  Return an array of MajorityCategories containing the total of responses for each choices.
  """
  responsesByChoice: [MajorityChoice!]!

  """Return the total of votes."""
  totalVotesCount: Int!
}

"""A map token used for connecting external services with our maps"""
type MapToken implements Node {
  """The ID of an object"""
  id: ID!

  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!

  """The public token"""
  publicToken: String!

  """The secret token"""
  secretToken: String

  """The corresponding provider in which belongs the token"""
  provider: MapTokenProvider

  """
  The style id associated to this map token (available only if a style is applied)
  """
  styleId: ID

  """
  The style owner associated to this map token (available only if a style is applied)
  """
  styleOwner: String

  """The available styles associated to this map token"""
  styles(
    """Filter the styles by its visibility"""
    visibility: MapTokenStyleVisibility
  ): [MapTokenStyle]
  createdAt: DateTime!
  updatedAt: DateTime
}

"""The provider for a map token"""
enum MapTokenProvider {
  """Used for Mapbox service provider"""
  MAPBOX
}

"""A map token style"""
type MapTokenStyle {
  id: ID!

  """The name of the style"""
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime

  """The version of the style"""
  version: Int!

  """The preview url of the style"""
  previewUrl: URI!

  """Does the style is the current one applied to the whole website?"""
  isCurrent: Boolean!

  """The owner of the style"""
  owner: String!

  """The visibility of the style"""
  visibility: MapTokenStyleVisibility!
}

"""The visibility of a style for a map token"""
enum MapTokenStyleVisibility {
  """The style is public"""
  PUBLIC

  """The style is private"""
  PRIVATE
}

"""A media"""
type Media implements UniformResourceLocatable {
  """The URL to this resource."""
  url(
    """The format of the media"""
    format: String
  ): URI!

  """The id of the media."""
  id: ID!
  name: String!
  size: String!
  enabled: Boolean!
  authorName: String
  description: String
  copyright: String
  contentType: String!
  providerReference: String!
  height: Int
  width: Int
}

"""A connection to a list of items."""
type MediaConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [MediaEdge]
}

"""An edge in a connection."""
type MediaEdge {
  """The item at the end of the edge."""
  node: Media!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A media question."""
type MediaQuestion implements Question & Node {
  """The ID of an object"""
  id: ID!

  """Identifies the question title."""
  title: String!

  """Return responses on this questions."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get responses with user not confirmed"""
    withNotConfirmedUser: Boolean = false

    """Get responses in which the term appears."""
    term: String
  ): ResponseConnection!
  number: Int!
  type: QuestionTypeValue!

  """The position of the question"""
  position: Int!
  private: Boolean!
  required: Boolean!
  helpText: String
  description: String
  kind: String!
  slug: String!

  """Return users who answered the question"""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get participant with user not confirmed"""
    withNotConfirmedUser: Boolean = false
  ): ParticipantConnection!

  """The associated logic jumps to this question."""
  jumps(
    """Ordering options for question jumps."""
    orderBy: JumpsOrder = {field: POSITION, direction: ASC}
  ): [LogicJump!]!

  """The jumps of which this question is the destination"""
  destinationJumps: [LogicJump!]!

  """The destination of the always jump (the else case) of this question."""
  alwaysJumpDestinationQuestion: Question

  """Boolean to decide whether the question will be rendered or not"""
  hidden: Boolean!
}

"""A response"""
type MediaResponse implements Response {
  """Nullable ID in case of empty response."""
  id: String

  """Identifies the question of the response."""
  question: Question!

  """Medias"""
  medias: [Media!]!
}

"""A multiple choice question"""
type MultipleChoiceQuestion implements Question & Node {
  """The ID of an object"""
  id: ID!

  """Identifies the question title."""
  title: String!

  """Return responses on this questions."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get responses with user not confirmed"""
    withNotConfirmedUser: Boolean = false

    """Get responses in which the term appears."""
    term: String
  ): ResponseConnection!
  number: Int!
  type: QuestionTypeValue!

  """The position of the question"""
  position: Int!
  private: Boolean!
  required: Boolean!
  helpText: String
  description: String
  kind: String!
  slug: String!

  """Return users who answered the question"""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get participant with user not confirmed"""
    withNotConfirmedUser: Boolean = false
  ): ParticipantConnection!

  """The associated logic jumps to this question."""
  jumps(
    """Ordering options for question jumps."""
    orderBy: JumpsOrder = {field: POSITION, direction: ASC}
  ): [LogicJump!]!

  """The jumps of which this question is the destination"""
  destinationJumps: [LogicJump!]!

  """The destination of the always jump (the else case) of this question."""
  alwaysJumpDestinationQuestion: Question

  """Boolean to decide whether the question will be rendered or not"""
  hidden: Boolean!
  isOtherAllowed: Boolean!

  """Responses of the `other` question choice."""
  otherResponses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ResponseConnection!
  choices(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 9999

    """The searched term in multiple question choices."""
    term: String

    """
    If the question has `randomQuestionChoices: true` will return choices in a random order.
    """
    allowRandomize: Boolean = false
  ): QuestionChoiceConnection!
  validationRule: MultipleChoiceQuestionValidationRule
  randomQuestionChoices: Boolean!

  """
  When the question is of type button, do we disable the colors for the responses
  """
  responseColorsDisabled: Boolean!

  """
  When the question is of type button, do we show the responses in a compact bar instead
  """
  groupedResponsesEnabled: Boolean!

  """
  Return array containing object with number of occurrences by response's keywords.
  """
  tagCloud(
    """Defines the number of aggregation for the tag cloud."""
    size: Int = 20
  ): [TagCloudItem!]!
}

"""A particular condition in a logic jump in a multiple choice question."""
type MultipleChoiceQuestionLogicJumpCondition implements LogicJumpCondition {
  id: ID!

  """Return the operator for this condition."""
  operator: LogicJumpConditionOperator!

  """
  Return the question which is going to be tested against the condition.
  """
  question: Question!

  """
  The value that the condition should meet to be fullfiled (depending on the operator).
  """
  value: QuestionChoice!
}

"""Multiple Choice Question Validation Rule"""
type MultipleChoiceQuestionValidationRule {
  type: MultipleChoiceQuestionValidationRulesTypes!
  number: Int!
}

input MultipleChoiceQuestionValidationRuleInput {
  type: MultipleChoiceQuestionValidationRulesTypes!
  number: Int!
}

"""Available types of validation rules"""
enum MultipleChoiceQuestionValidationRulesTypes {
  MIN
  EQUAL
  MAX
}

"""This is the entry point into performing writes in the schema."""
type Mutation {
  addEvent(input: AddEventInput!): AddEventPayload
  changeEvent(input: ChangeEventInput!): ChangeEventPayload
  deleteEvent(input: DeleteEventInput!): DeleteEventPayload
  deleteAccountByEmail(input: DeleteAccountByEmailInput!): DeleteAccountByEmailPayload
  changeMapProviderToken(input: ChangeMapProviderTokenInput!): ChangeMapProviderTokenPayload
  changeMapStyle(input: ChangeMapStyleInput!): ChangeMapStylePayload
  removeSiteFavicon(input: RemoveSiteFaviconInput!): RemoveSiteFaviconPayload
  changeSiteFavicon(input: ChangeSiteFaviconInput!): ChangeSiteFaviconPayload
  reviewEvent(input: ReviewEventInput!): ReviewEventPayload
  addEvents(input: AddEventsInput!): AddEventsPayload
  addComment(input: AddCommentInput!): AddCommentPayload
  addSourceVote(input: AddSourceVoteInput!): AddSourceVotePayload
  addCommentVote(input: AddCommentVoteInput!): AddCommentVotePayload
  addArgument(input: AddArgumentInput!): AddArgumentPayload
  addArgumentVote(input: AddArgumentVoteInput!): AddArgumentVotePayload
  addSource(input: AddSourceInput!): AddSourcePayload
  addVersion(input: AddVersionInput!): AddVersionPayload
  changeArgument(input: ChangeArgumentInput!): ChangeArgumentPayload
  changeVersion(input: ChangeVersionInput!): ChangeVersionPayload
  changeSource(input: ChangeSourceInput!): ChangeSourcePayload
  deleteArgument(input: DeleteArgumentInput!): DeleteArgumentPayload
  deleteComment(input: DeleteCommentInput!): DeleteCommentPayload
  deleteSource(input: DeleteSourceInput!): DeleteSourcePayload
  deleteOpinion(input: DeleteOpinionInput!): DeleteOpinionPayload
  deleteVersion(input: DeleteVersionInput!): DeleteVersionPayload
  addReply(input: AddReplyInput!): AddReplyPayload
  updateReply(input: UpdateReplyInput!): UpdateReplyPayload
  deleteReply(input: DeleteReplyInput!): DeleteReplyPayload
  changeUserNotificationsConfiguration(input: ChangeUserNotificationsConfigurationInput!): ChangeUserNotificationsConfigurationPayload
  addOpinionVote(input: AddOpinionVoteInput!): AddOpinionVotePayload
  removeOpinionVote(input: RemoveOpinionVoteInput!): RemoveOpinionVotePayload
  removeArgumentVote(input: RemoveArgumentVoteInput!): RemoveArgumentVotePayload
  removeCommentVote(input: RemoveCommentVoteInput!): RemoveCommentVotePayload
  removeSourceVote(input: RemoveSourceVoteInput!): RemoveSourceVotePayload
  addProposalVote(input: AddProposalVoteInput!): AddProposalVotePayload
  removeProposalVote(input: RemoveProposalVoteInput!): RemoveProposalVotePayload
  updateProposalVotes(input: UpdateProposalVotesInput!): UpdateProposalVotesPayload
  changeProposalAssessment(input: ChangeProposalAssessmentInput!): ChangeProposalAssessmentPayload
  evaluateProposalAssessment(input: EvaluateProposalAssessmentInput!): EvaluateProposalAssessmentPayload
  changeProposalDecision(input: ChangeProposalDecisionInput!): ChangeProposalDecisionPayload
  changeProposalAnalysis(input: ChangeProposalAnalysisInput!): ChangeProposalAnalysisPayload
  analyseProposalAnalysis(input: AnalyseProposalAnalysisInput!): AnalyseProposalAnalysisPayload
  requestUserArchive(input: RequestUserArchiveInput!): RequestUserArchivePayload
  changeProposalPublicationStatus(input: ChangeProposalPublicationStatusInput!): ChangeProposalPublicationStatusPayload
  changeProposalContent(input: ChangeProposalContentInput!): ChangeProposalContentPayload
  createProposal(input: CreateProposalInput!): CreateProposalPayload
  addProposalsFromCsv(input: AddProposalsFromCsvInput!): AddProposalsFromCsvPayload
  createProposalFusion(input: CreateProposalFusionInput!): CreateProposalFusionPayload
  updateProposalFusion(input: UpdateProposalFusionInput!): UpdateProposalFusionPayload
  changeProposalNotation(input: ChangeProposalNotationInput!): ChangeProposalNotationPayload
  followProposal(input: FollowProposalInput!): FollowProposalPayload
  followOpinion(input: FollowOpinionInput!): FollowOpinionPayload
  updateFollowProposal(input: UpdateFollowProposalInput!): UpdateFollowProposalPayload
  updateFollowOpinion(input: UpdateFollowOpinionInput!): UpdateFollowOpinionPayload
  unfollowProposal(input: UnfollowProposalInput!): UnfollowProposalPayload
  unfollowOpinion(input: UnfollowOpinionInput!): UnfollowOpinionPayload
  selectProposal(input: SelectProposalInput!): SelectProposalPayload
  unselectProposal(input: UnselectProposalInput!): UnselectProposalPayload
  changeSelectionStatus(input: ChangeSelectionStatusInput!): ChangeSelectionStatusPayload
  changeCollectStatus(input: ChangeCollectStatusInput!): ChangeCollectStatusPayload
  changeProposalProgressSteps(input: ChangeProposalProgressStepsInput!): ChangeProposalProgressStepsPayload
  addProposalsToSteps(input: AddProposalsToStepsInput!): AddProposalsToStepsPayload
  removeProposalsFromSteps(input: RemoveProposalsFromStepsInput!): RemoveProposalsFromStepsPayload
  applyProposalStatus(input: ApplyProposalStatusInput!): ApplyProposalStatusPayload
  deleteProposal(input: DeleteProposalInput!): DeleteProposalPayload
  updateRegistrationForm(input: UpdateRegistrationFormQuestionsInput!): UpdateRegistrationFormQuestionsPayload
  updateRegistrationFormCommunication(input: UpdateRegistrationFormCommunicationInput!): UpdateRegistrationFormCommunicationPayload
  contactProposalAuthor(input: ContactProposalAuthorInput!): ContactProposalAuthorPayload
  changeDistrict(input: ChangeDistrictInput!): ChangeDistrictPayload
  createProposalForm(input: CreateProposalFormInput!): CreateProposalFormPayload
  updateProposalForm(input: UpdateProposalFormInput!): UpdateProposalFormPayload
  deleteProposalForm(input: DeleteProposalFormInput!): DeleteProposalFormPayload
  duplicateProposalForm(input: DuplicateProposalFormInput!): DuplicateProposalFormPayload
  updateProposalFormNotificationsConfiguration(input: UpdateProposalFormNotificationsConfigurationInput!): UpdateProposalFormNotificationsConfigurationPayload
  updateQuestionnaireNotificationsConfiguration(input: UpdateQuestionnaireNotificationConfigurationInput!): UpdateQuestionnaireNotificationConfigurationPayload
  setEvaluationFormInProposalForm(input: SetEvaluationFormInProposalFormInput!): SetEvaluationFormInProposalFormPayload
  updateContactPage(input: UpdateContactPageInput!): UpdateContactPagePayload
  updateRegistrationPage(input: UpdateRegistrationPageInput!): UpdateRegistrationPagePayload
  sendContactForm(input: SendContactFormInput!): SendContactFormPayload
  addContactForm(input: AddContactFormInput!): AddContactFormPayload
  removeContactForm(input: RemoveContactFormInput!): RemoveContactFormPayload
  updateContactForm(input: UpdateContactFormInput!): UpdateContactFormPayload
  createGroup(input: CreateGroupInput!): CreateGroupPayload
  updateGroup(input: UpdateGroupInput!): UpdateGroupPayload
  deleteGroup(input: DeleteGroupInput!): DeleteGroupPayload
  deleteUserInGroup(input: DeleteUserInGroupInput!): DeleteUserInGroupPayload
  addUsersInGroup(input: AddUsersInGroupInput!): AddUsersInGroupPayload
  updateProfile(input: UpdateProfileInput!): UpdateProfilePayload
  updateProfilePassword(input: UpdateProfilePasswordInput!): UpdateProfilePasswordPayload
  updateProfilePersonalData(input: UpdateProfilePersonalDataInput!): UpdateProfilePersonalDataPayload
  updateProfilePublicData(input: UpdateProfilePublicDataInput!): UpdateProfilePublicDataPayload
  deleteAccount(input: DeleteAccountInput!): DeleteAccountPayload
  updateRequirement(input: UpdateRequirementInput!): UpdateRequirementPayload
  createUser(input: CreateUserInput!): CreateUserPayload
  updateUserAccount(input: UpdateUserAccountInput!): UpdateUserAccountPayload
  addUsersToGroupFromEmail(input: AddUsersToGroupFromEmailInput!): AddUsersToGroupFromEmailPayload
  createQuestionnaire(input: CreateQuestionnaireInput!): CreateQuestionnairePayload
  updateQuestionnaireParameters(input: UpdateQuestionnaireParametersInput!): UpdateQuestionnaireParametersPayload
  updateQuestionnaireConfiguration(input: UpdateQuestionnaireConfigurationInput!): UpdateQuestionnaireConfigurationPayload
  deleteQuestionnaire(input: DeleteQuestionnaireInput!): DeleteQuestionnairePayload
  createProject(input: CreateProjectInput!): CreateProjectPayload
  createAlphaProject(input: CreateAlphaProjectInput!): CreateAlphaProjectPayload
  updateAlphaProject(input: UpdateAlphaProjectInput!): UpdateAlphaProjectPayload
  duplicateProject(input: DuplicateProjectInput!): DuplicateProjectPayload
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload
  deleteProject(input: DeleteProjectInput!): DeleteProjectPayload
  createProjectDistrict(input: CreateProjectDistrictInput!): CreateProjectDistrictPayload
  deleteProjectDistrict(input: DeleteProjectDistrictInput!): DeleteProjectDistrictPayload
  updateProjectDistrict(input: UpdateProjectDistrictInput!): CreateProjectDistrictPayload
  deleteMediaAdmin(input: DeleteMediaAdminInput!): DeleteMediaAdminPayload
  updateShieldAdminForm(input: UpdateShieldAdminFormInput!): UpdateShieldAdminFormPayload
  createOauth2SSOConfiguration(input: CreateOauth2SSOConfigurationInput!): CreateOauth2SSOConfigurationPayload
  updateOauth2SSOConfiguration(input: UpdateOauth2SSOConfigurationInput!): UpdateOauth2SSOConfigurationPayload
  deleteSSOConfiguration(input: DeleteSSOConfigurationInput!): DeleteSSOConfigurationPayload
  toggleSSOConfigurationStatus(input: ToggleSSOConfigurationStatusInput!): ToggleSSOConfigurationStatusPayload
  updateFranceConnectSSOConfiguration(input: UpdateFranceConnectSSOConfigurationInput!): UpdateFranceConnectSSOConfigurationPayload
  updateFacebookSSOConfiguration(input: UpdateFacebookSSOConfigurationInput!): UpdateFacebookSSOConfigurationPayload
  updateLocaleStatus(input: UpdateLocaleStatusInput!): UpdateLocaleStatusPayload
  setDefaultLocale(input: SetDefaultLocaleInput!): SetDefaultLocalePayload
  setUserDefaultLocale(input: SetUserDefaultLocaleInput!): SetUserDefaultLocalePayload
  cropMedia(input: CropMediaInput!): CropMediaPayload
  changeFont(input: ChangeFontInput!): ChangeFontPayload
  deleteFont(input: DeleteFontInput!): DeleteFontPayload
  assignSupervisorToProposals(input: AssignSupervisorToProposalsInput!): AssignSupervisorToProposalsPayload
  assignDecisionMakerToProposals(input: AssignDecisionMakerToProposalsInput!): AssignDecisionMakerToProposalsPayload
  configureAnalysis(input: ConfigureAnalysisInput!): ConfigureAnalysisPayload
  updateRedirectIOKey(input: UpdateRedirectIOProjectIdInput!): UpdateRedirectIOProjectIdPayload
  revokeAnalystsToProposals(input: RevokeAnalystsToProposalsInput!): RevokeAnalystsToProposalsPayload
  assignAnalystsToProposals(input: AssignAnalystsToProposalsInput!): AssignAnalystsToProposalsPayload
  subscribeToEventAsNonRegistered(input: SubscribeToEventAsNonRegisteredInput!): SubscribeToEventAsNonRegisteredPayload
  subscribeToEventAsRegistered(input: SubscribeToEventAsRegisteredInput!): SubscribeToEventAsRegisteredPayload
  unsubscribeToEventAsRegistered(input: UnsubscribeToEventAsRegisteredInput!): UnsubscribeToEventAsRegisteredPayload
  generateJitsiRoomMutation(input: GenerateJitsiRoomMutationInput!): GenerateJitsiRoomMutationPayload
  updateProfileAccountEmail(input: UpdateProfileAccountEmailInput!): UpdateProfileAccountEmailPayload
  updateProfileAccountLocale(input: UpdateProfileAccountLocaleInput!): UpdateProfileAccountLocalePayload

  """Invite users in the application"""
  inviteUsers(input: InviteUsersInput!): InviteUsersPayload

  """Cancel user invitation in the application"""
  cancelUserInvitations(input: CancelUserInvitationsInput!): CancelUserInvitationsPayload

  """Reset password"""
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
  removeSso(input: RemoveSsoInput!): RemoveSsoPayload
  createMailingList(input: CreateMailingListInput!): CreateMailingListPayload
  deleteMailingList(input: DeleteMailingListInput!): DeleteMailingListPayload
  createEmailingCampaign(input: CreateEmailingCampaignInput!): CreateEmailingCampaignPayload
  deleteEmailingCampaigns(input: DeleteEmailingCampaignsInput!): DeleteEmailingCampaignsPayload
  updateEmailingCampaign(input: UpdateEmailingCampaignInput!): UpdateEmailingCampaignPayload
  sendEmailingCampaign(input: SendEmailingCampaignInput!): SendEmailingCampaignPayload
  testEmailingCampaign(input: TestEmailingCampaignInput!): TestEmailingCampaignPayload
  cancelEmailingCampaign(input: CancelEmailingCampaignInput!): CancelEmailingCampaignPayload
  updateOfficialResponse(input: UpdateOfficialResponseInput!): UpdateOfficialResponsePayload
  deleteOfficialResponse(input: DeleteOfficialResponseInput!): DeleteOfficialResponsePayload
  addDebateOpinion(input: AddDebateOpinionInput!): AddDebateOpinionPayload
  updateDebateOpinion(input: UpdateDebateOpinionInput!): UpdateDebateOpinionPayload
  deleteDebateOpinion(input: DeleteDebateOpinionInput!): DeleteDebateOpinionPayload
  addDebateVote(input: AddDebateVoteInput!): AddDebateVotePayload

  """
  Delete a debate vote from the current user, will also delete the debate argument, if any.
  """
  removeDebateVote(input: RemoveDebateVoteInput!): RemoveDebateVotePayload
  createDebateArgument(input: CreateDebateArgumentInput!): CreateDebateArgumentPayload
  updateDebateArgument(input: UpdateDebateArgumentInput!): UpdateDebateArgumentPayload
  deleteDebateArgument(input: DeleteDebateArgumentInput!): DeleteDebateArgumentPayload
  createDebateAnonymousArgument(input: CreateDebateAnonymousArgumentInput!): CreateDebateAnonymousArgumentPayload
  deleteDebateAnonymousArgument(input: DeleteDebateAnonymousArgumentInput!): DeleteDebateAnonymousArgumentPayload
  sendConfirmationEmailDebateAnonymousArgument(input: SendConfirmationEmailDebateAnonymousArgumentInput!): SendConfirmationEmailDebateAnonymousArgumentPayload
  addDebateArgumentVote(input: AddDebateArgumentVoteInput!): AddDebateArgumentVotePayload
  removeDebateArgumentVote(input: RemoveDebateArgumentVoteInput!): RemoveDebateArgumentVotePayload
  askProposalRevision(input: AskProposalRevisionInput!): AskProposalRevisionPayload
  report(input: ReportInput!): ReportPayload
  trash(input: TrashInput!): TrashPayload
  untrash(input: UnTrashInput!): UnTrashPayload
  addProposalNews(input: AddProposalNewsInput!): AddProposalNewsPayload
  updateProposalNews(input: UpdateProposalNewsInput!): UpdateProposalNewsPayload
  deleteProposalNews(input: DeleteProposalNewsInput!): DeleteProposalNewsPayload
  addDebateAnonymousVote(input: AddDebateAnonymousVoteInput!): AddDebateAnonymousVotePayload
  removeDebateAnonymousVote(input: RemoveDebateAnonymousVoteInput!): RemoveDebateAnonymousVotePayload

  """Edit projects section in admin"""
  updateHomePageProjectsSectionConfiguration(input: UpdateHomePageProjectsSectionConfigurationInput!): UpdateHomePageProjectsSectionConfigurationPayload

  """User registration"""
  register(input: RegisterInput!): RegisterPayload

  """Cancel email change"""
  cancelEmailChange: CancelEmailChangePayload

  """Re-send email confirmation"""
  resendEmailConfirmation: ResendEmailConfirmationPayload

  """Toggle a feature"""
  toggleFeature(input: ToggleFeatureInput!): ToggleFeaturePayload

  """Register email domains"""
  registerEmailDomains(input: RegisterEmailDomainsInput!): RegisterEmailDomainsPayload

  """Create new Opinion"""
  createOpinion(input: CreateOpinionInput!): CreateOpinionPayload

  """Update Opinion"""
  updateOpinion(input: UpdateOpinionInput!): UpdateOpinionPayload

  """Update an external service configuration."""
  updateExternalServiceConfiguration(input: UpdateExternalServiceConfigurationInput!): UpdateExternalServiceConfigurationPayload

  """Create a senderEmailDomain."""
  createSenderEmailDomain(input: CreateSenderEmailDomainInput!): CreateSenderEmailDomainPayload

  """Delete a senderEmailDomain."""
  deleteSenderEmailDomain(input: DeleteSenderEmailDomainInput!): DeleteSenderEmailDomainPayload

  """Add an email to address to send emails."""
  createSenderEmail(input: CreateSenderEmailInput!): CreateSenderEmailPayload

  """select a senderEmail as the one to send emails"""
  selectSenderEmail(input: SelectSenderEmailInput!): SelectSenderEmailPayload

  """update a SiteParameter."""
  updateSiteParameter(input: UpdateSiteParameterInput!): UpdateSiteParameterPayload

  """Create blog post"""
  createPost(input: CreatePostInput!): CreatePostPayload

  """Update blog post"""
  updatePost(input: UpdatePostInput!): UpdatePostPayload

  """Delete blog post"""
  deletePost(input: DeletePostInput!): DeletePostPayload

  """Update social networks on a proposal"""
  updateProposalSocialNetworks(input: UpdateProposalSocialNetworksInput!): UpdateProposalSocialNetworksPayload

  """Create a proposal from back office"""
  createProposalFromBackOffice(input: CreateProposalFromBackOfficeInput!): CreateProposalPayload

  """Update illustration on a proposal"""
  updateProposalIllustration(input: UpdateProposalIllustrationInput!): UpdateProposalIllustrationPayload
}

"""A connection to a list of items."""
type NewsConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [NewsEdge]
}

"""An edge in a connection."""
type NewsEdge {
  """The item at the end of the edge."""
  node: Post!

  """A cursor for use in pagination."""
  cursor: String!
}

input NewsTranslationInput {
  title: String!
  body: HTML!

  """abstract of proposal news"""
  abstract: String

  """the locale of the translation"""
  locale: TranslationLocale!
}

"""Fetches an object given its ID"""
interface Node {
  """The ID of an object"""
  id: ID!
}

"""Possible reason that a `Publishable` is not published."""
enum NotPublishedReason {
  """Author account was confirmed after the step has ended."""
  AUTHOR_CONFIRMED_TOO_LATE

  """Author account isn't confirmed and the step has ended."""
  AUTHOR_NOT_CONFIRMED

  """Author account isn't confirmed yet."""
  WAITING_AUTHOR_CONFIRMATION
}

"""A user without account."""
type NotRegistered {
  """Email of the user."""
  email: String

  """Username of the user."""
  username: String
}

"""A notifications configuration"""
type NotificationsConfiguration {
  onCreate: Boolean!
  onUpdate: Boolean!
  onDelete: Boolean!
  onCommentCreate: Boolean!
  onCommentUpdate: Boolean!
  onCommentDelete: Boolean!
  onProposalNewsCreate: Boolean!
  onProposalNewsUpdate: Boolean!
  onProposalNewsDelete: Boolean!
  email: Email
}

"""Oauth2 SSO Configuration."""
type Oauth2SSOConfiguration implements Node & SSOConfiguration {
  """The ID of an object."""
  id: ID!

  """The name of configured SSO."""
  name: String!

  """Does this configuration is enabled?"""
  enabled: Boolean!

  """Profile URL on the SSO side."""
  profileUrl: URI

  """Color in hexadecimal of SSO button."""
  buttonColor: Color!

  """Color in hexadecimal of label SSO button."""
  labelColor: Color!

  """Client ID."""
  clientId: String

  """Secret key."""
  secret: String

  """Authorization URL."""
  authorizationUrl: URI!

  """Access token URL."""
  accessTokenUrl: URI!

  """User info URL."""
  userInfoUrl: URI!

  """Logout URL."""
  logoutUrl: URI

  """Redirect URI callback."""
  redirectUri: URI!
}

"""An official response"""
type OfficialResponse implements Node {
  """The ID of an object"""
  id: ID!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  body(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): HTML

  """if the response is published"""
  isPublished: Boolean!

  """Identifies the date and time when the object was or will be published"""
  publishedAt: DateTime

  """The response's authors."""
  authors: [User!]!

  """The proposal linked to the official response"""
  proposal: Proposal!
}

"""A contribution"""
type Opinion implements Node & Contribution & Publishable & Argumentable & Sourceable & Reportable & Trashable & ContributionWithAuthor & EditableContribution {
  """The ID of an object"""
  id: ID!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """Url of the contribution"""
  url: URI!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """true if the contribution is pinned."""
  pinned: Boolean!

  """Identifies the contribution title."""
  title: String!

  """Identifies the body of the contribution."""
  body: HTML!

  """Identifies the body of the contribution rendered to text."""
  bodyText: String!

  """The related project."""
  project: Project
  contribuable: Boolean!

  """The arguments related to the argumentable."""
  arguments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ArgumentOrder = {field: PUBLISHED_AT, direction: DESC}

    """If provided, returns the arguments of this particular type."""
    type: ArgumentValue

    """The connection will return the trashed results too."""
    includeTrashed: Boolean = false
  ): ArgumentConnection!

  """The unpublished arguments of to the viewer."""
  viewerArgumentsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """If provided, returns the arguments of this particular type."""
    type: ArgumentValue
  ): ArgumentConnection
  step: ConsultationStep!

  """The sources related to the sourceable."""
  sources(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: SourceOrder = {field: PUBLISHED_AT, direction: DESC}
  ): SourceConnection!

  """
  The viewer unpublished sources related to the sourceable (only visible by viewer).
  """
  viewerSourcesUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): SourceConnection!

  """The available sources categories of to the sourceable."""
  availableSourceCategories: [SourceCategory]

  """Does the viewer already submitted a report ?"""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """The author of the contribution."""
  author: User!

  """Followers connection"""
  followers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: FollowerOrder = {field: FOLLOWED_AT, direction: DESC}
  ): FollowerConnection

  """The following viewer confiuration configuration."""
  viewerFollowingConfiguration: SubscriptionTypeValue

  """Either or not the viewer is following the content."""
  viewerIsFollowing: Boolean!

  """The kind of description."""
  kind: String!

  """The viewer vote."""
  viewerVote: OpinionVote
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ProposalVoteOrder = {field: PUBLISHED_AT, direction: DESC}

    """Filters vote by value"""
    value: YesNoPairedVoteValue
  ): YesNoPairedVoteConnection!

  """The versions related to the contribution."""
  versions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: VersionOrder = {field: PUBLISHED_AT, direction: DESC}
  ): VersionConnection!

  """The viewer versions related to the contribution."""
  viewerVersionsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: VersionOrder = {field: PUBLISHED_AT, direction: DESC}
  ): VersionConnection!

  """Where the proposition has been placed."""
  section: Section!
  answer: Answer
  position: Int
  ranking: Int
  modals: [OpinionModal]
  appendices: [Appendix]
}

"""A connection to a list of items."""
type OpinionConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [OpinionEdge]
}

"""An edge in a connection."""
type OpinionEdge {
  """The item at the end of the edge."""
  node: Opinion!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A contribution"""
type OpinionModal {
  """Identifies the contribution title."""
  key: String!

  """Identifies the contribution title."""
  after: String!

  """Identifies the contribution title."""
  before: String!
  title: String!
  diff: HTML
}

union OpinionOrVersion = Opinion | Version

"""Ways in which opinion connections can be ordered."""
input OpinionOrder {
  """The field in which to order nodes by."""
  field: OpinionOrderField!

  """The direction in which to order nodes."""
  direction: OrderDirection! = ASC
}

"""Properties by which opinion connections can be ordered"""
enum OpinionOrderField {
  """Allows ordering a list of opinions by position."""
  POSITIONS

  """Allows ordering a list of opinions randomly."""
  RANDOM

  """Allows ordering a list of opinions by when they were created."""
  PUBLISHED_AT

  """Allows ordering a list of opinions by the number of votes it have."""
  VOTES

  """Allows ordering a list of opinions by the number of votes OK it have."""
  VOTES_OK

  """Allows ordering a list of opinions by the number of comments it have."""
  COMMENTS
}

"""Entities that can be published."""
type OpinionVote implements YesNoPairedVote & Publishable & Vote {
  """The ID of an object"""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution."""
  author: User

  """The contribution that was voted."""
  related: Contribution

  """Returns 'opinionVote'."""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason
  value: YesNoPairedVoteValue!
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderDirection {
  """Specifies an ascending order for a given `orderBy` argument."""
  ASC

  """Specifies a descending order for a given `orderBy` argument."""
  DESC
}

"""A step inside a project."""
type OtherStep implements Node & Step {
  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The ID of an object"""
  id: ID!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI
}

"""A page."""
type Page implements UniformResourceLocatable {
  """The URL to this resource."""
  url: URI!

  """The ID of an object"""
  id: ID!
  title(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String
  body(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String
  translations: [PageTranslation!]!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A translation page."""
type PageTranslation {
  locale: String!
  title: String
  body: String
}

"""User and NotRegistered"""
union Participant = User | NotRegistered

"""A connection to a list of items."""
type ParticipantConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ParticipantEdge]
}

"""An edge in a connection."""
type ParticipantEdge {
  registeredAt: DateTime!
  registeredAnonymously: Boolean!

  """The item at the end of the edge."""
  node: Participant!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Requires a phone"""
type PhoneRequirement implements Node & Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!

  """The phone of the viewer."""
  viewerValue: String
}

"""Represent a set of analytics for a platform"""
type PlatformAnalytics {
  """Get the registrations analytics of the platform."""
  registrations: PlatformAnalyticsRegistrations

  """Get the votes analytics of the platform."""
  votes: PlatformAnalyticsVotes

  """Get the comments analytics of the platform."""
  comments: PlatformAnalyticsComments

  """Get the contributions analytics of the platform."""
  contributions: PlatformAnalyticsContributions

  """Get the followers analytics of the platform."""
  followers: PlatformAnalyticsFollowers

  """Get the visitors analytics of the platform."""
  visitors: PlatformAnalyticsVisitors

  """Get the page views analytics of the platform."""
  pageViews: PlatformAnalyticsPageViews

  """Get the traffic sources analytics of the platform."""
  trafficSources: PlatformAnalyticsTrafficSources

  """Get the most visited pages analytics of the platform."""
  mostVisitedPages: PlatformAnalyticsMostVisitedPages

  """Get the contributors analytics of the platform."""
  contributors: PlatformAnalyticsContributors

  """Get the anonymous contributors analytics of the platform."""
  anonymousContributors: PlatformAnalyticsAnonymousContributors

  """Get the top contributors analytics of the platform."""
  topContributors: [PlatformAnalyticsTopContributor!]

  """Get the most used proposal categories analytics of the platform."""
  mostUsedProposalCategories: PlatformAnalyticsMostUsedProposalCategories
}

"""Represent the anonymous contributors for a platform"""
type PlatformAnalyticsAnonymousContributors {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent the comments analytics for a platform"""
type PlatformAnalyticsComments {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent the contributions analytics for a platform"""
type PlatformAnalyticsContributions {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent a contribution made by a contributor"""
type PlatformAnalyticsContributorContribution {
  """The related contribution type"""
  type: PlatformAnalyticsContributorContributionType!

  """The total count of the contribution type."""
  totalCount: Int!
}

"""Represent a type of a contributor contribution"""
enum PlatformAnalyticsContributorContributionType {
  """The contribution is a reply"""
  REPLY

  """The contribution is a proposal"""
  PROPOSAL

  """The contribution is a comment"""
  COMMENT

  """The contribution is an opinion"""
  OPINION

  """The contribution is an opinion version"""
  OPINION_VERSION

  """The contribution is an argument"""
  ARGUMENT

  """The contribution is a debate argument"""
  DEBATE_ARGUMENT

  """The contribution is a source"""
  SOURCE
}

"""Represent the contributors for a platform"""
type PlatformAnalyticsContributors {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent the followers analytics for a platform"""
type PlatformAnalyticsFollowers {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent the most used proposal categories for a platform"""
type PlatformAnalyticsMostUsedProposalCategories {
  """The total count of the most used proposal categories."""
  totalCount: Int!

  """The most used proposal categories with their total count."""
  values: [PlatformAnalyticsMostUsedProposalCategory!]!
}

"""Represent a proposal category and how much it has been used"""
type PlatformAnalyticsMostUsedProposalCategory {
  """The related category."""
  category: ProposalCategory!

  """How much this category has been used."""
  totalCount: Int!
}

"""Represent the most visited pages for a platform"""
type PlatformAnalyticsMostVisitedPages {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent the page views for a platform"""
type PlatformAnalyticsPageViews {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent the registrations analytics for a platform"""
type PlatformAnalyticsRegistrations {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent a top contributor with it's contributions for a platform"""
type PlatformAnalyticsTopContributor {
  """The contributor."""
  user: User!

  """The associated contributions of the contributor."""
  contributions(first: Int = 2): [PlatformAnalyticsContributorContribution!]!
}

"""Represent a traffic source"""
type PlatformAnalyticsTrafficSource {
  """The related traffic source type."""
  type: PlatformAnalyticsTrafficSourceType!

  """The total count of this traffic source."""
  totalCount: Int!
}

"""Represent a type of a traffic source"""
enum PlatformAnalyticsTrafficSourceType {
  """The traffic source came from a search engine"""
  SEARCH_ENGINE

  """The traffic source came from a direct link"""
  DIRECT

  """The traffic source came from an external link"""
  EXTERNAL_LINK

  """The traffic source came from a social network"""
  SOCIAL_NETWORK

  """The traffic source came from an email"""
  EMAIL
}

"""Represent the different traffic sources for a platform"""
type PlatformAnalyticsTrafficSources {
  """The total count of all the traffic sources combined."""
  totalCount: Int!

  """The available traffic sources with their total count."""
  sources: [PlatformAnalyticsTrafficSource!]!
}

"""Represent the visitors analytics for a platform"""
type PlatformAnalyticsVisitors {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""Represent the votes analytics for a platform"""
type PlatformAnalyticsVotes {
  totalCount: Int!
  values: [AggregatedResult!]!
}

"""A commentable"""
type Post implements Node & UniformResourceLocatable & UniformResourceAdminLocatable & Commentable {
  """The ID of an object"""
  id: ID!

  """The URL to this resource."""
  url: URI!

  """The admin url for this post."""
  adminUrl: URI!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """The post's title."""
  title(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String

  """Identifies the date and time when the object was published."""
  publishedAt: DateTime

  """The post's authors."""
  authors: [User!]!

  """The publication status for this post."""
  publicationStatus: PostPublicationStatus!

  """Wether or not the post is commentable."""
  commentable: Boolean!

  """Abstract of the post."""
  abstract(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String!

  """The post's related media."""
  media: Media

  """The post's related themes."""
  themes: [Theme!]!
  body(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): HTML
  translations: [PostTranslation!]!

  """The comments related to the commentable."""
  comments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: CommentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): CommentConnection!
  displayedOnBlog: Boolean!
  relatedContent: [PostRelatedContent!]!
  viewerDidAuthor: Boolean!
  customCode: String
  isPublished: Boolean!
  metaDescription(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String

  """The owner of the post."""
  owner: PostOwner
}

"""The affiliation of a user to a post"""
enum PostAffiliation {
  """Posts that are owned by the authenticated user."""
  OWNER
}

"""A connection to a list of items."""
type PostConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [PostEdge]
}

"""An edge in a connection."""
type PostEdge {
  """The item at the end of the edge."""
  node: Post!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of posts can be ordered upon return."""
input PostOrder {
  """The field to order posts by."""
  field: PostOrderField! = UPDATED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Properties by which posts can be ordered"""
enum PostOrderField {
  """Allows ordering a list of posts by when they have been updated."""
  UPDATED_AT
}

"""Represent an owner of a post."""
interface PostOwner {
  """User ID"""
  id: ID!

  """User username"""
  username: String

  """Get all posts that the user owns."""
  posts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for posts returned from the connection.
    For example, OWNER will include only posts that the current viewer owns.
    
    """
    affiliations: [PostAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for posts"""
    orderBy: PostOrder = {field: UPDATED_AT, direction: DESC}
  ): PostConnection!
}

"""Available publication statuses for a post."""
enum PostPublicationStatus {
  """Normal status, publicly visible"""
  PUBLISHED

  """Not publicly visible"""
  NOT_PUBLISHED
}

"""A related content for a post"""
union PostRelatedContent = Theme | Proposal | Project

"""A translation post."""
type PostTranslation {
  """The post translation related locale."""
  locale: TranslationLocale!

  """The title of the post translation."""
  title: String

  """The body of the post translation."""
  body: HTML

  """Abstract of the post translation."""
  abstract: String
  metaDescription: String
  slug: String
}

"""Requires a postal address"""
type PostalAddressRequirement implements Node & Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!

  """The postal address of the viewer."""
  viewerAddress: GoogleMapsAddress
}

"""A step inside a project."""
type PresentationStep implements Node & Step {
  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The ID of an object"""
  id: ID!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI
}

"""A vote that can be anonymous."""
interface PrivatableVote {
  """Whether the author of the vote is anonymous or not."""
  private: Boolean @deprecated(reason: "Field `private` will be removed. Use `anonymous` instead. This field has been renamed. Removal on 2020-01-01 UTC.")

  """Whether the author of the vote is anonymous or not."""
  anonymous: Boolean!
}

"""A budget contribution"""
type ProgressStep {
  id: ID!
  title: String!
  startAt: DateTime!
  endAt: DateTime
}

input ProgressStepInput {
  title: String!
  startAt: DateTime!
  endAt: DateTime
}

"""A participatory project."""
type Project implements Node & UniformResourceLocatable & UniformResourceAdminLocatable {
  """The ID of an object."""
  id: ID!

  """The URL to this resource."""
  url: URI!

  """Identifies the title of the project."""
  title: String!

  """Identifies when the project was published at."""
  publishedAt: DateTime!

  """A list of votes associated with the project."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Wether it retrieves anonymous votes or not."""
    anonymous: Boolean = null
  ): VoteConnection!

  """A list of contributors associated with the project."""
  contributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for contributors returning from the connection."""
    orderBy: UserOrder = {field: CREATED_AT, direction: DESC}

    """The step in which the user has contributed."""
    step: ID

    """Does the user has verified his account."""
    vip: Boolean

    """The user type to filter by."""
    userType: ID

    """Search contributor by his email, username, lastname"""
    term: String
  ): UserConnection!

  """Count of contributions associated with the project."""
  contributionsCount: Int! @deprecated(reason: "Field `contributionsCount` will be removed. Use `contributions.totalCount` instead when it will be published. In preparation for an upcoming change to the way we expose counters, this field will only be available inside a connection. Removal on 2020-04-01 UTC.")

  """Contributions associated with the project."""
  contributions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Filter contributions by a specific type."""
    type: ContributionType
    orderBy: ContributionOrder = {field: CREATED_AT, direction: DESC}
  ): ContributionConnection!

  """The cover image associated with the project."""
  cover: Media

  """The type associated with the project."""
  type: ProjectType

  """The different steps associated with the project."""
  steps(orderBy: StepOrder = {field: POSITION, direction: ASC}): [Step!]!

  """The list of users who authored the project."""
  authors: [User!]!

  """The admin URL to this resource."""
  adminUrl: URI!

  """A list of proposals associated to the object."""
  proposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    If non-null, filters proposals with the given trashed status (eg: visible, not visible).
    """
    trashedStatus: ProposalTrashedStatus = NOT_TRASHED

    """
    ID of a User to filter by. If non-null, only proposals authored by this user will be returned.
    """
    author: ID

    """Ordering options for proposals returned from the connection."""
    orderBy: ProposalOrder = {field: PUBLISHED_AT, direction: ASC}

    """(ROLE_ADMIN only) Select also draft proposals."""
    includeDraft: Boolean = false

    """
    The state of the proposals to filter by. If non-null, filters proposals with the given state.
    """
    state: ProposalsState

    """
    ID of a ProposalDistrict to filter by. If non-null, filters proposals with the given district.
    """
    district: ID

    """
    ID of a UserType to filter by. If non-null, filters proposals with the given type of author.
    """
    userType: ID

    """
    ID of a ProposalCategory to filter by. If non-null, filters proposals with the given category.
    """
    category: ID

    """
    ID of a ProposalStatus to filter by. If non-null, filters proposals with the given status.
    """
    status: ID

    """
    ID of a Theme to filter by. If non-null, filters proposals with the given theme.
    """
    theme: ID

    """If non-null, filters proposals with the given string to look for."""
    term: String

    """Affiliation options for proposals returned from the connection."""
    affiliations: [ProposalAffiliation]

    """(ROLE_SUPER_ADMIN only) Select also unpublished proposals."""
    includeUnpublished: Boolean = false

    """The global progress status of the proposal."""
    progressStatus: ProposalProgressState

    """The analysts's ids assigned to the proposal"""
    analysts: [ID!]

    """The supervisor's id assigned to the proposal"""
    supervisor: ID

    """The decision-maker's id assigned to the proposal"""
    decisionMaker: ID

    """
    ID of a Step to filter by. If non-null, filters proposals with the given step.
    """
    step: ID
  ): ProposalConnection!

  """The viewer unpublished proposals (only visible by viewer)."""
  viewerProposalsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection

  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!
  hasAnalysis: Boolean!
  metaDescription: String

  """Slug of a project"""
  slug: String!
  video: String

  """Identifies the first collect step of the project, if any."""
  firstCollectStep: CollectStep

  """Identifies the first debate step of the project, if any."""
  firstDebateStep: DebateStep

  """Identifies the first analysis step of the project, if any."""
  firstAnalysisStep: ProposalStep
  hasParticipativeStep(
    """
    If specified, get if the project is participative while excluding the
    specified step. It allows to know if a particular step is the only
    participative step in project.
    """
    exceptStepId: ID = null
  ): Boolean!
  themes: [Theme!]
  votableSteps: [ProposalStep!]!

  """The visibility of the project."""
  visibility: ProjectVisibility!
  adminAlphaUrl: URI!

  """State of activation of Opinion subscription."""
  opinionCanBeFollowed: Boolean!

  """Viewers that can access the project, null otherwise."""
  restrictedViewers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): GroupConnection

  """Linking table with position for district"""
  districts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProjectDistrictConnection

  """The comments related to the project."""
  comments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """The connection will return only the trashed results."""
    onlyTrashed: Boolean = false
    orderBy: CommentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): CommentConnection!
  isVotesCounterDisplayable: Boolean!
  isContributionsCounterDisplayable: Boolean!
  isParticipantsCounterDisplayable: Boolean!

  """Whether it's an external project or not."""
  isExternal: Boolean!

  """URL of the external project."""
  externalLink: URI

  """Contributions count of the external project."""
  externalContributionsCount: Int

  """Participant count of the external project."""
  externalParticipantsCount: Int

  """Vote count of the external project."""
  externalVotesCount: Int

  """The header's format of the project."""
  headerType: ProjectHeaderType

  """The cover filter opacity percent value."""
  coverFilterOpacityPercent: Int

  """the locale for the project, if any"""
  locale: Locale

  """Get all assigned proposals of the viewer."""
  viewerAssignedProposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    term: String
    theme: ID
    district: ID
    analysts: [ID!]
    supervisor: ID
    decisionMaker: ID
    category: ID
    orderBy: ProposalOrder = {field: CREATED_AT, direction: DESC}

    """The current status of the proposal"""
    state: ProposalTaskState
  ): ProposalConnection!

  """list of analysts assigned on the project"""
  analysts: [User]!

  """list of supervisors assigned on the project"""
  supervisors: [User]!

  """list of decision makers assigned on the project"""
  decisionMakers: [User]!

  """list of proposal categories on the project"""
  categories: [ProposalCategory!]!

  """list of exportable steps in the project"""
  exportableSteps: [ProjectAbstractStep]!

  """The current step of the step timeline."""
  currentStep: Step

  """if it is archived"""
  archived: Boolean!

  """The owner of the project."""
  owner: ProjectOwner
  exportContributorsUrl: URI
}

"""A project abstract step."""
type ProjectAbstractStep {
  """The ID of an object"""
  id: ID!

  """The step of the association"""
  step: Step!

  """The step's position"""
  position: Int
}

"""The affiliation of a user to a project"""
enum ProjectAffiliation {
  """Projects that are owned by the authenticated user."""
  OWNER

  """Projects where the user is assigned as author."""
  AUTHOR
}

"""A connection to a list of items."""
type ProjectConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ProjectEdge]
}

"""A project district"""
type ProjectDistrict implements District {
  id: ID!
  name(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String!
  geojson: GeoJSON
  geojsonStyle: CssJSON
  displayedOnMap: Boolean!
  border: Style
  background: Style
  translations: [DistrictTranslation!]!
}

"""A connection to a list of items."""
type ProjectDistrictConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ProjectDistrictEdge]
}

"""An edge in a connection."""
type ProjectDistrictEdge {
  """The item at the end of the edge."""
  node: ProjectDistrict

  """A cursor for use in pagination."""
  cursor: String!
}

"""An edge in a connection."""
type ProjectEdge {
  """The item at the end of the edge."""
  node: Project!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Describe the type of the project's header."""
enum ProjectHeaderType {
  """The project's header cover take the entire width."""
  FULL_WIDTH

  """
  The project's thumbnail take half the width next to the project's informations.
  """
  THUMBNAIL
}

"""Ways in which project can be ordered."""
input ProjectOrder {
  """The direction in which to order nodes."""
  direction: OrderDirection! = DESC

  """The field in which to order nodes by."""
  field: ProjectOrderField! = PUBLISHED_AT
}

"""Ordering options for projects returned from the connection."""
enum ProjectOrderField {
  """Allows ordering a list of projects by their number of contributions."""
  POPULAR

  """Allows ordering a list of projects by when they were published."""
  PUBLISHED_AT
}

"""Represent an owner of a project."""
interface ProjectOwner {
  id: ID!
  username: String

  """Get all projects that the user owns."""
  projects(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for projects returned from the connection.
    For example, OWNER will include only projects that the current viewer owns.
    
    """
    affiliations: [ProjectAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for posts"""
    orderBy: ProjectOwnerProjectOrder = {direction: DESC, field: PUBLISHED_AT}

    """
    ID of a Status to filter by. If non-null, filter projects by statuses.
    """
    status: ID
  ): ProjectConnection!
}

"""Ways in which project in admin list can be ordered."""
input ProjectOwnerProjectOrder {
  """The direction in which to order nodes."""
  direction: OrderDirection! = DESC

  """The field in which to order nodes by."""
  field: ProjectOwnerProjectOrderField! = PUBLISHED_AT
}

"""Ordering options for projects returned from the connection."""
enum ProjectOwnerProjectOrderField {
  """Allows ordering a list of projects by when they were published."""
  PUBLISHED_AT
}

input ProjectStepInput {
  type: ConcreteStepType!
  id: ID
  title: String!
  label: String!
  startAt: DateTime
  endAt: DateTime
  body: HTML
  metaDescription: String
  customCode: String
  isEnabled: Boolean!
  requirements: [StepRequirementInput!]!
  requirementsReason: String
  timeless: Boolean
  consultations: [ID]
  votesHelpText: String
  voteType: ProposalStepVoteType
  budget: Float

  """Maximum number of votes a user can submit."""
  votesLimit: Int

  """
  Minimum number of votes a user must submit for his votes to be counted.
  """
  votesMin: Int
  votesRanking: Boolean
  voteThreshold: Int
  defaultSort: ProposalSort
  allowAuthorsToAddNews: Boolean
  allowingProgressSteps: Boolean
  statuses: [StepStatusInput]

  """the default view : grid, list or map"""
  mainView: String
  private: Boolean
  proposalForm: ID
  defaultStatus: ID
  questionnaire: ID
  footer: HTML
  nbOpinionsToDisplay: Int
  nbVersionsToDisplay: Int
  isAnonymousParticipationAllowed: Boolean
  articles: [DebateArticleInput]
  debateType: DebateType
  debateContent: String
}

"""Label of a Project."""
type ProjectType {
  """Id of project Type"""
  id: ID!

  """Title of project Type"""
  title: String!

  """Slug of project Type"""
  slug: String!

  """Color of project Type"""
  color: String!
}

"""4 possible values"""
enum ProjectVisibility {
  """visible for group admin"""
  ADMIN

  """the project is restricted to users groups"""
  CUSTOM

  """visible for me only"""
  ME

  """visible for all"""
  PUBLIC
}

"""Represents a type that can be retrieved by a URL on the admin."""
type Proposal implements Node & Publishable & UniformResourceLocatable & Trashable & Draftable & Contribution & Commentable & Reportable & UniformResourceAdminLocatable {
  """The ID of an object."""
  id: ID!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """Url of the contribution"""
  url: URI!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """Identifies proposals as draft."""
  draft: Boolean!

  """Identifies when the entity was undraft at."""
  undraftAt: DateTime

  """Identifies the proposal title."""
  title: String!

  """Identifies the author of the contribution."""
  author: User!

  """Identifies the body of the proposal."""
  body: HTML

  """Identifies the responses of the proposal."""
  responses: [Response]!

  """Identifies the unique reference of the proposal."""
  reference(
    """Show the full reference?"""
    full: Boolean
  ): String!

  """Analysts's analysis of the proposal."""
  analyses: [ProposalAnalysis!]

  """The decision of the decision-maker on the analysis of the proposal."""
  decision: ProposalDecision

  """The supervisor's assessment on the analysis of the proposal."""
  assessment: ProposalAssessment

  """List of votes of the proposal."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """The ordering options for votes."""
    orderBy: ProposalVoteOrder = {field: PUBLISHED_AT, direction: DESC}

    """If provided, retrieve only in this step."""
    stepId: ID

    """(ROLE_SUPER_ADMIN only) Select also unpublished votes."""
    includeUnpublished: Boolean = false

    """(ROLE_SUPER_ADMIN only) Select also not accounted votes."""
    includeNotAccounted: Boolean = false
  ): ProposalVoteConnection!

  """List of selections (step an status) of the proposal."""
  selections: [ProposalSelection!]!

  """The address of the proposal."""
  address: GoogleMapsAddress

  """The theme of the proposal."""
  theme: Theme

  """The category of the proposal, related to the ProposalForm."""
  category: ProposalCategory

  """Identifies the summary of the contribution."""
  summary: String

  """Identifies the body of the contribution rendered to text."""
  bodyText: String

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The comments related to the commentable."""
  comments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: CommentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): CommentConnection!

  """Does the viewer already submitted a report ?"""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """Followers connection"""
  followers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for followers returning from the connection"""
    orderBy: FollowerOrder = {field: FOLLOWED_AT, direction: DESC}
  ): UserConnection!

  """Identifies the viewer following configuration on the entity."""
  viewerFollowingConfiguration: SubscriptionTypeValue

  """Identifies if the viewer is following the entity."""
  viewerIsFollowing: Boolean!

  """The admin URL to this resource."""
  adminUrl: URI

  """Did the viewer author this entity."""
  viewerDidAuthor: Boolean

  """Link of Web page."""
  webPageUrl: URI

  """Link of Facebook page."""
  facebookUrl: URI

  """Link of Twitter page."""
  twitterUrl: URI

  """Link of Instagram page."""
  instagramUrl: URI

  """Link of LinkedIn profile."""
  linkedInUrl: URI

  """Link of Youtube channel."""
  youtubeUrl: URI
  progressSteps: [ProgressStep!]!
  evaluers: [Group!]! @deprecated(reason: "Field `evaluers` will be removed. TODO This field belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")
  currentVotableStep: ProposalStep
  viewerIsAnEvaluer: Boolean! @deprecated(reason: "Field `evaluers` will be removed. TODO This field belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")
  news(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ProposalOrder = {field: PUBLISHED_AT, direction: DESC}
  ): NewsConnection!
  officialResponse: OfficialResponse

  """The related project."""
  project: Project
  status(
    """Used to get the status on a selection step."""
    step: ID
  ): ProposalStepStatus
  likers: [User!]!
  estimation: Float
  media: Media
  district: ProposalDistrict

  """The delete date."""
  deletedAt: DateTime

  """The update user."""
  updatedBy: User

  """The publication status for this proposal."""
  publicationStatus: ProposalPublicationStatus!

  """Identifies the preview text of the contribution."""
  summaryOrBodyExcerpt: String

  """Identifies the form where the contribution was submitted."""
  form: ProposalForm!

  """Identifies the answers to an evaluation form."""
  evaluation: ProposalEvaluation @deprecated(reason: "Field `viewerCanSeeEvaluation` will be removed. TODO This field belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")

  """Check if the proposal has been merged with another"""
  hasBeenMerged: Boolean

  """If the proposal is a fusion, contains the list of merged proposals."""
  mergedFrom: [Proposal!]!

  """If the proposal is listed in a fusion, contains the list of fusions."""
  mergedIn: [Proposal!]!
  postsCount: Int!
  viewerCanSeeEvaluation: Boolean! @deprecated(reason: "Field `viewerCanSeeEvaluation` will be removed. TODO This field belongs to our legacy evaluation tool. Removal on 2020-01-01 UTC.")
  viewerHasVote(
    """The concerned step."""
    step: ID!
  ): Boolean!
  viewerVote(
    """The concerned step."""
    step: ID!
  ): ProposalVote
  votableSteps: [ProposalStep!]!

  """The supervisor of the proposal."""
  supervisor: User

  """Does the user can evaluate the current proposal."""
  viewerCanEvaluate: Boolean!

  """The decision maker of the proposal."""
  decisionMaker: User

  """Does the user can give the final decision on the current proposal."""
  viewerCanDecide: Boolean!

  """The analysts assigned to the proposal."""
  analysts: [User!]

  """Does the user can analyse the current proposal."""
  viewerCanAnalyse: Boolean!

  """The proposal global progress status."""
  progressStatus: ProposalProgressState!

  """The proposal's related revision in pending state."""
  revisions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """If null, get revisions in done and pending state"""
    state: ProposalRevisionState = null
  ): ProposalRevisionConnection!

  """Viewer can contribute to the proposal"""
  contribuable: Boolean!

  """The ID of tipsmeee."""
  tipsmeeeId: String

  """Return all tipsmeee related data."""
  tipsmeee: TipsMeee
  isProposalAuthorAllowedToAddNews: Boolean!

  """
  True if proposal got any social network value and proposal form using any social networks.
  """
  isProposalUsingAnySocialNetworks: Boolean!
}

"""The affiliation of a user to a proposal"""
enum ProposalAffiliation {
  """Show only the proposals where the current user is an owner"""
  OWNER

  """Show only the proposals where the current user is an evaluer"""
  EVALUER
}

"""A proposal analysis."""
type ProposalAnalysis {
  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """The proposal's analysis id."""
  id: ID!

  """The related proposal."""
  proposal: Proposal!

  """The last updated by a analyst."""
  analyst: User!

  """The estimated cost of the related proposal in ."""
  estimatedCost: Int

  """The proposal's analysis comment."""
  comment: String

  """The current state of the analysis."""
  state: ProposalAnalysisState!

  """The analysis responses."""
  responses: [Response!]!
}

"""Available decisions value for a proposal analysis."""
enum ProposalAnalysisDecision {
  """The proposal's assessment state is favourable."""
  FAVOURABLE

  """The proposal's assessment state is unfavourable."""
  UNFAVOURABLE

  """The proposal's assessment state is unfavourable."""
  NONE
}

"""The possible states for a proposal analysis."""
enum ProposalAnalysisState {
  """The proposal's analysis is currently being edited"""
  IN_PROGRESS

  """The proposal's related analysis state is favourable."""
  FAVOURABLE

  """The proposal's related analysis state is unfavourable."""
  UNFAVOURABLE

  """The proposal's related analysis has been not made in time."""
  TOO_LATE

  """The analysis has not begun."""
  NONE
}

"""A proposal assessment."""
type ProposalAssessment {
  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """The proposal's assessment id."""
  id: ID!

  """The related proposal."""
  proposal: Proposal!

  """The last updated by a supervisor."""
  supervisor: User!

  """The current state of the assessment."""
  state: ProposalAssessmentState!

  """The body of the assessment."""
  body: String

  """The estimated cost of the related proposal in ."""
  estimatedCost: Int

  """The official response of the proposal assessment."""
  officialResponse: String
}

"""Available decisions value for a proposal analysis related statement."""
enum ProposalAssessmentDecision {
  """The proposal's assessment state is favourable."""
  FAVOURABLE

  """The proposal's assessment state is unfavourable."""
  UNFAVOURABLE
}

"""Possible values of a proposal's assessment state."""
enum ProposalAssessmentState {
  """The proposal's assessment is currently being edited"""
  IN_PROGRESS

  """The proposal's related statement state is favourable."""
  FAVOURABLE

  """The proposal's related statement state is unfavourable."""
  UNFAVOURABLE

  """The evaluation of the proposal was not issued in time."""
  TOO_LATE
}

"""Available errors on proposal assignment related mutations."""
enum ProposalAssignmentErrorCode {
  """You dont have access to revoke supervisor."""
  ACCESS_DENIED_TO_REVOKE_SUPERVISOR

  """You dont have access to assign supervisor."""
  ACCESS_DENIED_TO_ASSIGN_SUPERVISOR

  """You dont have access to revoke decision maker."""
  ACCESS_DENIED_TO_REVOKE_DECISION_MAKER

  """You dont have access to assign decision maker."""
  ACCESS_DENIED_TO_ASSIGN_DECISION_MAKER

  """You cant revoke yourself"""
  CANT_REVOKE_YOURSELF

  """
  You dont have permission to revoke analyst with analysis in progress .
  """
  IN_PROGRESS_ANALYSIS_REVOKE_ANALYST_DENIED

  """You dont have access to assign analyst."""
  ACCESS_DENIED_TO_ASSIGN_ANALYST

  """You cant add more 10 analysts."""
  MAX_ANALYSTS_REACHED
}

"""A proposal category"""
type ProposalCategory {
  """Identifies the name of the category."""
  name: String!
  id: ID!
  color: String!
  icon: String

  """Get the associated illustration of the category"""
  categoryImage: CategoryImage
}

input ProposalCategoryInput {
  id: ID
  name: String!
  color: AvailableProposalCategoryColor!
  icon: AvailableProposalCategoryIcon

  """The category image id to illustrate"""
  categoryImage: ID

  """The image id to transform as new categoryImage"""
  newCategoryImage: ID
}

"""Get the options for a proposal category within a proposal form"""
type ProposalCategoryOptions {
  """
  Get the list of the possible colors for a category within this proposal form
  """
  colors: [AvailableProposalCategoryColor!]!

  """
  Get the list of the possible icons for a category within this proposal form
  """
  icons: [AvailableProposalCategoryIcon!]!
}

"""A connection to a list of items."""
type ProposalConnection {
  totalCount: Int!
  fusionCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ProposalEdge]
}

"""A proposal decision."""
type ProposalDecision {
  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """The proposal's decision id."""
  id: ID!

  """The related proposal."""
  proposal: Proposal!

  """The last updated by a decision-maker."""
  decisionMaker: User!

  """The current state of the decision."""
  isApproved: Boolean!

  """The estimated cost of the related proposal in ."""
  estimatedCost: Int

  """The related official response."""
  post: OfficialResponse @deprecated(reason: "Field `post` will be removed. Use `officialResponse` instead. Replaced by OfficialResponse Removal on 2020-11-13 UTC.")

  """The related official response."""
  officialResponse: OfficialResponse

  """The current status of the decision on the proposal"""
  state: ProposalDecisionState!

  """The step's related status assigned to the proposal."""
  refusedReason: ProposalStepStatus
}

"""Possible values of a proposal's decision state."""
enum ProposalDecisionState {
  """The proposal's decision is currently being edited"""
  IN_PROGRESS

  """The proposal's related decision state is favourable."""
  DONE
}

"""A proposal district"""
type ProposalDistrict implements District {
  id: ID!
  name(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String!
  geojson: GeoJSON
  geojsonStyle: CssJSON
  displayedOnMap: Boolean!
  border: Style
  background: Style
  translations: [DistrictTranslation!]!
}

"""An edge in a connection."""
type ProposalEdge {
  """The item at the end of the edge."""
  node: Proposal!

  """A cursor for use in pagination."""
  cursor: String!
}

"""An evaluation for a proposal"""
type ProposalEvaluation {
  """Identifies the proposal."""
  proposal: Proposal!

  """The revision number of the evaluation"""
  version: Int!

  """List of responses for the evaluation"""
  responses: [Response]!
}

"""A budget form"""
type ProposalForm implements Node & UniformResourceLocatable {
  """The ID of an object"""
  id: ID!

  """A list of proposals associated to the object."""
  proposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    If non-null, filters proposals with the given trashed status (eg: visible, not visible).
    """
    trashedStatus: ProposalTrashedStatus = NOT_TRASHED

    """
    ID of a User to filter by. If non-null, only proposals authored by this user will be returned.
    """
    author: ID

    """Ordering options for proposals returned from the connection."""
    orderBy: ProposalOrder = {field: PUBLISHED_AT, direction: ASC}

    """(ROLE_ADMIN only) Select also draft proposals."""
    includeDraft: Boolean = false

    """
    The state of the proposals to filter by. If non-null, filters proposals with the given state.
    """
    state: ProposalsState

    """
    ID of a ProposalDistrict to filter by. If non-null, filters proposals with the given district.
    """
    district: ID

    """
    ID of a UserType to filter by. If non-null, filters proposals with the given type of author.
    """
    userType: ID

    """
    ID of a ProposalCategory to filter by. If non-null, filters proposals with the given category.
    """
    category: ID

    """
    ID of a ProposalStatus to filter by. If non-null, filters proposals with the given status.
    """
    status: ID

    """
    ID of a Theme to filter by. If non-null, filters proposals with the given theme.
    """
    theme: ID

    """If non-null, filters proposals with the given string to look for."""
    term: String

    """Affiliation options for proposals returned from the connection."""
    affiliations: [ProposalAffiliation]

    """(ROLE_SUPER_ADMIN only) Select also unpublished proposals."""
    includeUnpublished: Boolean = false

    """The global progress status of the proposal."""
    progressStatus: ProposalProgressState

    """The analysts's ids assigned to the proposal"""
    analysts: [ID!]

    """The supervisor's id assigned to the proposal"""
    supervisor: ID

    """The decision-maker's id assigned to the proposal"""
    decisionMaker: ID
  ): ProposalConnection!

  """The viewer unpublished proposals (only visible by viewer)."""
  viewerProposalsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection

  """The URL to this resource."""
  url: URI!
  reference: String!
  description: String
  summaryHelpText: String
  illustrationHelpText: String
  title: String!

  """Available categories for proposals of this form."""
  categories(order: CategoryOrderField): [ProposalCategory!]!
  usingThemes: Boolean!

  """Viewer can contribute to the form"""
  contribuable: Boolean!
  themeMandatory: Boolean!
  themeHelpText: String
  usingDistrict: Boolean!
  commentable: Boolean!
  costable: Boolean!
  proposalInAZoneRequired: Boolean!
  districts(order: DistrictOrderField): [ProposalDistrict!]!
  districtMandatory: Boolean!
  districtHelpText: String
  usingCategories: Boolean!
  categoryMandatory: Boolean!
  categoryHelpText: String
  usingAddress: Boolean!
  titleHelpText: String
  descriptionHelpText: String
  addressHelpText: String
  questions: [Question!]!
  mapCenter: GoogleMapsAddress
  zoomMap: Int
  adminUrl: URI!
  notificationsConfiguration: NotificationsConfiguration!

  """Get the evaluation form of the proposal form"""
  evaluationForm: EvaluationForm

  """Identifies the step that use the proposal form."""
  step: CollectStep
  allowAknowledge: Boolean!

  """Proposal form is type of Proposal or Question"""
  isProposalForm: Boolean!

  """The kind of proposal form (Proposal/Question/Establishment)"""
  objectType: ProposalFormObjectType!

  """Proposal form using description field"""
  usingDescription: Boolean!

  """Proposal form using illustration field"""
  usingIllustration: Boolean!

  """Proposal form using summary field"""
  usingSummary: Boolean!

  """Proposal form is description field is mandatory or not"""
  descriptionMandatory: Boolean!

  """
  When a user is creating a proposal, suggest similar to avoid duplicate.
  """
  suggestingSimilarProposals: Boolean!
  isIndexationDone: Boolean!

  """can the viewer send a contact message to the proposals author"""
  canContact: Boolean!

  """The configuration for the related analysis."""
  analysisConfiguration: AnalysisConfiguration

  """True if the grid view is enabled."""
  isGridViewEnabled: Boolean!

  """True if the grid view is enabled."""
  isListViewEnabled: Boolean!

  """True if the grid view is enabled."""
  isMapViewEnabled: Boolean!

  """True if tipsmeee is enabled."""
  usingTipsmeee: Boolean!

  """The help text for tipsmeee."""
  tipsmeeeHelpText: String

  """The number of social networks used."""
  numberOfUsedSocialNetworks: Int!

  """Proposal form using web page field"""
  usingWebPage: Boolean!

  """Proposal form using Twitter field"""
  usingTwitter: Boolean!

  """Proposal form using Facebook field"""
  usingFacebook: Boolean!

  """Proposal form using Instagram field"""
  usingInstagram: Boolean!

  """Proposal form using Youtube field"""
  usingYoutube: Boolean!

  """Proposal form using LinkedIn field"""
  usingLinkedIn: Boolean!

  """Proposal form using any social networks field"""
  isUsingAnySocialNetworks: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime

  """The owner of the questionnaire."""
  owner: QuestionnaireOwner

  """The social networks used as string."""
  socialNetworksUsed: String!
}

"""The affiliation of a user to a `ProposalForm.`"""
enum ProposalFormAffiliation {
  """`ProposalForms` that are owned by the authenticated user."""
  OWNER
}

"""A connection to a list of items."""
type ProposalFormConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ProposalFormEdge]
}

"""An edge in a connection."""
type ProposalFormEdge {
  """The item at the end of the edge."""
  node: ProposalForm!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Value of a proposal sorting"""
enum ProposalFormObjectType {
  """The proposal form is a Proposal"""
  PROPOSAL

  """The proposal form is a Question"""
  QUESTION

  """The proposal form is an Establishment"""
  ESTABLISHMENT
}

"""Ways in which lists of proposalForms can be ordered upon return."""
input ProposalFormOrder {
  """The field to order `ProposalForm` by."""
  field: ProposalFormOrderField! = CREATED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Properties by which `ProposalForms` can be ordered."""
enum ProposalFormOrderField {
  """
  Allows ordering a list of `ProposalForms` by when they have been updated.
  """
  UPDATED_AT

  """
  Allows ordering a list of `ProposalForms` by when they have been created.
  """
  CREATED_AT
}

"""Represent an owner of a `ProposalForm`."""
interface ProposalFormOwner {
  """User ID"""
  id: ID!

  """User username."""
  username: String

  """Get all `ProposalForms` that the user owns."""
  proposalForms(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Only available proposalForms will be returned."""
    availableOnly: Boolean = false

    """
    Array of viewer's affiliation options for proposalForms returned from the connection.
    For example, OWNER will include only proposalForms that the current viewer owns.
    
    """
    affiliations: [ProposalFormAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for proposalForms"""
    orderBy: ProposalFormOrder = {field: CREATED_AT, direction: DESC}
  ): ProposalFormConnection!
}

"""Available errors on proposal illustration mutation"""
enum ProposalIllustrationErrorCode {
  """No proposal match your id."""
  PROPOSAL_NOT_FOUND

  """Access denied."""
  ACCESS_DENIED

  """No media match."""
  MEDIA_NOT_FOUND
}

"""Available errors on proposal news mutation"""
enum ProposalImportsErrorCode {
  """No proposal form match your id"""
  PROPOSAL_FORM_NOT_FOUND

  """CSV file has bad header"""
  BAD_DATA_MODEL

  """Given CSV file is empty"""
  EMPTY_FILE
}

"""Available errors on proposal news mutation"""
enum ProposalNewsErrorCode {
  """No proposal match your id."""
  PROPOSAL_NOT_FOUND

  """Access denied."""
  ACCESS_DENIED

  """ROLE_USER cant add proposal news on this project"""
  PROPOSAL_DOESNT_ALLOW_NEWS

  """No post match your id"""
  POST_NOT_FOUND

  """Invalid data in submitted form ."""
  INVALID_DATA
}

"""Properties by which proposal connections can be ordered."""
input ProposalOrder {
  """The field in which to order nodes by."""
  field: ProposalOrderField!

  """The direction in which to order nodes."""
  direction: OrderDirection! = ASC
}

"""Ordering options for proposals votes connections."""
enum ProposalOrderField {
  """
  Allows ordering a list of proposals by the number of comments it have.
  """
  COMMENTS

  """
  Allows ordering a list of proposals by the cost it have been estimated.
  """
  COST

  """Allows ordering a list of proposals by their creation date."""
  CREATED_AT

  """Allows ordering a list of proposals by when they were published."""
  PUBLISHED_AT

  """Allows randomizing a list of proposals."""
  RANDOM

  """Allows ordering a list of proposals by the number of votes it have."""
  VOTES

  """Allows ordering a list of proposals by the number of points it have."""
  POINTS

  """Allows ordering a list of proposals by revision date."""
  REVISION_AT
}

"""Possible values of a proposal's global progress state."""
enum ProposalProgressState {
  """The proposal is currently being edited"""
  IN_PROGRESS

  """The proposal's progress state is favourable."""
  FAVOURABLE

  """The proposal's progress state is unfavourable."""
  UNFAVOURABLE

  """The evaluation of the proposal was not issued in time."""
  TOO_LATE

  """The evaluation of the proposal has not started yet."""
  TODO
}

"""Available statuses"""
enum ProposalPublicationStatus {
  """Publicly visible"""
  PUBLISHED

  """Publicly visible in the trash bin"""
  TRASHED

  """In the trash bin, content not visible"""
  TRASHED_NOT_VISIBLE

  """Not publicly visible, deleted by author"""
  DELETED

  """Draft, not publicly visible, only showed for his author."""
  DRAFT

  """Visible by author only."""
  UNPUBLISHED
}

"""A proposal revision."""
type ProposalRevision {
  """The proposal's revision id."""
  id: ID!

  """The related proposal."""
  proposal: Proposal!

  """The author of revision"""
  author: User!

  """The current state of the revision on the proposal"""
  state: ProposalRevisionState!

  """The reason of revision"""
  reason: String

  """The creation date of the assessment."""
  createdAt: DateTime!

  """The date of expiration."""
  expiresAt: DateTime!

  """The date of revision by user."""
  revisedAt: DateTime

  """Is the revision expired ?"""
  isExpired: Boolean!

  """The information to resolve revision without html tags"""
  bodyText: String!

  """The information to resolve revision"""
  body: HTML!
}

"""A connection to a list of items."""
type ProposalRevisionConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ProposalRevisionEdge]
}

"""An edge in a connection."""
type ProposalRevisionEdge {
  """The item at the end of the edge."""
  node: ProposalRevision!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Possible values of a proposal's revision state."""
enum ProposalRevisionState {
  """The proposal's revision is currently pending"""
  PENDING

  """The proposal's related revision is done"""
  REVISED

  """The proposal's related revision is pending but expired"""
  EXPIRED
}

"""The selection of a proposal in a step."""
type ProposalSelection {
  """The step where the proposal is selected."""
  step: SelectionStep!

  """The status of the proposal in the step."""
  status: ProposalStepStatus
}

"""Available errors on proposal social networks mutation."""
enum ProposalSocialNetworksErrorCode {
  """No proposal match your id."""
  PROPOSAL_NOT_FOUND

  """Access denied."""
  ACCESS_DENIED

  """Social networks are not available on this proposal."""
  PROPOSAL_DOESNT_ALLOW_SOCIAL_NETWORKS
}

"""Value of a proposal sorting"""
enum ProposalSort {
  """Sort by the oldest ones first"""
  OLD

  """Sort by the most recent ones first"""
  LAST

  """Sort by the most voted ones first"""
  VOTES

  """Sort by the least voted ones first"""
  LEAST_VOTE

  """Sort by the most commented first"""
  COMMENTS

  """Sort randomly"""
  RANDOM

  """Sort by the cheap ones first"""
  CHEAP

  """Sort by the expensive ones first"""
  EXPENSIVE
}

"""Available errors on analysis related mutations."""
enum ProposalStatementErrorCode {
  """The given proposal does not exist."""
  NON_EXISTING_PROPOSAL

  """You are not assigned to this proposal."""
  NOT_ASSIGNED_PROPOSAL

  """The decision-maker has already gave his decision about this proposal."""
  DECISION_ALREADY_GIVEN

  """An internal server error occurred."""
  INTERNAL_ERROR

  """The refused reason must not be empty if the proposal is not approved."""
  REFUSED_REASON_EMPTY

  """The proposal analysis does not exist."""
  NON_EXISTING_ANALYSIS

  """The provided responses are not valid."""
  INVALID_FORM
}

"""A proposal step"""
interface ProposalStep {
  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The ID of an object"""
  id: ID!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI

  """A list of proposals associated to the object."""
  proposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    If non-null, filters proposals with the given trashed status (eg: visible, not visible).
    """
    trashedStatus: ProposalTrashedStatus = NOT_TRASHED

    """
    ID of a User to filter by. If non-null, only proposals authored by this user will be returned.
    """
    author: ID

    """Ordering options for proposals returned from the connection."""
    orderBy: ProposalOrder = {field: PUBLISHED_AT, direction: ASC}

    """(ROLE_ADMIN only) Select also draft proposals."""
    includeDraft: Boolean = false

    """
    The state of the proposals to filter by. If non-null, filters proposals with the given state.
    """
    state: ProposalsState

    """
    ID of a ProposalDistrict to filter by. If non-null, filters proposals with the given district.
    """
    district: ID

    """
    ID of a UserType to filter by. If non-null, filters proposals with the given type of author.
    """
    userType: ID

    """
    ID of a ProposalCategory to filter by. If non-null, filters proposals with the given category.
    """
    category: ID

    """
    ID of a ProposalStatus to filter by. If non-null, filters proposals with the given status.
    """
    status: ID

    """
    ID of a Theme to filter by. If non-null, filters proposals with the given theme.
    """
    theme: ID

    """If non-null, filters proposals with the given string to look for."""
    term: String

    """Affiliation options for proposals returned from the connection."""
    affiliations: [ProposalAffiliation]

    """(ROLE_SUPER_ADMIN only) Select also unpublished proposals."""
    includeUnpublished: Boolean = false

    """The global progress status of the proposal."""
    progressStatus: ProposalProgressState

    """The analysts's ids assigned to the proposal"""
    analysts: [ID!]

    """The supervisor's id assigned to the proposal"""
    supervisor: ID

    """The decision-maker's id assigned to the proposal"""
    decisionMaker: ID
  ): ProposalConnection!

  """The viewer unpublished proposals (only visible by viewer)."""
  viewerProposalsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection

  """The requirements to vote on this step."""
  requirements(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): RequirementConnection!

  """
  If votesRanking enabled, votesLimit is the reference value for the points scale.
  """
  votesLimit: Int

  """
  Minimum number of votes a user must submit for his votes to be counted.
  """
  votesMin: Int
  budget: Int
  voteType: ProposalStepVoteType!
  votable: Boolean!
  votesHelpText: String
  voteThreshold: Int
  statuses: [ProposalStepStatus!]!
  defaultSort: String
  open: Boolean!

  """If enabled, allow voters to order their votes by point"""
  votesRanking: Boolean!

  """A list of viewer votes associated with the step."""
  viewerVotes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ProposalVoteOrder = {direction: DESC}
  ): ProposalVoteConnection!
  form: ProposalForm
}

"""The given proposal status in a step."""
type ProposalStepStatus {
  """The id of the proposal step status."""
  id: ID!

  """The name of the proposal step status."""
  name: String!

  """The color of the proposal step status."""
  color: ProposalStepStatusColor!
}

"""Different status type"""
enum ProposalStepStatusColor {
  """Info color."""
  INFO

  """Primary color."""
  PRIMARY

  """Success color."""
  SUCCESS

  """Warning color."""
  WARNING

  """Danger color."""
  DANGER

  """Default color."""
  DEFAULT
}

"""Type of vote."""
enum ProposalStepVoteType {
  DISABLED
  SIMPLE
  BUDGET
}

"""Possible values of a proposal's state."""
enum ProposalTaskState {
  """The proposal's got some task in todo"""
  TODO

  """The proposal's all task done"""
  DONE
}

type ProposalTopDonator {
  """The donator's email."""
  email: String!

  """The donator's name."""
  name: String!

  """The amount of the donation."""
  amount: Float!

  """The donation date."""
  date: DateTime!
}

"""Possible trashed status for a `Proposal`."""
enum ProposalTrashedStatus {
  """`NOT_TRASHED` status to inclide the non trashed proposal."""
  NOT_TRASHED

  """`TRASHED` status to include the trashed proposal."""
  TRASHED
}

"""A contribution with an author"""
type ProposalVote implements Vote & Publishable & PrivatableVote & Contribution {
  """The ID of an object"""
  id: ID!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution. If null, the vote is anonymous."""
  author: User

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """Returns 'proposalVote'."""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Whether the author of the vote is anonymous or not."""
  private: Boolean @deprecated(reason: "Field `private` will be removed. Use `anonymous` instead. This field has been renamed. Removal on 2020-01-01 UTC.")

  """Whether the author of the vote is anonymous or not."""
  anonymous: Boolean!

  """Url of the contribution"""
  url: URI!

  """Return the proposal."""
  proposal: Proposal!

  """Return the step."""
  step: ProposalStep!

  """Return the ranking of the vote (if any)"""
  ranking: Int
}

"""A connection to a list of items."""
type ProposalVoteConnection {
  totalCount: Int!
  creditsLeft: Int
  creditsSpent: Int

  """
  Default value is 0. To know if vote ranking is enabled check votesRanking value field on proposalStep
  """
  totalPointsCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ProposalVoteEdge]
}

"""An edge in a connection."""
type ProposalVoteEdge {
  """The item at the end of the edge."""
  node: ProposalVote!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of votes can be ordered upon return."""
input ProposalVoteOrder {
  """The field in which to order nodes by."""
  field: ProposalVoteOrderField! = PUBLISHED_AT

  """The direction in which to order nodes."""
  direction: OrderDirection! = DESC
}

"""Ordering options for proposals votes connections."""
enum ProposalVoteOrderField {
  """Allows ordering a list of vote by when they were published."""
  PUBLISHED_AT

  """Allows ordering a list of vote by position."""
  POSITION
}

"""Possible values to filters a list of proposals based on their state."""
enum ProposalsState {
  """Show all proposals"""
  ALL

  """Show only published proposals"""
  PUBLISHED

  """Show only trashed proposals"""
  TRASHED

  """Show only drafted proposals"""
  DRAFT
}

"""Entities that can be published."""
interface Publishable {
  """The ID of an object"""
  id: ID!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason
}

"""Root of the schema."""
type Query {
  """The currently authenticated user."""
  viewer: User!

  """Lookup a node by its ID."""
  node(
    """The ID of an object."""
    id: ID!
  ): Node

  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!

  """Lookup projects."""
  projects(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for projects returning from the connection."""
    orderBy: ProjectOrder = {direction: DESC, field: PUBLISHED_AT}

    """
    ID of a User to filter by. If non-null, only projects authored by this user will be returned.
    """
    author: ID

    """If provided, searches projects by title."""
    term: String

    """
    ID of a Status to filter by. If non-null, filter projects by statuses.
    """
    status: ID

    """ID of a Theme to filter by. If non-null, filter projects by themes"""
    theme: ID

    """
    ID of a ProjectType to filter by. If non-null, filter projects by types
    """
    type: ID

    """
    ID of a ProjectDistrict to filter by. If non-null, filter projects by district
    """
    district: ID

    """If true, only projects with at least 1 event will be returned."""
    withEventOnly: Boolean = false

    """If true, only projects with public visibility will be returned."""
    onlyPublic: Boolean = false

    """code of a Locale to filter by. If non-null, filter projects by locale"""
    locale: String = null
  ): ProjectConnection!

  """Lookup events."""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for events returning from the connection."""
    orderBy: EventOrder = {field: START_AT, direction: DESC}

    """
    ID of a Project to filter by. If non-null, only events belonging to the project will be returned.
    """
    project: ID

    """
    If true, return the presential events, if false return the remote events.
    """
    isPresential: Boolean

    """If provided, searches events by title and description."""
    search: String

    """If provided, searches events by locale."""
    locale: TranslationLocale

    """If non-null, filters events by comparing the start date with present."""
    isFuture: Boolean

    """If non-null, filters events with the given theme."""
    theme: ID

    """If non-null, filters events with the given author."""
    author: ID

    """If non-null, filters events with the given author type."""
    userType: ID

    """
    If true, filter the events with registration link or internal registration
    enable, if false  filter the events with both registration type at false
    """
    isRegistrable: Boolean

    """
    If true get enabled only, if false get disabled, if null get all events
    """
    enabled: Boolean = true
  ): EventConnection!

  """Lookup users."""
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Remove super admin from export."""
    superAdmin: Boolean = false

    """Get user list with disabled users"""
    withDisabled: Boolean = false

    """Filter the list by email confirmation"""
    emailConfirmed: Boolean = null

    """Filter the list by consent to internal communication"""
    consentInternalCommunication: Boolean = null
    orderBy: UserOrder = {field: CREATED_AT, direction: DESC}
  ): UserConnection!

  """Lookup pages."""
  pages: [Page!]!

  """Lookup blog posts."""
  posts: [Post!]!

  """Lookup themes."""
  themes(
    """Filter by title."""
    title: String = null
  ): [Theme!]!

  """Get the available map tokens"""
  mapTokens: [MapToken!]!

  """Search a particular map token by its provider"""
  mapToken(
    """The map provider"""
    provider: MapTokenProvider!
  ): MapToken

  """Get the current favicon"""
  siteFavicon: SiteImage!

  """Get a site image"""
  siteImage(
    """The site image keyname"""
    keyname: String!
  ): SiteImage

  """Get the current registration form"""
  registrationForm: RegistrationForm

  """Get the current post registration script"""
  registrationScript: String

  """Validate the registration credentials"""
  passwordComplexityScore(
    """The username of the user"""
    username: String

    """The email of the user"""
    email: String

    """The password of the user"""
    password: String!
  ): Int

  """Get the contact forms"""
  contactForms: [ContactForm!]
  projectAuthors: [User!]!
  projectTypes(
    """If true, filter the projectTypes only used by the projects"""
    onlyUsedByProjects: Boolean = false
  ): [ProjectType!]!
  userSearch(
    """Filter by displayName."""
    displayName: String = null

    """Return all users except the ones in the array."""
    notInIds: [String] = null

    """If true, retrieve only users that created an event."""
    authorsOfEventOnly: Boolean = false
  ): [User]
  consultationSteps(
    """
    If omitted, returns all consultations steps. If provided, returns the consultation step of the particular id.
    """
    id: ID
  ): [ConsultationStep!]!
  consultations(
    """
    If omitted, returns all consultations. If provided, returns the consultation of the particular id.
    """
    id: ID
  ): [Consultation!]!

  """Lookup groups."""
  groups: [Group!]!

  """Lookup forms."""
  proposalForms: [ProposalForm]!

  """Lookup category images."""
  categoryImages(
    """
    If true, get default category image, if false get custom category image, if null get all
    """
    isDefault: Boolean
  ): [CategoryImage!]!

  """Lookup availables districts on a proposalForm for a given address."""
  availableDistrictsForLocalisation(proposalFormId: ID!, latitude: Float!, longitude: Float!): [ProposalDistrict!]!

  """TO BE REMOVED"""
  contributions(
    """Returns all contributions of the provided consultation."""
    consultation: ID!
  ): [Opinion!]!

  """TO BE REMOVED"""
  question(id: Int!): Question!
  availableQuestionnaires(
    """the term to filter questions"""
    term: String
  ): [Questionnaire!]!

  """List all the district project in the platform."""
  projectDistricts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Filter by name."""
    name: String = null
  ): ProjectDistrictConnection!

  """List all the contributors in the platform."""
  allContributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!

  """Return the number of contributions in the platform."""
  allContributions: Int!

  """List all the votes in the platform."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get only accounted votes."""
    onlyAccounted: Boolean = true
  ): VoteConnection!

  """Get the current shield admin form."""
  shieldAdminForm: ShieldAdminForm!

  """List all SSO Configurations."""
  ssoConfigurations(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): SSOConfigurationConnection!

  """List all sections."""
  sections(
    """Filter by contributor of section."""
    user: ID
  ): [Section!]!

  """List all medias"""
  medias(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Search by term."""
    term: String
  ): MediaConnection!

  """List all locales on the platform."""
  availableLocales(includeDisabled: Boolean): [Locale!]!

  """List all locales published."""
  locales: [Locale!]!

  """Get the default locale."""
  defaultLocale: Locale!

  """List all available fonts on the platform."""
  fonts: [Font!]!

  """Retrieve the configured notifications from email."""
  notificationsFromEmail: Email

  """get a site parameter from its keyname"""
  siteParameter(
    """keyname of the site parameter to get"""
    keyname: String!
  ): SiteParameter

  """get consultations without step"""
  availableConsultations(
    """Retrieve consultation where title match term param."""
    term: String
  ): [Consultation]!

  """Autocomplete several fields based on siret"""
  apiEnterpriseAutocompleteFromSiret(
    """siret of the legal institution"""
    siret: String!

    """type of the legal institution"""
    type: APIEnterpriseType!
  ): APIEnterpriseResult

  """Autocomplete several fields based on id"""
  apiEnterpriseAutocompleteFromId(
    """id of the legal institution"""
    id: String!
  ): APIEnterpriseAssociation

  """Fetch documents with an id"""
  fetchAPIEnterpriseDocuments(
    """Get heavy documents for a legal instance."""
    id: String!

    """type of the legal instance"""
    type: APIEnterpriseType!
  ): APIEnterpriseDocuments

  """Fetch projects with assignment"""
  viewerAssignedProjectsToAnalyse: [Project!]

  """Whether or not this user can access our evaluations page."""
  viewerCanSeeEvaluationsPage: Boolean!

  """An address from Google Maps."""
  geocode(
    """the latitude of geocode"""
    latitude: Float!

    """the longitude of geocode"""
    longitude: Float!
  ): GoogleMapsAddress

  """List all feature flags."""
  featureFlags: [FeatureFlag!]!

  """List all invited users."""
  userInvitations(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String
    first: Int = 50
  ): UserInviteConnection!

  """List all site colors."""
  siteColors: [SiteColor!]!

  """Retrieve the current version of the app."""
  appVersion: String

  """Get all mailing lists"""
  mailingLists(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """If provided, filter lists by name"""
    term: String
  ): MailingListConnection!

  """Get all emailing campaigns"""
  emailingCampaigns(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """optional filter by status"""
    status: EmailingCampaignStatusFilter

    """The ordering direction for sending date"""
    orderBy: EmailingCampaignOrder = {field: SEND_AT, direction: DESC}

    """If provided, filter campaigns by name"""
    term: String
  ): EmailingCampaignConnection!

  """Get the options for creating a category within a proposal form"""
  proposalCategoryOptions: ProposalCategoryOptions!

  """Get HomePageProjectsSectionConfiguration"""
  homePageProjectsSectionConfiguration: HomePageProjectsSectionConfiguration!

  """Return the platform analytics"""
  analytics(filter: QueryAnalyticsFilter!): PlatformAnalytics!
  isEmailAlreadyTaken(
    """Email to check."""
    email: Email!
  ): Boolean!
  externalServiceConfiguration(
    """The type of configuration asked"""
    type: ExternalServiceConfigurationType!
  ): ExternalServiceConfiguration!

  """Get all domains registered"""
  senderEmailDomains: [SenderEmailDomain!]!

  """Get all sending addresses registered"""
  senderEmails: [SenderEmail!]!
}

input QueryAnalyticsFilter {
  startAt: DateTime!
  endAt: DateTime!
  projectId: ID = null
  topContributorsCount: Int = 4
}

"""Fetches an object given its ID"""
interface Question {
  """The ID of an object"""
  id: ID!

  """Identifies the question title."""
  title: String!

  """Return responses on this questions."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get responses with user not confirmed"""
    withNotConfirmedUser: Boolean = false

    """Get responses in which the term appears."""
    term: String
  ): ResponseConnection!
  number: Int!
  type: QuestionTypeValue!

  """The position of the question"""
  position: Int!
  private: Boolean!
  required: Boolean!
  helpText: String
  description: String
  kind: String!
  slug: String!

  """Return users who answered the question"""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get participant with user not confirmed"""
    withNotConfirmedUser: Boolean = false
  ): ParticipantConnection!

  """The associated logic jumps to this question."""
  jumps(
    """Ordering options for question jumps."""
    orderBy: JumpsOrder = {field: POSITION, direction: ASC}
  ): [LogicJump!]!

  """The jumps of which this question is the destination"""
  destinationJumps: [LogicJump!]!

  """The destination of the always jump (the else case) of this question."""
  alwaysJumpDestinationQuestion: Question

  """Boolean to decide whether the question will be rendered or not"""
  hidden: Boolean!
}

"""A possible choice of a question."""
type QuestionChoice implements Node {
  """The ID of an object"""
  id: ID!

  """Identifies the question choice title."""
  title: String!

  """Identifies the responses of the question choice."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ResponseConnection!
  description: String

  """The color assign with the question"""
  color: Color
  image: Media

  """Return the ranking of the given question choice"""
  ranking: [QuestionChoiceRanking]
}

"""A connection to a list of items."""
type QuestionChoiceConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [QuestionChoiceEdge]
}

"""An edge in a connection."""
type QuestionChoiceEdge {
  """The item at the end of the edge."""
  node: QuestionChoice

  """A cursor for use in pagination."""
  cursor: String!
}

"""A possible choice of a question"""
input QuestionChoiceInput {
  id: ID
  title: String!
  description: String

  """The color assign with the question choice"""
  color: Color
  image: ID
}

"""The choice ranking"""
type QuestionChoiceRanking {
  """Identifies the position of the choice"""
  position: Int!

  """Identifies the responses of the choice."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ResponseConnection!
}

input QuestionInput {
  """If null, a new question will be created."""
  id: String
  alwaysJumpDestinationQuestion: ID
  title: String!
  type: QuestionTypeValue!
  private: Boolean! = false
  required: Boolean! = false
  helpText: String
  randomQuestionChoices: Boolean
  otherAllowed: Boolean
  validationRule: MultipleChoiceQuestionValidationRuleInput
  choices: [QuestionChoiceInput]
  description: String
  jumps: [LogicJumpInput]
  hidden: Boolean = false

  """If not null, give the section s depth"""
  level: Int

  """can the viewer add a range (number question only)"""
  isRangeBetween: Boolean

  """The minimal range (number question only)"""
  rangeMin: Int

  """The maximal range (number question only)"""
  rangeMax: Int

  """Does the question have it's responses grouped"""
  groupedResponsesEnabled: Boolean

  """Does the questions have disabled the responses colors"""
  responseColorsDisabled: Boolean
}

"""Value of type of question"""
enum QuestionTypeValue {
  text
  textarea
  editor
  radio
  select
  checkbox
  ranking
  medias
  button
  number
  section
  siret
  rna
  majority
}

"""A questionnaire is a series of questions that users can answer."""
type Questionnaire implements Node {
  """The ID of an object."""
  id: ID!

  """Identifies the questionnaire title."""
  title: String!

  """Whether the user has reply to a questionnaire."""
  userHasReply(
    """The user's login (for example, an email)."""
    login: String!
  ): Boolean!

  """A list of users that have replied to the questionnaire."""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!

  """The list of questions of the questionnaire."""
  questions: [Question!]!

  """A list of replies to the questionnaire."""
  replies(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """(ROLE_ADMIN only) Select also unpublished replies."""
    includeUnpublished: Boolean = false

    """(ROLE_ADMIN only) Select also draft replies."""
    includeDraft: Boolean = false
  ): ReplyConnection!

  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!
  step: QuestionnaireStep
  anonymousAllowed: Boolean!
  description: String
  multipleRepliesAllowed: Boolean!

  """accept answers or not"""
  contribuable: Boolean!
  phoneConfirmationRequired: Boolean!
  viewerReplies(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ReplyConnection
  acknowledgeReplies: Boolean!

  """The questionnaire type"""
  type: QuestionnaireType!
  notificationsConfiguration: QuestionnaireNotificationConfiguration!

  """Results of survey are private"""
  privateResult: Boolean!
  exportResultsUrl: URI!
  adminUrl: URI!
  isIndexationDone: Boolean!
  createdAt: DateTime
  updatedAt: DateTime

  """The owner of the questionnaire."""
  owner: QuestionnaireOwner
}

input QuestionnaireAbstractQuestionInput {
  question: QuestionInput!
}

"""The affiliation of a user to a questionnaire"""
enum QuestionnaireAffiliation {
  """Questionnaires that are owned by the authenticated user."""
  OWNER
}

"""A connection to a list of items."""
type QuestionnaireConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [QuestionnaireEdge]
}

"""An edge in a connection."""
type QuestionnaireEdge {
  """The item at the end of the edge."""
  node: Questionnaire!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A questionnaire notifications configuration"""
type QuestionnaireNotificationConfiguration {
  """The email that will be used to send notification"""
  email: Email

  """The email that will be used to send notification"""
  onQuestionnaireReplyCreate: Boolean!

  """Notify when a response is created for this questionnaire"""
  onQuestionnaireReplyUpdate: Boolean!

  """Notify when a response is deleted for this questionnaire"""
  onQuestionnaireReplyDelete: Boolean!
}

"""Ways in which lists of questionnaires can be ordered upon return."""
input QuestionnaireOrder {
  """The field to order questionnaires by."""
  field: QuestionnaireOrderField! = CREATED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Properties by which questionnaires can be ordered"""
enum QuestionnaireOrderField {
  """
  Allows ordering a list of questionnaires by when they have been updated.
  """
  UPDATED_AT

  """
  Allows ordering a list of questionnaires by when they have been created.
  """
  CREATED_AT
}

"""Represent an owner of a questionnaire."""
interface QuestionnaireOwner {
  """User ID"""
  id: ID!

  """User username"""
  username: String

  """Get all questionnaires that the user owns."""
  questionnaires(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for questionnaires returned from the connection.
    For example, OWNER will include only questionnaires that the current viewer owns.
    
    """
    affiliations: [QuestionnaireAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for questionnaires"""
    orderBy: QuestionnaireOrder = {field: CREATED_AT, direction: DESC}

    """Filter by available questionnaires"""
    availableOnly: Boolean
  ): QuestionnaireConnection!
}

"""A step inside a project."""
type QuestionnaireStep implements Node & Step & RequirementStep {
  """The ID of an object"""
  id: ID!

  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI

  """Requirements for answering the questionnaire"""
  requirements(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): RequirementConnection!
  footer: String

  """A list of contributor associated with the step."""
  contributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!

  """A questionnaire associated with the step."""
  questionnaire: Questionnaire
}

"""Available questionnaire types."""
enum QuestionnaireType {
  """Draft are allowed."""
  QUESTIONNAIRE

  """Draft are not allowed."""
  VOTING
}

"""A step inside a project."""
type RankingStep implements Node & Step {
  """The ID of an object"""
  id: ID!

  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI
  nbOpinionsToDisplay: Int
  nbVersionsToDisplay: Int
}

input RegisterEmailDomainsInput {
  """the domains"""
  domains: [EmailDomainInput!]
  clientMutationId: String
}

type RegisterEmailDomainsPayload {
  """the added domains"""
  domains: [EmailDomain!]
  clientMutationId: String
}

"""Available errors on register mutations."""
enum RegisterErrorCode {
  """The email is already registered"""
  EMAIL_ALREADY_USED

  """The email domain is not authorized"""
  EMAIL_DOMAIN_NOT_AUTHORIZED

  """The captcha is invalid"""
  CAPTCHA_INVALID

  """The register feature is not enabled"""
  REGISTER_FEATURE_NOT_ENABLED

  """The username is blank"""
  USERNAME_BLANK

  """The email is blank"""
  EMAIL_BLANK

  """The password is blank"""
  PASSWORD_BLANK

  """The email is throwable"""
  EMAIL_THROWABLE

  """The form should not contain extra fields"""
  NO_EXTRA_FIELDS
}

input RegisterInput {
  """The user email"""
  email: Email!

  """The user username"""
  username: String!

  """The user plainpassword"""
  plainPassword: String!

  """The captcha to validate the registration"""
  captcha: String

  """
  Whether or not the user accept to register to the internal communication newsletter
  """
  consentInternalCommunication: Boolean

  """
  Whether or not the user accept to register to the external communication newsletter
  """
  consentExternalCommunication: Boolean

  """
  When the user is invited, represents the token attached to the registration link
  """
  invitationToken: String

  """The user locale"""
  locale: String

  """List of responses of optionnal questions set by the admin"""
  responses: [ResponseInput]!

  """The user userType"""
  userType: String

  """The user zipcode"""
  zipcode: String
  clientMutationId: String
}

type RegisterPayload {
  """The newly created user"""
  user: User

  """Errors if mutation fails"""
  errorsCode: [RegisterErrorCode]
  clientMutationId: String
}

"""Fetches an object given its ID"""
type RegistrationForm implements Node {
  """The ID of an object"""
  id: ID!

  """Does the bottom text is displayed?"""
  bottomTextDisplayed: Boolean!

  """Does the top text is displayed?"""
  topTextDisplayed: Boolean!

  """The bottom text to display"""
  topText(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String

  """The bottom text to display"""
  bottomText(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String

  """A whitelist of authorized domains that can register"""
  domains: [EmailDomain!]

  """The available questions"""
  questions: [Question!]!
  isIndexationDone: Boolean!
  translations: [RegistrationFormTranslation!]!
}

input RegistrationFormCommunicationInput {
  """The locale of the translation"""
  locale: String!

  """The bottom text to display"""
  topText: String

  """The bottom text to display"""
  bottomText: String
}

"""translation of the registration form"""
type RegistrationFormTranslation {
  """The locale of the translation"""
  locale: String!

  """The bottom text to display"""
  topText: String

  """The bottom text to display"""
  bottomText: String
}

type RemainingTime {
  """Number of days remaining"""
  days: Int

  """Number of hours remaining"""
  hours: Int
}

input RemoveArgumentVoteInput {
  """The Node ID of the argument to unvote."""
  argumentId: ID!
  clientMutationId: String
}

type RemoveArgumentVotePayload {
  deletedVoteId: ID
  contribution: Argument
  viewer: User!
  clientMutationId: String
}

input RemoveCommentVoteInput {
  """The Node ID of the comment to unvote."""
  commentId: ID!
  clientMutationId: String
}

type RemoveCommentVotePayload {
  deletedVoteId: ID
  contribution: Comment
  viewer: User!
  clientMutationId: String
}

input RemoveContactFormInput {
  """ID of the contact form to delete."""
  id: ID!
  clientMutationId: String
}

type RemoveContactFormPayload {
  """Id of the deleted contact form."""
  deletedContactFormId: ID!
  clientMutationId: String
}

"""Available errors for a `removeDebateAnonymousVote` mutation."""
enum RemoveDebateAnonymousVoteErrorCode {
  """No `Debate` match your id."""
  UNKNOWN_DEBATE

  """The debate is closed and removing a vote cannot be done."""
  CLOSED_DEBATE

  """The given hash is not valid."""
  INVALID_HASH

  """The user has not voted."""
  NOT_VOTED
}

input RemoveDebateAnonymousVoteInput {
  """The Node ID of the `Debate` to remove the vote on."""
  debateId: ID!

  """The cookie hash needed to remove the anonymous debate vote."""
  hash: String!

  """
  The cookie hash needed to remove the anonymous debate argument, if any.
  """
  argumentHash: String
  clientMutationId: String
}

type RemoveDebateAnonymousVotePayload {
  """The debate that had the anonymous vote."""
  debate: Debate

  """The id of the vote that has just been removed."""
  deletedDebateAnonymousVoteId: ID

  """The id of the argument removed, if any."""
  deletedDebateAnonymousArgumentId: ID

  """An unsuccessful mutation will return an error."""
  errorCode: RemoveDebateAnonymousVoteErrorCode
  clientMutationId: String
}

"""Available errors for a `removeDebateArgumentVote` mutation."""
enum RemoveDebateArgumentVoteErrorCode {
  """No `DebateArgument` match your id."""
  UNKNOWN_DEBATE_ARGUMENT

  """The debate is closed and arguments cannot be voted for."""
  CLOSED_DEBATE

  """Viewer has not already voted this argument."""
  NOT_VOTED
}

input RemoveDebateArgumentVoteInput {
  """The id of the `DebateArgument` to remove the vote."""
  debateArgumentId: ID!
  clientMutationId: String
}

type RemoveDebateArgumentVotePayload {
  """The argument that had just been upvoted."""
  debateArgument: AbstractDebateArgument

  """The id of the vote just removed."""
  deletedDebateArgumentVoteId: ID

  """An unsuccessful mutation will return an error."""
  errorCode: RemoveDebateArgumentVoteErrorCode
  clientMutationId: String
}

"""Available errors for a `removeDebateVote` mutation."""
enum RemoveDebateVoteErrorCode {
  """No `Debate` match your `debateId`."""
  UNKNOWN_DEBATE
}

input RemoveDebateVoteInput {
  """The Node ID of the `Debate` to remove the vote."""
  debateId: ID!
  clientMutationId: String
}

type RemoveDebateVotePayload {
  """The debate of the deleted vote."""
  debate: Debate

  """The id of the removed vote."""
  deletedVoteId: ID

  """The id of the removed argument."""
  deletedArgumentId: ID

  """An unsuccessful mutation will return an error."""
  errorCode: RemoveDebateVoteErrorCode
  clientMutationId: String
}

input RemoveOpinionVoteInput {
  """The Node ID of the opinion to unvote."""
  opinionId: ID!
  clientMutationId: String
}

type RemoveOpinionVotePayload {
  deletedVoteId: ID
  contribution: Contribution
  viewer: User!
  clientMutationId: String
}

input RemoveProposalVoteInput {
  """The Node ID of the proposal to unvote."""
  proposalId: ID!

  """The Node ID of the contribuable step."""
  stepId: ID!
  clientMutationId: String
}

type RemoveProposalVotePayload {
  step: ProposalStep!
  proposal: Proposal!
  viewer: User!
  previousVoteId: ID
  areRemainingVotesAccounted: Boolean!
  clientMutationId: String
}

"""Available errors on step assignment of proposals"""
enum RemoveProposalsFromStepsErrorCode {
  """No proposal match your id or it does not fit the selected status"""
  NO_VALID_PROPOSAL

  """No step match your id or it does not fit the selected proposals"""
  NO_VALID_STEP
}

input RemoveProposalsFromStepsInput {
  """The ids of the proposals to remove from steps"""
  proposalIds: [ID!]!

  """The ids of the steps to which proposals should be removed"""
  stepIds: [ID!]!
  clientMutationId: String
}

type RemoveProposalsFromStepsPayload {
  """Connection of assigned proposals"""
  proposals: ProposalConnection

  """An unsuccessful mutation will return an error message"""
  error: RemoveProposalsFromStepsErrorCode
  clientMutationId: String
}

input RemoveSiteFaviconInput {
  clientMutationId: String
}

type RemoveSiteFaviconPayload {
  """The newly updated site image favicon"""
  siteFavicon: SiteImage!
  clientMutationId: String
}

input RemoveSourceVoteInput {
  """The Node ID of the source to unvote."""
  sourceId: ID!
  clientMutationId: String
}

type RemoveSourceVotePayload {
  deletedVoteId: ID
  contribution: Source
  viewer: User!
  clientMutationId: String
}

input RemoveSsoInput {
  """The password to set."""
  plainPassword: String

  """The service to dissociate."""
  service: AvailableSso!
  clientMutationId: String
}

type RemoveSsoPayload {
  viewer: User!

  """The redirect URI to disconnect the sso"""
  redirectUrl: URI
  clientMutationId: String
}

"""Represents a user's answer to a questionnaire."""
type Reply implements Node & Publishable & Updatable & Draftable & Contribution & UniformResourceLocatable & Deletable {
  """Check if the current viewer can update this object"""
  viewerCanUpdate: Boolean!

  """The ID of an object."""
  id: ID!

  """Check if the current viewer can delete this object"""
  viewerCanDelete: Boolean!

  """Whether or not the entity is a draft."""
  draft: Boolean!

  """Identifies when the entity was undraft at."""
  undraftAt: DateTime

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The URL to this resource."""
  url: URI!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """The responses of the reply."""
  responses: [Response]!

  """The author of the contribution."""
  author: User!
  private: Boolean!

  """The reply status."""
  publicationStatus: ReplyPublicationStatus!

  """Identifies the form where the contribution was submitted."""
  questionnaire: Questionnaire!
}

"""A connection to a list of items."""
type ReplyConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ReplyEdge]
}

"""An edge in a connection."""
type ReplyEdge {
  """The item at the end of the edge."""
  node: Reply!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Available statuses"""
enum ReplyPublicationStatus {
  """Publicly visible"""
  PUBLISHED

  """Draft, not publicly visible, only showed for his author."""
  DRAFT
}

"""A connection to a list of items."""
type ReportConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ReportEdge]
}

"""An edge in a connection."""
type ReportEdge {
  """The item at the end of the edge."""
  node: Reporting!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Available errors on report mutations."""
enum ReportErrorCode {
  """The entity does not exist or is not reportable."""
  REPORTABLE_NOT_FOUND

  """The viewer has already reported this content."""
  ALREADY_REPORTED
}

input ReportInput {
  """The id of the entity to be reported."""
  reportableId: ID!

  """The content of the report"""
  body: String!

  """Kind of report."""
  type: ReportingType!
  clientMutationId: String
}

type ReportPayload {
  """The reporting just created."""
  report: Reporting

  """Contains the error code if one occurred."""
  errorCode: ReportErrorCode
  clientMutationId: String
}

"""A reportable"""
interface Reportable {
  """Does the viewer already submitted a report ?"""
  viewerHasReport: Boolean!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!
}

"""A report"""
type Reporting implements Contribution & ContributionWithAuthor {
  """The ID of an object"""
  id: ID!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """Url of the contribution"""
  url: URI!

  """The author of the contribution."""
  author: User!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """The escaped content of the argument."""
  bodyText: String!

  """Kind of report."""
  type: ReportingType!

  """The content of the argument."""
  body: String!
  kind: String!
}

"""A connection to a list of items."""
type ReportingConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ReportingEdge]
}

"""An edge in a connection."""
type ReportingEdge {
  """The item at the end of the edge."""
  node: Reporting!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which lists of reportings can be ordered upon return."""
input ReportingOrder {
  field: ReportingOrderField! = CREATED_AT
  direction: OrderDirection! = DESC
}

"""Properties by which report connections can be ordered"""
enum ReportingOrderField {
  """Allows ordering a list of reports by when they were created."""
  CREATED_AT
}

"""Type of reporting"""
enum ReportingType {
  """The associated contribution has been flagged as sexual content"""
  SEX

  """The associated contribution has been flagged as offending content"""
  OFF

  """The associated contribution has been flagged as spam"""
  SPAM

  """The associated contribution has been flagged as erroneous"""
  ERROR

  """The associated contribution has been flagged as off topic"""
  OFF_TOPIC
}

input RequestUserArchiveInput {
  clientMutationId: String
}

type RequestUserArchivePayload {
  viewer: User!
  clientMutationId: String
}

"""A requirement"""
interface Requirement {
  """The ID of an object"""
  id: ID!

  """Does the viewer meets the requirement ?"""
  viewerMeetsTheRequirement: Boolean!
}

"""A connection to a list of items."""
type RequirementConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Does the viewer meets all the requirements ?"""
  viewerMeetsTheRequirements: Boolean!

  """The reason for requirements."""
  reason: String

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [RequirementEdge]
}

"""An edge in a connection."""
type RequirementEdge {
  """The item at the end of the edge."""
  node: Requirement!

  """A cursor for use in pagination."""
  cursor: String!
}

interface RequirementStep {
  """The requirements to vote on this step."""
  requirements(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): RequirementConnection!
}

"""Possible values for a requirement"""
enum RequirementType {
  """The requirement is a checkbox"""
  CHECKBOX

  """The requirement is a firstname"""
  FIRSTNAME

  """The requirement is a lastname"""
  LASTNAME

  """The requirement is a phone number"""
  PHONE

  """The requirement is a date of birth"""
  DATE_OF_BIRTH

  """The requirement is a postal address"""
  POSTAL_ADDRESS

  """The requirement is an identification code"""
  IDENTIFICATION_CODE
}

"""Available errors on resendEmailConfirmationMutation"""
enum ResendEmailConfirmationErrorCode {
  """The email is already confirmed"""
  EMAIL_ALREADY_CONFIRMED

  """The email has already been sent recently"""
  EMAIL_RECENTLY_SENT
}

type ResendEmailConfirmationPayload {
  """An unsuccessful mutation will return an error."""
  errorCode: ResendEmailConfirmationErrorCode
  clientMutationId: String
}

input ResetPasswordInput {
  """The token needed to identify the user"""
  token: String!

  """The new password"""
  password: String!
  clientMutationId: String
}

type ResetPasswordPayload {
  """The modified user"""
  user: User

  """In case of error a message is given here"""
  error: String
  clientMutationId: String
}

"""A response to a question."""
interface Response {
  """Nullable ID in case of empty response."""
  id: String

  """Identifies the question of the response."""
  question: Question!
}

"""A connection to a list of items."""
type ResponseConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ResponseEdge]
}

"""An edge in a connection."""
type ResponseEdge {
  """The item at the end of the edge."""
  node: Response!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A response"""
input ResponseInput {
  """If related to a value question"""
  value: JSON

  """The question id"""
  question: String!

  """If related to a media question"""
  medias: [ID!]
}

input ReviewEventInput {
  """The ID of the Event to review."""
  id: ID!

  """The details of reason why the review is refused"""
  comment: String

  """Kind of review is refused."""
  refusedReason: EventRefusedReason

  """The status of review."""
  status: EventReviewStatus!
  clientMutationId: String
}

type ReviewEventPayload {
  """The event reviewed."""
  event: Event

  """An unsuccessful mutation will return one or more `UserError` objects."""
  userErrors: [UserError!]!
  clientMutationId: String
}

input RevokeAnalystsToProposalsInput {
  """Revoke analyst list to a list of proposals."""
  proposalIds: [ID!]!

  """The concerned list of analysts"""
  analystIds: [ID!]!
  clientMutationId: String
}

type RevokeAnalystsToProposalsPayload {
  """Connection of revoked proposals"""
  proposals: ProposalConnection

  """Contains the error code if one occurred."""
  errorCode: ProposalAssignmentErrorCode
  viewer: User!
  clientMutationId: String
}

"""A SSO Configuration"""
interface SSOConfiguration {
  """The ID of an object"""
  id: ID!

  """The name of configured SSO."""
  name: String!

  """Does this configuration is enabled?"""
  enabled: Boolean!

  """Profile URL on the SSO side."""
  profileUrl: URI

  """Color in hexadecimal of SSO button."""
  buttonColor: Color!

  """Color in hexadecimal of label SSO button."""
  labelColor: Color!
}

"""A connection to a list of items."""
type SSOConfigurationConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [SSOConfigurationEdge]
}

"""An edge in a connection."""
type SSOConfigurationEdge {
  """The item at the end of the edge."""
  node: SSOConfiguration

  """A cursor for use in pagination."""
  cursor: String!
}

"""Possible environments for a SSO Configuration."""
enum SSOEnvironment {
  """Unset mode."""
  NONE

  """Integration mode for resource owner validation."""
  TESTING

  """Production mode."""
  PRODUCTION
}

"""A section"""
type Section implements Node & UniformResourceLocatable {
  """The URL to this resource."""
  url: URI!

  """The id of the section."""
  id: ID!

  """Get the associated consultation of this section"""
  consultation: Consultation

  """The slug of the section."""
  slug: String!

  """The title of the section."""
  title: String!

  """The color of the section."""
  color: String!

  """The subtitle of the section."""
  subtitle: String

  """The description of the section."""
  description: HTML
  contributionsCount: Int!
  contributionConnection(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for contributions returned from the connection."""
    orderBy: ContributionOrder

    """The connection will return the trashed results too."""
    trashed: Boolean = false

    """The connection will return the results where consultation.step = step"""
    step: ID
  ): ContributionConnection!

  """Array of appendix types (possibly empty)."""
  appendixTypes: [SectionAppendixType]

  """Array of subsections (possibly empty)."""
  sections: [Section]
  voteWidgetType: Int!
  commentSystem: Int!
  contribuable: Boolean!
  versionable: Boolean!
  sourceable: Boolean!
  linkable: Boolean!
  votesHelpText: String
  votesThreshold: Int
  votesThresholdHelpText: String
  defaultOrderBy: SectionOrderBy
  opinions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Filter by author of opinion."""
    author: ID

    """Ordering options for followers returning from the connection"""
    orderBy: OpinionOrder = {field: PUBLISHED_AT, direction: DESC}

    """Include trashed opinion or not"""
    includeTrashed: Boolean = false
  ): OpinionConnection!
}

"""A section"""
type SectionAppendixType {
  id: String
  position: Int!
  title: String
  helpText: String
}

enum SectionOrderBy {
  positions
  random
  last
  old
  favorable
  votes
  comments
}

"""A section is just a title in a quiz without any possible answer."""
type SectionQuestion implements Question & Node {
  """The ID of an object"""
  id: ID!

  """Identifies the question title."""
  title: String!

  """Return responses on this questions."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get responses with user not confirmed"""
    withNotConfirmedUser: Boolean = false

    """Get responses in which the term appears."""
    term: String
  ): ResponseConnection!
  number: Int!
  type: QuestionTypeValue!

  """The position of the question"""
  position: Int!
  private: Boolean!
  required: Boolean!
  helpText: String
  description: String
  kind: String!
  slug: String!

  """Return users who answered the question"""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get participant with user not confirmed"""
    withNotConfirmedUser: Boolean = false
  ): ParticipantConnection!

  """The associated logic jumps to this question."""
  jumps(
    """Ordering options for question jumps."""
    orderBy: JumpsOrder = {field: POSITION, direction: ASC}
  ): [LogicJump!]!

  """The jumps of which this question is the destination"""
  destinationJumps: [LogicJump!]!

  """The destination of the always jump (the else case) of this question."""
  alwaysJumpDestinationQuestion: Question

  """Boolean to decide whether the question will be rendered or not"""
  hidden: Boolean!

  """If not null, give the section s depth"""
  level: Int
}

input SelectProposalInput {
  """The step where the proposal is selected"""
  stepId: String!

  """The proposal ID to select."""
  proposalId: ID!

  """The selection status."""
  statusId: String
  clientMutationId: String
}

type SelectProposalPayload {
  proposal: Proposal!
  clientMutationId: String
}

"""Possible errors on selectSenderDomain mutation."""
enum SelectSenderEmailErrorCode {
  """No `SenderEmail` matching your id."""
  UNKNOWN_SENDER_EMAIL
}

input SelectSenderEmailInput {
  """The SenderEmail to be selected."""
  senderEmail: ID!
  clientMutationId: String
}

type SelectSenderEmailPayload {
  """The selected SenderEmail."""
  senderEmail: SenderEmail

  """The error generated, if any."""
  errorCode: SelectSenderEmailErrorCode
  clientMutationId: String
}

"""A budget contribution"""
type SelectionStep implements Node & Step & ProposalStep & RequirementStep {
  """The ID of an object"""
  id: ID!

  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI

  """A list of proposals associated to the object."""
  proposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    If non-null, filters proposals with the given trashed status (eg: visible, not visible).
    """
    trashedStatus: ProposalTrashedStatus = NOT_TRASHED

    """
    ID of a User to filter by. If non-null, only proposals authored by this user will be returned.
    """
    author: ID

    """Ordering options for proposals returned from the connection."""
    orderBy: ProposalOrder = {field: PUBLISHED_AT, direction: ASC}

    """(ROLE_ADMIN only) Select also draft proposals."""
    includeDraft: Boolean = false

    """
    The state of the proposals to filter by. If non-null, filters proposals with the given state.
    """
    state: ProposalsState

    """
    ID of a ProposalDistrict to filter by. If non-null, filters proposals with the given district.
    """
    district: ID

    """
    ID of a UserType to filter by. If non-null, filters proposals with the given type of author.
    """
    userType: ID

    """
    ID of a ProposalCategory to filter by. If non-null, filters proposals with the given category.
    """
    category: ID

    """
    ID of a ProposalStatus to filter by. If non-null, filters proposals with the given status.
    """
    status: ID

    """
    ID of a Theme to filter by. If non-null, filters proposals with the given theme.
    """
    theme: ID

    """If non-null, filters proposals with the given string to look for."""
    term: String

    """Affiliation options for proposals returned from the connection."""
    affiliations: [ProposalAffiliation]

    """(ROLE_SUPER_ADMIN only) Select also unpublished proposals."""
    includeUnpublished: Boolean = false

    """The global progress status of the proposal."""
    progressStatus: ProposalProgressState

    """The analysts's ids assigned to the proposal"""
    analysts: [ID!]

    """The supervisor's id assigned to the proposal"""
    supervisor: ID

    """The decision-maker's id assigned to the proposal"""
    decisionMaker: ID
  ): ProposalConnection!

  """The viewer unpublished proposals (only visible by viewer)."""
  viewerProposalsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection

  """The requirements to vote on this step."""
  requirements(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): RequirementConnection!

  """
  If votesRanking enabled, votesLimit is the reference value for the points scale.
  """
  votesLimit: Int

  """
  Minimum number of votes a user must submit for his votes to be counted.
  """
  votesMin: Int
  budget: Int
  voteType: ProposalStepVoteType!
  votable: Boolean!
  votesHelpText: String
  voteThreshold: Int
  statuses: [ProposalStepStatus!]!
  defaultSort: String
  open: Boolean!

  """If enabled, allow voters to order their votes by point"""
  votesRanking: Boolean!

  """A list of viewer votes associated with the step."""
  viewerVotes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ProposalVoteOrder = {direction: DESC}
  ): ProposalVoteConnection!
  form: ProposalForm
  position: Int!

  """
  Only one selection step inside a project can have realisation steps, true if this one
  """
  allowingProgressSteps: Boolean!

  """
  Whether or not authors can add news on proposals selected in this step
  """
  allowAuthorsToAddNews: Boolean!

  """A list of contributor associated with the consultation."""
  contributors(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): UserConnection!

  """The main view : grid, list or map"""
  mainView: String!
  defaultStatus: ProposalStepStatus
  isAnalysisStep: Boolean!
}

"""
Available errors for an `sendConfirmationEmailDebateAnonymousArgument` mutation.
"""
enum SendConfirmationEmailDebateAnonymousArgumentErrorCode {
  """No `Debate` match your `id`."""
  UNKNOWN_DEBATE

  """The debate is closed and arguments cannot be published any more."""
  CLOSED_DEBATE

  """The given hash is not valid."""
  INVALID_HASH

  """The user has no argument on this debate."""
  UNKNOWN_DEBATE_ARGUMENT

  """The argument has already been published."""
  ALREADY_PUBLISHED_ARGUMENT
}

input SendConfirmationEmailDebateAnonymousArgumentInput {
  """The Node ID of the `Debate` to where the argument is."""
  debate: ID!

  """The cookie hash needed to identify anonymous argument."""
  hash: String!
  clientMutationId: String
}

type SendConfirmationEmailDebateAnonymousArgumentPayload {
  """The argument to be confirmed."""
  debateArgument: DebateAnonymousArgument

  """An unsuccessful mutation will return an error."""
  errorCode: SendConfirmationEmailDebateAnonymousArgumentErrorCode
  clientMutationId: String
}

input SendContactFormInput {
  """The ID of the contact form."""
  idContactForm: ID!

  """The title of the contact form."""
  title: String!

  """The body of the contact form."""
  body: String!

  """The email of the contact."""
  email: String!

  """The captcha of the form."""
  name: String

  """The captcha verification."""
  captcha: String
  clientMutationId: String
}

type SendContactFormPayload {
  """The contact form submited."""
  contactForm: ContactForm!
  clientMutationId: String
}

"""Available errors when sending or testing a campaign"""
enum SendEmailingCampaignErrorCode {
  """No campaign match your id"""
  ID_NOT_FOUND

  """
  The campaign cannot be sent : maybe it is not a draft, maybe it is not complete
  """
  CANNOT_BE_SENT
}

input SendEmailingCampaignInput {
  """Global id of the campaign to send"""
  id: ID!
  clientMutationId: String
}

type SendEmailingCampaignPayload {
  """The campaign sent"""
  emailingCampaign: EmailingCampaign

  """The error code, if any"""
  error: SendEmailingCampaignErrorCode
  clientMutationId: String
}

"""Represent an email address to use to send emails."""
type SenderEmail {
  """uuid of the SenderEmail"""
  id: ID!

  """The first part of the address, before the @."""
  locale: String!

  """The second part of the address, after the @."""
  domain: String!

  """The whole address."""
  address: String!

  """Is the address selected to send."""
  isDefault: Boolean!
}

"""Represent a registered domain name for a mailer service"""
type SenderEmailDomain {
  """Uuid of the domain."""
  id: ID!

  """The domain, eg cap-collectif.com."""
  value: String!

  """The service to use : mailjet or mandrill."""
  service: SenderEmailDomainService!

  """Is the SPF validated."""
  spfValidation: Boolean!

  """Is the DKIM validated."""
  dkimValidation: Boolean!
}

"""Possible types for SenderEmailDomain."""
enum SenderEmailDomainService {
  """Choice of the external mailer client : mandrill or mailjet."""
  MANDRILL

  """Choice of the external mailer client : mandrill or mailjet."""
  MAILJET
}

input SetDefaultLocaleInput {
  """Locale uuid."""
  id: ID!
  clientMutationId: String
}

type SetDefaultLocalePayload {
  """The new default Locale"""
  locale: Locale
  clientMutationId: String
}

input SetEvaluationFormInProposalFormInput {
  proposalFormId: ID!
  evaluationFormId: ID
  clientMutationId: String
}

type SetEvaluationFormInProposalFormPayload {
  proposalForm: ProposalForm!
  clientMutationId: String
}

input SetUserDefaultLocaleInput {
  """User uuid."""
  userId: ID

  """Locale code """
  code: String
  clientMutationId: String
}

type SetUserDefaultLocalePayload {
  code: String
  clientMutationId: String
}

type ShieldAdminForm {
  """Is shield mode is active?"""
  shieldMode: Boolean!

  """Introduction text to show in shield page."""
  introduction: HTML

  """Image to show in shield page."""
  media: Media
  translations: [ShieldAdminFormTranslation!]!
}

type ShieldAdminFormTranslation {
  """The locale of the translation"""
  locale: String!

  """Introduction text to show in shield page."""
  introduction: HTML
}

"""A simple question"""
type SimpleQuestion implements Question & Node {
  """The ID of an object"""
  id: ID!

  """Identifies the question title."""
  title: String!

  """Return responses on this questions."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get responses with user not confirmed"""
    withNotConfirmedUser: Boolean = false

    """Get responses in which the term appears."""
    term: String
  ): ResponseConnection!
  number: Int!
  type: QuestionTypeValue!

  """The position of the question"""
  position: Int!
  private: Boolean!
  required: Boolean!
  helpText: String
  description: String
  kind: String!
  slug: String!

  """Return users who answered the question"""
  participants(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Get participant with user not confirmed"""
    withNotConfirmedUser: Boolean = false
  ): ParticipantConnection!

  """The associated logic jumps to this question."""
  jumps(
    """Ordering options for question jumps."""
    orderBy: JumpsOrder = {field: POSITION, direction: ASC}
  ): [LogicJump!]!

  """The jumps of which this question is the destination"""
  destinationJumps: [LogicJump!]!

  """The destination of the always jump (the else case) of this question."""
  alwaysJumpDestinationQuestion: Question

  """Boolean to decide whether the question will be rendered or not"""
  hidden: Boolean!

  """if type number, value can be ranged (number question only)"""
  isRangeBetween: Boolean!

  """value min, if isRangeBetween (number question only)"""
  rangeMin: Int

  """value max, if isRangeBetween (number question only)"""
  rangeMax: Int

  """
  Return array containing object with number of occurrences by response's keywords.
  """
  tagCloud(
    """Defines the number of aggregation for the tag cloud."""
    size: Int = 20
  ): [TagCloudItem!]!
}

"""A site color."""
type SiteColor {
  keyname: String!
  value: String
}

"""A site image"""
type SiteImage {
  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!
  id: ID!

  """A unique key to distinguish site image"""
  keyname: String!

  """Does the site image is currently enabled?"""
  isEnabled: Boolean!

  """The position of the site image"""
  position: Int!

  """The category of the site image"""
  category: String!

  """The associated media of the site image"""
  media: Media
}

"""A site parameter"""
type SiteParameter {
  id: ID!
  keyname: String!
  isTranslatable: Boolean
  translations: [SiteParameterTranslation]
  value: String
}

"""translation of site parameter"""
type SiteParameterTranslation {
  id: ID!
  value: String!
  locale: String!
}

"""A source"""
type Source implements Node & Publishable & Contribution & Trashable & UniformResourceLocatable & Reportable & ContributionWithAuthor {
  """The ID of an object."""
  id: ID!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The source's url"""
  url: URI!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """Does the viewer already submitted a report ?"""
  viewerHasReport: Boolean!

  """Whether or not the user can contribute to the source."""
  contribuable: Boolean!

  """Whether or not the user has voted for this source."""
  viewerHasVote: Boolean!

  """The title of the source."""
  title: String!

  """The content of the source."""
  body: String!

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """The author of the contribution."""
  author: User!
  step: ConsultationStep!
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): SourceVoteConnection
  viewerVote: SourceVote
  category: SourceCategory

  """The link of the source."""
  link: URI!
  kind: String!
}

"""A source category."""
type SourceCategory {
  id: ID!
  title: String!
}

"""A connection to a list of items."""
type SourceConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [SourceEdge]
}

"""An edge in a connection."""
type SourceEdge {
  """The item at the end of the edge."""
  node: Source!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which source connections can be ordered."""
input SourceOrder {
  """The field in which to order nodes by."""
  field: SourceOrderField!

  """The direction in which to order nodes."""
  direction: OrderDirection! = ASC
}

"""Properties by which source connections can be ordered"""
enum SourceOrderField {
  """Allows ordering a list of sources by when they were published."""
  PUBLISHED_AT

  """Allows ordering a list of sources by the number of votes it have."""
  VOTES
}

"""A contribution with an author"""
type SourceVote implements Vote & Publishable & Contribution {
  """The ID of an object"""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution."""
  author: User

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """Returns 'sourceVote'."""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """Url of the contribution"""
  url: URI!
}

"""A connection to a list of items."""
type SourceVoteConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [SourceVoteEdge]
}

"""An edge in a connection."""
type SourceVoteEdge {
  """The item at the end of the edge."""
  node: SourceVote!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A sourceable"""
interface Sourceable {
  id: ID!
  contribuable: Boolean!
  step: ConsultationStep!

  """The sources related to the sourceable."""
  sources(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: SourceOrder = {field: PUBLISHED_AT, direction: DESC}
  ): SourceConnection!

  """
  The viewer unpublished sources related to the sourceable (only visible by viewer).
  """
  viewerSourcesUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): SourceConnection!

  """The available sources categories of to the sourceable."""
  availableSourceCategories: [SourceCategory]
}

"""A step inside a project."""
interface Step {
  """When the time interval begins or ends."""
  timeRange: TimeRange!

  """The URL to this resource."""
  url: URI!

  """The ID of an object"""
  id: ID!

  """The title of the step."""
  title: String!

  """Identifies the current state of the step."""
  state: StepState!

  """The kind of the step"""
  kind: String! @deprecated(reason: "Please, use `__typename` instead.")

  """The type of the step"""
  type: String @deprecated(reason: "Please, use `__typename` instead.")

  """Does the step have a end date ?"""
  timeless: Boolean

  """The introduction text of the step."""
  body: HTML

  """Is the step enabled or not"""
  enabled: Boolean!

  """The label of the step"""
  label: String!

  """The step's metadescription"""
  metaDescription: String

  """The step's custom code"""
  customCode: String

  """The step's slug"""
  slug: String

  """Events linked to the step"""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: EventOrder! = {field: START_AT, direction: DESC}
  ): EventConnection!
  project: Project
  exportStepUrl: URI
  exportContributorsUrl: URI
}

"""Ways in which lists of steps can be ordered upon return."""
input StepOrder {
  """The field in which to order nodes by."""
  field: StepOrderField! = POSITION

  """The direction in which to order nodes."""
  direction: OrderDirection! = DESC
}

"""Ordering options for steps returned from the connection."""
enum StepOrderField {
  """Allows ordering a list of steps by position."""
  POSITION
}

input StepRequirementInput {
  id: ID
  label: String
  type: RequirementType!
}

"""The possible states in which a step can be."""
enum StepState {
  """The step has not started yet."""
  FUTURE

  """The step is currently open."""
  OPENED

  """The step has been closed."""
  CLOSED
}

input StepStatusInput {
  id: ID
  name: String
  color: ProposalStepStatusColor
}

"""A object style."""
type Style {
  id: ID

  """Specify if the style is activated or not."""
  enabled: Boolean!

  """The color value in hexadecimal format for the border or background."""
  color: Color

  """The value of the opacity of the border or the background."""
  opacity: Float

  """The value of the border size."""
  size: Int
}

input SubscribeToEventAsNonRegisteredInput {
  eventId: ID!

  """Email of user"""
  email: String!

  """Username of user"""
  username: String!

  """Should the event registration be private"""
  private: Boolean = false
  clientMutationId: String
}

type SubscribeToEventAsNonRegisteredPayload {
  """Event"""
  event: Event
  clientMutationId: String
}

input SubscribeToEventAsRegisteredInput {
  """Event global id"""
  eventId: ID!

  """Should the event registration be private"""
  private: Boolean = false
  clientMutationId: String
}

type SubscribeToEventAsRegisteredPayload {
  """Event"""
  event: Event
  clientMutationId: String
}

"""3 possible values for a subscription."""
enum SubscriptionTypeValue {
  """Get all notifications for this subscription"""
  ALL

  """Get essentials notifications for this subscription"""
  ESSENTIAL

  """Get minimal notifications for this subscription"""
  MINIMAL
}

"""Object containing the tag value and the number of occurrences."""
type TagCloudItem {
  """The tag value."""
  value: String!

  """The number of time this value appears in a response's text value."""
  occurrencesCount: Int!
}

input TestEmailingCampaignInput {
  """Global id of the campaign to test"""
  id: ID!

  """email receiving the tested campaign"""
  email: Email!
  clientMutationId: String
}

type TestEmailingCampaignPayload {
  """The email sent"""
  html: HTML

  """error code, if any"""
  error: SendEmailingCampaignErrorCode
  clientMutationId: String
}

"""A theme"""
type Theme implements UniformResourceLocatable {
  """Identifies the title of the theme."""
  title(
    """The locale to translate content (eg: FR_FR)."""
    locale: TranslationLocale
  ): String!

  """The URL to this resource."""
  url: URI!
  id: ID!
  translations: [ThemeTranslation!]!
}

"""A translation theme."""
type ThemeTranslation {
  """The theme translation related locale."""
  locale: TranslationLocale!

  """The title of the theme translation."""
  title: String

  """The body of the theme translation."""
  body: String

  """The theme translation teaser."""
  teaser: String
}

"""A time range that contains start date and end date."""
type TimeRange {
  """The start date of the time range."""
  startAt: DateTime

  """The end date of the time range"""
  endAt: DateTime

  """Whether it has started"""
  hasStarted: Boolean!

  """Whether it has ended"""
  hasEnded: Boolean!

  """Get the remaining time in days/hours"""
  remainingTime: RemainingTime

  """Whether it last one day"""
  lastOneDay: Boolean!

  """Whether it is still open"""
  isOpen: Boolean!

  """Whether it is closed"""
  isClosed: Boolean!

  """Whether it occurs in the future"""
  isFuture: Boolean!

  """Whether it is timeless"""
  isTimeless: Boolean!
}

"""Object containing all tipsmee related data."""
type TipsMeee {
  """The number of donation"""
  donationCount: Int!

  """The number of donators."""
  donatorsCount: Int!

  """The donation total count."""
  donationTotalCount: Float!

  """The top donators of the proposal."""
  topDonators(
    """The first n top donators."""
    first: Int = 100
  ): [ProposalTopDonator!]!
}

input ToggleFeatureInput {
  """The type of the feature"""
  type: FeatureFlagType!
  enabled: Boolean!
  clientMutationId: String
}

type ToggleFeaturePayload {
  featureFlag: FeatureFlag
  clientMutationId: String
}

input ToggleSSOConfigurationStatusInput {
  ssoConfigurationId: ID!
  clientMutationId: String
}

type ToggleSSOConfigurationStatusPayload {
  ssoConfiguration: SSOConfiguration!
  clientMutationId: String
}

"""A translation locale"""
enum TranslationLocale {
  """English - UNITED KINGDOM locale"""
  EN_GB

  """French - FRANCE locale"""
  FR_FR

  """Spanish - SPAIN locale"""
  ES_ES

  """German - GERMANY locale"""
  DE_DE

  """Dutch - NETHERLANDS locale"""
  NL_NL

  """Swedish - SWEDEN locale"""
  SV_SE

  """Basque - EUSKADIA locale"""
  EU_EU

  """Gascon - OCCITAN locale"""
  OC_OC
}

"""Available errors for a `trash` mutation."""
enum TrashErrorCode {
  """No trashable entity match your id."""
  TRASHABLE_NOT_FOUND
}

input TrashInput {
  """The id of the trashable entity."""
  id: ID!
  trashedStatus: TrashableStatus!

  """The reason why the entity is trashed."""
  trashedReason: String
  clientMutationId: String
}

type TrashPayload {
  """The entity that had just been trashed."""
  trashable: Trashable

  """An unsuccessful mutation will return an error."""
  errorCode: TrashErrorCode
  clientMutationId: String
}

"""Entities that can be trashed."""
interface Trashable {
  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String
}

"""Different trashable status."""
enum TrashableStatus {
  """Content is not visible."""
  INVISIBLE

  """Content is visible."""
  VISIBLE
}

"""An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string."""
scalar URI

"""Available errors for an `unTrash` mutation."""
enum UnTrashErrorCode {
  """No trashable entity match your id."""
  TRASHABLE_NOT_FOUND

  """The entity is not trashed."""
  NOT_TRASHED
}

input UnTrashInput {
  """The id of the trashed entity."""
  id: ID!
  clientMutationId: String
}

type UnTrashPayload {
  """The entity that had just been untrashed."""
  trashable: Trashable

  """An unsuccessful mutation will return an error."""
  errorCode: UnTrashErrorCode
  clientMutationId: String
}

input UnfollowOpinionInput {
  """The opinion id"""
  opinionId: ID

  """Array of opinion id"""
  idsOpinion: [ID!]
  clientMutationId: String
}

type UnfollowOpinionPayload {
  opinion: OpinionOrVersion
  unfollowerId: ID
  clientMutationId: String
}

input UnfollowProposalInput {
  """The proposal id"""
  proposalId: ID

  """Array of proposal id"""
  idsProposal: [ID!]
  clientMutationId: String
}

type UnfollowProposalPayload {
  proposal: Proposal
  unfollowerId: ID
  clientMutationId: String
}

"""Represents a type that can be retrieved by a URL on the admin."""
interface UniformResourceAdminLocatable {
  """The admin URL to this resource."""
  adminUrl: URI
}

"""Represents a type that can be retrieved by a URL."""
interface UniformResourceLocatable {
  """The URL to this resource."""
  url: URI!
}

input UnselectProposalInput {
  """The step where the proposal is selected"""
  stepId: String!

  """The proposal ID to remove from step."""
  proposalId: ID!
  clientMutationId: String
}

type UnselectProposalPayload {
  proposal: Proposal!
  clientMutationId: String
}

input UnsubscribeToEventAsRegisteredInput {
  eventId: ID!
  clientMutationId: String
}

type UnsubscribeToEventAsRegisteredPayload {
  """Event"""
  event: Event
  clientMutationId: String
}

"""Entities that can be updated."""
interface Updatable {
  """Check if the current viewer can update this object"""
  viewerCanUpdate: Boolean!
}

input UpdateAlphaProjectInput {
  """The project title"""
  title: String!

  """The project authors IDs"""
  authors: [ID!]!

  """The project type ID"""
  projectType: ID

  """The project cover"""
  Cover: ID

  """The project video link"""
  video: String

  """The project themes IDs"""
  themes: [ID!]!

  """The project districts IDs"""
  districts: [ID!]!

  """The project metadescription"""
  metaDescription: String

  """Is the project external"""
  isExternal: Boolean!

  """The project external link"""
  externalLink: String

  """The project external participants count"""
  externalParticipantsCount: Int

  """The project external contributions count"""
  externalContributionsCount: Int

  """The project external votes count"""
  externalVotesCount: Int

  """The project publication date"""
  publishedAt: DateTime!

  """The project visibility"""
  visibility: ProjectVisibility!
  opinionCanBeFollowed: Boolean!
  steps: [ProjectStepInput!]!
  headerType: ProjectHeaderType
  coverFilterOpacityPercent: Int

  """The locale id of the project. Null if visible by all languages"""
  locale: ID

  """Groups id."""
  restrictedViewerGroups: [ID!]

  """if it is archived"""
  archived: Boolean!
  clientMutationId: String
  projectId: ID!
}

type UpdateAlphaProjectPayload {
  """The created project"""
  project: Project
  clientMutationId: String
}

input UpdateContactFormInput {
  """ID of the contact form to update."""
  id: ID!

  """Email of the interlocutor of the contact form."""
  email: String!
  translations: [ContactFormTranslationInput!]!
  clientMutationId: String
}

type UpdateContactFormPayload {
  """The contact form updated."""
  contactForm: ContactForm
  clientMutationId: String
}

input UpdateContactPageInput {
  """The title of the contact page."""
  title: String

  """The description of the contact page."""
  description: HTML

  """The picto of the contact page."""
  picto: ID

  """The metadescription of the contact page."""
  metadescription: String

  """The customcode of the contact page."""
  customcode: String

  """The locale of the contact page."""
  locale: String
  clientMutationId: String
}

type UpdateContactPagePayload {
  """The title of the contact page."""
  title: String!

  """The description of the contact page."""
  description: HTML

  """The picto of the contact page."""
  picto: SiteImage

  """The metadescription of the contact page."""
  metadescription: String

  """The customcode of the contact page."""
  customcode: String

  """The locale of the contact page."""
  locale: String
  clientMutationId: String
}

"""Available errors for an `updateDebateArgument` mutation."""
enum UpdateDebateArgumentErrorCode {
  """No `DebateArgument` match your id."""
  UNKNOWN_DEBATE_ARGUMENT

  """Wrong author of the `DebateArgument`."""
  NOT_ARGUMENT_AUTHOR
}

input UpdateDebateArgumentInput {
  """The global id of the argument to update."""
  id: ID!

  """The body value of the argument."""
  body: String!
  clientMutationId: String
}

type UpdateDebateArgumentPayload {
  """The argument that had just been updated."""
  debateArgument: DebateArgument

  """An unsuccessful mutation will return an error."""
  errorCode: UpdateDebateArgumentErrorCode
  clientMutationId: String
}

"""Available errors for an `updateDebateOpinion` mutation."""
enum UpdateDebateOpinionErrorCode {
  """No `DebateOpinion` match your `debateOpinionId`."""
  UNKNOWN_DEBATE_OPINION

  """The provided values are not valid."""
  INVALID_FORM
}

input UpdateDebateOpinionInput {
  """The Node ID of the `DebateOpinion` to update."""
  debateOpinionId: ID!

  """If provided, update the title value."""
  title: String

  """If provided, update the body value."""
  body: HTML

  """If a Node ID of a `User` is provided, update the author."""
  author: ID

  """If provided, update the type."""
  type: ForOrAgainstValue
  clientMutationId: String
}

type UpdateDebateOpinionPayload {
  """The just updated opinion."""
  debateOpinion: DebateOpinion

  """An unsuccessful mutation will return an error."""
  errorCode: UpdateDebateOpinionErrorCode
  clientMutationId: String
}

"""Available errors on campaign edition"""
enum UpdateEmailingCampaignErrorCode {
  """No campaign match your id"""
  ID_NOT_FOUND

  """The campaign is not editable"""
  NOT_EDITABLE

  """sendAt must be in the future"""
  TOO_LATE

  """A campaign cannot have both internal and organic list"""
  DOUBLE_LIST

  """No mailing list match your id"""
  MAILING_LIST_NOT_FOUND
}

input UpdateEmailingCampaignInput {
  """Global id of the campaign to update"""
  id: ID!

  """Name of the campaign"""
  name: String!

  """Email to appear as sender"""
  senderEmail: String!

  """Name to appear as sender"""
  senderName: String!

  """Id of the mailing list"""
  mailingList: ID

  """Id of the internal mailing list"""
  mailingInternal: ID

  """object of the email"""
  object: String = ""

  """content of the email"""
  content: String = ""

  """unlayer configuration of the email"""
  unlayerConf: String

  """the date when the email shall be sent"""
  sendAt: DateTime = null
  clientMutationId: String
}

type UpdateEmailingCampaignPayload {
  """The campaign created"""
  emailingCampaign: EmailingCampaign

  """The error code, if any"""
  error: UpdateEmailingCampaignErrorCode
  clientMutationId: String
}

"""Available errors on update of external services configurations."""
enum UpdateExternalServiceConfigurationErrorCode {
  """The given value is not valid for the selected type."""
  INVALID_VALUE
}

input UpdateExternalServiceConfigurationInput {
  """The configuration to update"""
  type: ExternalServiceConfigurationType!

  """The new value of the configuration."""
  value: String!
  clientMutationId: String
}

type UpdateExternalServiceConfigurationPayload {
  externalServiceConfiguration: ExternalServiceConfiguration!
  error: UpdateExternalServiceConfigurationErrorCode
  clientMutationId: String
}

input UpdateFacebookSSOConfigurationInput {
  """Client ID."""
  clientId: String!

  """Secret key."""
  secret: String!

  """True to enable facebook login."""
  enabled: Boolean!
  clientMutationId: String
}

type UpdateFacebookSSOConfigurationPayload {
  """The updated Facebook connect configuration."""
  facebookSSOConfiguration: FacebookSSOConfiguration
  clientMutationId: String
}

input UpdateFollowOpinionInput {
  """The opinion id"""
  opinionId: ID!
  notifiedOf: SubscriptionTypeValue!
  clientMutationId: String
}

type UpdateFollowOpinionPayload {
  follower: Follower
  followerEdge: FollowerEdge
  opinion: OpinionOrVersion
  clientMutationId: String
}

input UpdateFollowProposalInput {
  """The proposal id"""
  proposalId: ID!
  notifiedOf: SubscriptionTypeValue!
  clientMutationId: String
}

type UpdateFollowProposalPayload {
  follower: Follower
  followerEdge: FollowerEdge
  proposal: Proposal
  clientMutationId: String
}

input UpdateFranceConnectSSOConfigurationInput {
  """Client ID."""
  clientId: String!

  """Secret key."""
  secret: String!

  """Environment mode."""
  environment: SSOEnvironment!
  given_name: Boolean!
  family_name: Boolean!
  birthdate: Boolean!
  birthplace: Boolean!
  birthcountry: Boolean!
  gender: Boolean!
  email: Boolean!
  preferred_username: Boolean!
  clientMutationId: String
}

type UpdateFranceConnectSSOConfigurationPayload {
  """The updated France Connect configuration."""
  fcConfiguration: FranceConnectSSOConfiguration
  clientMutationId: String
}

input UpdateGroupInput {
  groupId: ID!
  title: String!
  description: String
  clientMutationId: String
}

type UpdateGroupPayload {
  group: Group!
  clientMutationId: String
}

"""
Available errors for an `updateHomePageProjectsSectionConfiguration` mutation.
"""
enum UpdateHomePageProjectsSectionConfigurationErrorCode {
  """Limit of projects that can be dispayed in the homepage"""
  TOO_MANY_PROJECTS

  """The form is not valid"""
  INVALID_FORM
}

input UpdateHomePageProjectsSectionConfigurationInput {
  """The position of the section in the homepage"""
  position: Int!

  """How to display the projects"""
  displayMode: HomePageProjectsSectionConfigurationDisplayMode!

  """Number of objects to display"""
  nbObjects: Int!

  """Whether it is published or not"""
  enabled: Boolean!
  translations: [HomePageProjectsSectionConfigurationTranslationInput!]
  projects: [ID!]!
  clientMutationId: String
}

type UpdateHomePageProjectsSectionConfigurationPayload {
  """the updated homePageProjectsSectionConfiguration"""
  homePageProjectsSectionConfiguration: HomePageProjectsSectionConfiguration

  """An unsuccessful mutation will return an error."""
  errorCode: UpdateHomePageProjectsSectionConfigurationErrorCode
  clientMutationId: String
}

input UpdateLocaleStatusInput {
  locales: [LocaleStatusInput!]!
  clientMutationId: String
}

type UpdateLocaleStatusPayload {
  locales: LocaleConnection!
  clientMutationId: String
}

input UpdateOauth2SSOConfigurationInput {
  """Client ID."""
  clientId: String!

  """Secret key."""
  secret: String!

  """Authorization URL."""
  authorizationUrl: URI!

  """Access token URL."""
  accessTokenUrl: URI!

  """User info URL."""
  userInfoUrl: URI!

  """Logout URL."""
  logoutUrl: URI

  """Profile URL on the SSO side."""
  profileUrl: URI

  """Specify if this SSO configuration is active or not."""
  enabled: Boolean!

  """The name of your SSO provider."""
  name: String!

  """Color in hexadecimal of SSO button."""
  buttonColor: Color!

  """Color in hexadecimal of label SSO button."""
  labelColor: Color!

  """The ID of oauth2 configuration that needs to be updated."""
  id: ID!
  clientMutationId: String
}

type UpdateOauth2SSOConfigurationPayload {
  """The updated oauth2 configuration."""
  ssoConfiguration: Oauth2SSOConfiguration
  clientMutationId: String
}

"""Available errors on OfficialResponse creation or edition"""
enum UpdateOfficialResponseErrorCode {
  """No OfficialResponse match your id"""
  ID_NOT_FOUND

  """No author match your id"""
  AUTHOR_NOT_FOUND

  """OfficialResponse needs at least one author"""
  NO_AUTHOR

  """No proposal match your id"""
  PROPOSAL_NOT_FOUND

  """The proposal already has an OfficialResponse"""
  PROPOSAL_HAS_RESPONSE

  """The received date is not valid."""
  INVALID_DATE

  """Not admin of this project."""
  NOT_ADMIN
}

input UpdateOfficialResponseInput {
  """If provided, the id of the OfficialResponse to update."""
  id: ID

  """The body of the OfficialResponse."""
  body: HTML!

  """True if the OfficialResponse is published."""
  isPublished: Boolean!

  """Identifies the date and time when the object has to be published."""
  publishedAt: DateTime

  """The id of the authors of the OfficialResponse."""
  authors: [ID!]!

  """The id of the proposal linked to the OfficialResponse."""
  proposal: ID!
  clientMutationId: String
}

type UpdateOfficialResponsePayload {
  """The OfficialResponse who just have been updated."""
  officialResponse: OfficialResponse

  """The error, if any."""
  error: UpdateOfficialResponseErrorCode
  clientMutationId: String
}

"""Available errors on opinion update"""
enum UpdateOpinionErrorCode {
  """the user is not authorized to edit this opinion"""
  NOT_AUTHORIZED

  """the opinion is not contribuable"""
  OPINION_NOT_CONTRIBUABLE

  """the form is invalid"""
  INVALID_FORM
}

input UpdateOpinionInput {
  """the id of the opinion to update"""
  opinionId: ID!

  """the opinion title"""
  title: String!

  """the opinion body"""
  body: String!

  """the opinion appendices"""
  appendices: [AppendixInput]!
  clientMutationId: String
}

type UpdateOpinionPayload {
  """the updated opinion"""
  opinion: Opinion

  """available errors if mutation fails"""
  errorCode: UpdateOpinionErrorCode
  clientMutationId: String
}

"""Available errors on updatePost mutation"""
enum UpdatePostErrorCode {
  """Submitted form is invalid"""
  INVALID_FORM
}

input UpdatePostInput {
  translations: [CreatePostTranslationInput!]

  """post authors"""
  authors: [ID!]!

  """post customCode"""
  customCode: String

  """related projects related to the post"""
  projects: [ID]!

  """proposals related to the post"""
  proposals: [ID]!

  """themes related to the post"""
  themes: [ID]!

  """Whether or not the post should be displayed on blog"""
  displayedOnBlog: Boolean!

  """When the post should be pusblished"""
  publishedAt: DateTime!

  """Whether or not the post should be published"""
  isPublished: Boolean!

  """Whether or not the post should be commentable"""
  commentable: Boolean!

  """The media attached to the post"""
  media: ID
  clientMutationId: String

  """The id of the post to update"""
  id: ID!
}

type UpdatePostPayload {
  """The updated post"""
  post: Post

  """Available errorCode for updatePost mutation"""
  errorCode: UpdatePostErrorCode
  clientMutationId: String
}

input UpdateProfileAccountEmailInput {
  """The password to confirm action"""
  passwordConfirm: String!

  """The email to change"""
  email: String!
  clientMutationId: String
}

type UpdateProfileAccountEmailPayload {
  """The user who just have been updated"""
  viewer: User

  """The error"""
  error: UpdateUserEmailErrorCode
  clientMutationId: String
}

input UpdateProfileAccountLocaleInput {
  """The locale to change"""
  locale: TranslationLocale!
  clientMutationId: String
}

type UpdateProfileAccountLocalePayload {
  """The user who just have been updated"""
  viewer: User

  """The new locale code"""
  locale: TranslationLocale

  """The error"""
  error: String
  clientMutationId: String
}

input UpdateProfileInput {
  username: String
  clientMutationId: String
}

input UpdateProfilePasswordInput {
  """The current password"""
  current_password: String!

  """The new password"""
  new_password: String!
  clientMutationId: String
}

type UpdateProfilePasswordPayload {
  """The user who just have been updated"""
  user: User!

  """The error"""
  error: String
  clientMutationId: String
}

type UpdateProfilePayload {
  """The viewer"""
  viewer: User!
  clientMutationId: String
}

input UpdateProfilePersonalDataInput {
  """
  (ROLE_SUPER_ADMIN only) the user to update, if not provided the viewer is updated.
  """
  userId: ID

  """Your firstname"""
  firstname: String

  """Your lastname"""
  lastname: String

  """Your gender"""
  gender: GenderValue

  """Your phone number"""
  phone: String

  """Your address, geocoded by google"""
  postalAddress: String

  """Your address"""
  address: String

  """Your complementary address"""
  address2: String

  """Your city"""
  city: String

  """Your zipcode"""
  zipCode: String

  """Your date of birth"""
  dateOfBirth: String

  """Is your phone confirmed ?"""
  phoneConfirmed: Boolean

  """Your email"""
  email: String

  """Your birth place"""
  birthPlace: String

  """Your identification code"""
  identificationCode: String
  clientMutationId: String
}

type UpdateProfilePersonalDataPayload {
  """The user who just have been updated"""
  user: User!
  clientMutationId: String
}

input UpdateProfilePublicDataInput {
  """
  (ROLE_SUPER_ADMIN only) the user to update, if not provided the viewer is updated.
  """
  userId: ID

  """Your username"""
  username: String!

  """Your user type"""
  userType: ID

  """Your biography"""
  biography: String

  """Your neighborhood"""
  neighborhood: String

  """Your website"""
  websiteUrl: URI

  """Your linkedIn"""
  linkedInUrl: String

  """Your facebook"""
  facebookUrl: String

  """Your twitter"""
  twitterUrl: String

  """Whether or not this user profile page is indexed."""
  profilePageIndexed: Boolean

  """Current media id"""
  media: ID
  clientMutationId: String
}

type UpdateProfilePublicDataPayload {
  """The user who just have been updated"""
  user: User!
  clientMutationId: String
}

input UpdateProjectDistrictInput {
  id: ID!

  """A GeoJSON format to display in map after."""
  geojson: GeoJSON

  """Should I display this on map?"""
  displayedOnMap: Boolean = false

  """The border style attached to this district."""
  border: BorderStyleInput

  """The background style attached to this district."""
  background: BackgroundStyleInput

  """The names of the district for each language"""
  translations: [DistrictTranslationInput!]!
}

input UpdateProjectInput {
  """The project's ID"""
  id: ID!

  """The project's title"""
  title: String

  """The project's authors"""
  authors: [ID!]

  """The project's type"""
  projectType: String

  """The project's date of publication"""
  publishedAt: String

  """The project's themes"""
  themes: [ID]

  """The project's image"""
  Cover: ID

  """The project's video"""
  video: String

  """The project's districts"""
  districts: [ID!]

  """The uuid of the locale of this project, null if none"""
  locale: ID

  """Is the project external or not"""
  isExternal: Boolean

  """The link of an external project"""
  externalLink: String

  """The number of participants in an external project"""
  externalParticipantsCount: Int

  """The number of contributions in an external project"""
  externalContributionsCount: Int

  """The number of votes in an external project"""
  externalVotesCount: Int
  clientMutationId: String
}

type UpdateProjectPayload {
  """The created project"""
  project: Project
  clientMutationId: String
}

input UpdateProposalFormInput {
  proposalFormId: ID!
  title: String
  description: String
  summaryHelpText: String
  illustrationHelpText: String
  usingThemes: Boolean
  themeMandatory: Boolean
  themeHelpText: String
  usingDistrict: Boolean
  districtMandatory: Boolean
  commentable: Boolean
  costable: Boolean
  districtHelpText: String
  usingCategories: Boolean
  categoryMandatory: Boolean
  categoryHelpText: String
  usingAddress: Boolean
  proposalInAZoneRequired: Boolean
  titleHelpText: String
  descriptionHelpText: String
  addressHelpText: String

  """the json of the googleMapsAddress"""
  mapCenter: String
  zoomMap: Int
  categories: [ProposalCategoryInput!]
  districts: [DistrictInput!]
  questions: [QuestionnaireAbstractQuestionInput!]
  allowAknowledge: Boolean

  """Proposal form is type of Proposal or Question or Establishment"""
  objectType: ProposalFormObjectType

  """Proposal form using description field"""
  usingDescription: Boolean

  """Proposal form using illustration field"""
  usingIllustration: Boolean

  """Proposal form using summary field"""
  usingSummary: Boolean
  suggestingSimilarProposals: Boolean

  """Proposal form is description field is mandatory or not"""
  descriptionMandatory: Boolean

  """can the viewer send a contact message to the proposals author"""
  canContact: Boolean

  """can the viewer see the proposals as a grid"""
  isGridViewEnabled: Boolean

  """can the viewer see the proposals as a list"""
  isListViewEnabled: Boolean

  """can the viewer see the proposals as a map"""
  isMapViewEnabled: Boolean

  """Proposal form using tipsmeee field"""
  usingTipsmeee: Boolean

  """Proposal form help text for tipsmeee field"""
  tipsmeeeHelpText: String

  """Can proposal contain web site url"""
  usingWebPage: Boolean! = false

  """Can proposal contain facebook url"""
  usingFacebook: Boolean! = false

  """Can proposal contain twitter url"""
  usingTwitter: Boolean! = false

  """Can proposal contain instagram url"""
  usingInstagram: Boolean! = false

  """Can proposal contain youtube url"""
  usingYoutube: Boolean! = false

  """Can proposal contain linkedin url"""
  usingLinkedIn: Boolean! = false
  clientMutationId: String
}

input UpdateProposalFormNotificationsConfigurationInput {
  proposalFormId: ID!
  onCreate: Boolean!
  onUpdate: Boolean!
  onDelete: Boolean!
  onCommentCreate: Boolean!
  onCommentUpdate: Boolean!
  onCommentDelete: Boolean!
  onProposalNewsCreate: Boolean!
  onProposalNewsUpdate: Boolean!
  onProposalNewsDelete: Boolean!
  email: Email
  clientMutationId: String
}

type UpdateProposalFormNotificationsConfigurationPayload {
  proposalForm: ProposalForm!
  clientMutationId: String
}

type UpdateProposalFormPayload {
  proposalForm: ProposalForm!
  clientMutationId: String
}

input UpdateProposalFusionInput {
  """The proposal to update."""
  proposalId: ID!

  """Proposal ids that are merged."""
  fromProposals: [ID!]!

  """Proposal title for newly created proposal"""
  title: String

  """Proposal description for newly created proposal"""
  description: String
  clientMutationId: String
}

type UpdateProposalFusionPayload {
  """The updated proposal"""
  proposal: Proposal

  """The proposals that have been removed from the fusion."""
  removedMergedFrom: [Proposal]!
  clientMutationId: String
}

input UpdateProposalIllustrationInput {
  """The id of the proposal to update social networks."""
  proposalId: ID!

  """The media id to illustrate, use null to delete an existing media."""
  media: ID
  clientMutationId: String
}

type UpdateProposalIllustrationPayload {
  """The proposal to update."""
  proposal: Proposal

  """An unsuccessful mutation will return an error message"""
  errorCode: ProposalIllustrationErrorCode
  clientMutationId: String
}

input UpdateProposalNewsInput {
  """The Node ID of the proposal news."""
  postId: ID!
  translations: [NewsTranslationInput!]!

  """Current media id"""
  media: ID
  clientMutationId: String
}

type UpdateProposalNewsPayload {
  """The post to update."""
  proposalPost: Post

  """An unsuccessful mutation will return an error message"""
  errorCode: ProposalNewsErrorCode
  clientMutationId: String
}

input UpdateProposalSocialNetworksInput {
  """Link of Web page."""
  webPageUrl: URI

  """Link of Facebook page."""
  facebookUrl: URI

  """Link of Twitter page."""
  twitterUrl: URI

  """Link of Instagram page."""
  instagramUrl: URI

  """Link of LinkedIn profile."""
  linkedInUrl: URI

  """Link of Youtube channel."""
  youtubeUrl: URI

  """The id of the proposal to update social networks."""
  proposalId: ID!
  clientMutationId: String
}

type UpdateProposalSocialNetworksPayload {
  """The proposal to update."""
  proposal: Proposal

  """An unsuccessful mutation will return an error message"""
  errorCode: ProposalSocialNetworksErrorCode
  clientMutationId: String
}

input UpdateProposalVotesInput {
  """The step."""
  step: ID!

  """The votes."""
  votes: [VoteInput!]!
  clientMutationId: String
}

type UpdateProposalVotesPayload {
  step: ProposalStep!
  clientMutationId: String
}

input UpdateQuestionnaireConfigurationInput {
  questionnaireId: ID!

  """The new title of the questionnaire."""
  title: String

  """The new description of the questionnaire."""
  description: String

  """The new list of available questions for this questionnaire"""
  questions: [QuestionnaireAbstractQuestionInput!]
  clientMutationId: String
}

type UpdateQuestionnaireConfigurationPayload {
  questionnaire: Questionnaire
  clientMutationId: String
}

input UpdateQuestionnaireNotificationConfigurationInput {
  """The questionnaire id."""
  questionnaireId: ID!

  """The email that will be used to send notification"""
  email: Email

  """Notify when a response is created for this questionnaire"""
  onQuestionnaireReplyCreate: Boolean!

  """Notify when a response is updated for this questionnaire"""
  onQuestionnaireReplyUpdate: Boolean!

  """Notify when a response is deleted for this questionnaire"""
  onQuestionnaireReplyDelete: Boolean!
  clientMutationId: String
}

type UpdateQuestionnaireNotificationConfigurationPayload {
  """The updated questionnaire."""
  questionnaire: Questionnaire!
  clientMutationId: String
}

input UpdateQuestionnaireParametersInput {
  questionnaireId: ID!
  acknowledgeReplies: Boolean
  anonymousAllowed: Boolean
  multipleRepliesAllowed: Boolean
  privateResult: Boolean
  clientMutationId: String
}

type UpdateQuestionnaireParametersPayload {
  questionnaire: Questionnaire
  clientMutationId: String
}

input UpdateRedirectIOProjectIdInput {
  """The project ID used for the project."""
  projectId: ID!
  clientMutationId: String
}

type UpdateRedirectIOProjectIdPayload {
  """The saved project key."""
  projectId: String
  clientMutationId: String
}

input UpdateRegistrationFormCommunicationInput {
  translations: [RegistrationFormCommunicationInput!]
  topTextDisplayed: Boolean
  bottomTextDisplayed: Boolean
  clientMutationId: String
}

type UpdateRegistrationFormCommunicationPayload {
  registrationForm: RegistrationForm
  clientMutationId: String
}

input UpdateRegistrationFormQuestionsInput {
  questions: [QuestionnaireAbstractQuestionInput!]
  clientMutationId: String
}

type UpdateRegistrationFormQuestionsPayload {
  registrationForm: RegistrationForm
  clientMutationId: String
}

input UpdateRegistrationPageInput {
  """The customcode of the contact page."""
  customcode: String
  clientMutationId: String
}

type UpdateRegistrationPagePayload {
  """The customcode of the Registration page."""
  customcode: String
  clientMutationId: String
}

input UpdateReplyInput {
  """The id of the reply"""
  replyId: ID!

  """The responses to the questionnaire questions"""
  responses: [ResponseInput]

  """Anonymous or not."""
  private: Boolean

  """If true will create a draft reply."""
  draft: Boolean! = false
  clientMutationId: String
}

type UpdateReplyPayload {
  """Update a reply"""
  reply: Reply
  clientMutationId: String
}

input UpdateRequirementInput {
  """The Node ID of the requirement to modify."""
  requirement: ID!

  """The updated value of the requirement."""
  value: Boolean!
  clientMutationId: String
}

type UpdateRequirementPayload {
  viewer: User
  requirement: Requirement
  clientMutationId: String
}

input UpdateShieldAdminFormInput {
  """Enable or disable shield mode."""
  shieldMode: Boolean!

  """introduction"""
  translations: [UpdateShieldAdminFormTranslationInput!]

  """The image id to associate for the shield image."""
  mediaId: ID
  clientMutationId: String
}

type UpdateShieldAdminFormPayload {
  """The shield admin form."""
  shieldAdminForm: ShieldAdminForm!
  clientMutationId: String
}

input UpdateShieldAdminFormTranslationInput {
  """The locale of the translation"""
  locale: String!

  """Introduction text to show on shield page."""
  introduction: HTML
}

"""Available errors for an `updateSiteParameter` mutation."""
enum UpdateSiteParameterErrorCode {
  """The given value is invalid."""
  INVALID_VALUE
}

input UpdateSiteParameterInput {
  """The keyname of the SiteParameter to be updated"""
  keyname: UpdateSiteParameterKeyname!

  """The new value fo the SiteParameter."""
  value: String!

  """The locale of the new value, if relevant."""
  locale: String
  clientMutationId: String
}

"""Available keynames for an `updateSiteParameter` mutation."""
enum UpdateSiteParameterKeyname {
  """Give the user the `ROLE_USER` role."""
  RECEIVE_ADDRESS

  """Give the user the `ROLE_ADMIN` role."""
  SEND_NAME
}

type UpdateSiteParameterPayload {
  """The updated SiteParameter."""
  siteParameter: SiteParameter

  """The error generated, if any."""
  errorCode: UpdateSiteParameterErrorCode
  clientMutationId: String
}

input UpdateUserAccountInput {
  userId: ID!

  """Unattended roles as array."""
  roles: [UserRole]
  locked: Boolean
  vip: Boolean
  enabled: Boolean
  subscribedToProposalNews: Boolean
  clientMutationId: String
}

type UpdateUserAccountPayload {
  user: User!
  clientMutationId: String
}

"""Available errors on user email related mutations."""
enum UpdateUserEmailErrorCode {
  """You must specify your password to update your email."""
  SPECIFY_PASSWORD

  """Already used email."""
  ALREADY_USED_EMAIL

  """Unauthorized email domain."""
  UNAUTHORIZED_EMAIL_DOMAIN
}

"""A user is an individual's account."""
type User implements Node & UniformResourceLocatable & ProjectOwner & PostOwner & QuestionnaireOwner & EventOwner & ProposalFormOwner {
  """User ID"""
  id: ID!

  """The URL to this resource."""
  url: URI!

  """User username."""
  username: String

  """Whether or not this user is the authenticated user."""
  isViewer: Boolean!

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """A URL pointing to the user's Facebook account."""
  facebookUrl: URI

  """A URL pointing to the user's Twitter account."""
  twitterUrl: URI

  """A URL pointing to the user's LinkedIn account."""
  linkedInUrl: URI

  """A URL pointing to the user's public website/blog."""
  websiteUrl: URI

  """The user's public profile biography."""
  biography: String

  """Identifies the date and time when this user account was deleted."""
  deletedAccountAt: DateTime

  """The type of the person."""
  userType: UserType

  """The responses answered by user."""
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ResponseConnection!

  """The user's personal email."""
  email: Email

  """Whether or not this user consent internal communication."""
  consentInternalCommunication: Boolean

  """The user's public avatar URL."""
  avatarUrl: URI

  """Whether or not this user has a confirmed account."""
  enabled: Boolean!

  """Expose Primary Key, do not use it, except for testing purpose."""
  _id: ID!

  """Get all projects that the user owns."""
  projects(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for projects returned from the connection.
    For example, OWNER will include only projects that the current viewer owns.
    
    """
    affiliations: [ProjectAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for posts"""
    orderBy: ProjectOwnerProjectOrder = {direction: DESC, field: PUBLISHED_AT}

    """
    ID of a Status to filter by. If non-null, filter projects by statuses.
    """
    status: ID
  ): ProjectConnection!

  """Get all posts that the user owns."""
  posts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for posts returned from the connection.
    For example, OWNER will include only posts that the current viewer owns.
    
    """
    affiliations: [PostAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for posts"""
    orderBy: PostOrder = {field: UPDATED_AT, direction: DESC}
  ): PostConnection!

  """Get all questionnaires that the user owns."""
  questionnaires(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for questionnaires returned from the connection.
    For example, OWNER will include only questionnaires that the current viewer owns.
    
    """
    affiliations: [QuestionnaireAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for questionnaires"""
    orderBy: QuestionnaireOrder = {field: CREATED_AT, direction: DESC}

    """Filter by available questionnaires"""
    availableOnly: Boolean
  ): QuestionnaireConnection!

  """Get all events that the user owns."""
  events(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """
    Array of viewer's affiliation options for events returned from the connection.
    For example, OWNER will include only events that the current viewer owns.
    
    """
    affiliations: [EventAffiliation!]

    """the search query"""
    search: String

    """The ordering direction for events."""
    orderBy: EventOrder = {field: START_AT, direction: DESC}

    """Filter events by a given status."""
    status: EventStatus = null

    """only fetch where user is author"""
    onlyWhenAuthor: Boolean = false
  ): EventConnection!

  """Get all `ProposalForms` that the user owns."""
  proposalForms(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Only available proposalForms will be returned."""
    availableOnly: Boolean = false

    """
    Array of viewer's affiliation options for proposalForms returned from the connection.
    For example, OWNER will include only proposalForms that the current viewer owns.
    
    """
    affiliations: [ProposalFormAffiliation!]

    """the search query"""
    query: String

    """The ordering direction for proposalForms"""
    orderBy: ProposalFormOrder = {field: CREATED_AT, direction: DESC}
  ): ProposalFormConnection!

  """The user's admin edit url"""
  adminUrl: URI!

  """The user's public avatar file."""
  media: Media

  """The user's public profile name."""
  displayName: String!

  """Whether or not this user is a VIP."""
  vip: Boolean!

  """The user's slug (unique)."""
  slug: String!

  """The user's account confirmation date."""
  confirmedAccountAt: DateTime

  """Last connection of the user."""
  lastLogin: DateTime

  """A user notifications preferences"""
  notificationsConfiguration: UserNotificationsConfiguration!
  locked: Boolean!
  phoneConfirmed: Boolean!
  phoneConfirmationSentAt: DateTime
  gender: GenderValue
  firstname: String
  lastname: String
  dateOfBirth: DateTime

  """Unattended roles as array."""
  roles: [UserRole!]!

  """Array of roles converted and translated to string."""
  rolesText: String

  """Is the personal archive of the user has been deleted"""
  isArchiveDeleted: Boolean!

  """Is the personal archive of the user is ready?"""
  isArchiveReady: Boolean!

  """
  Is the personal archive of the user is being asked for the first time?
  """
  firstArchive: Boolean!
  postalAddress: GoogleMapsAddress
  address: String
  address2: String
  zipCode: String
  city: String
  phone: String
  facebookId: String
  samlId: String
  franceConnectId: String

  """Get all sources of the user"""
  sources(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): SourceConnection!

  """Get the count of votes made by the user"""
  opinionVotesCount: Int!
  argumentVotesCount: Int!

  """Get all proposals of the user."""
  proposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection!
  proposalVotesCount: Int!

  """Get all comment votes of the user."""
  commentVotes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): CommentVoteConnection!

  """
  Provisional number of contributions who will be totally deleted if the user chose to delete his account.
  """
  contributionsToDeleteCount: Int!

  """A list of replies associated to the user."""
  replies(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ReplyConnection!

  """Get all comments of the user."""
  comments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): CommentConnection!

  """Whether or not this user consent external communication."""
  consentExternalCommunication: Boolean!

  """Array of proposals followed by current user."""
  followingProposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 32

    """Ordering options for followers returning from the connection"""
    orderBy: String
  ): ProposalConnection!

  """Array of opinions followed by current user."""
  followingOpinions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for followers returning from the connection"""
    orderBy: String
  ): OpinionConnection!

  """Array of opinions by current user."""
  opinions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): OpinionConnection!

  """Total of contributions count"""
  contributionsCount: Int!

  """Whether or not this user profile page is indexed."""
  profilePageIndexed: Boolean

  """Your localisation"""
  neighborhood: String
  proposalVotes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ProposalVoteOrder = {field: PUBLISHED_AT, direction: DESC}
    stepId: ID

    """(ROLE_SUPER_ADMIN only) Select also unpublished votes."""
    includeUnpublished: Boolean = false
  ): ProposalVoteConnection!

  """Get all medias the user has published."""
  medias: [Media]!

  """Get all votes of the user."""
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """The id of the contribuable entity (Project, Step)"""
    contribuableId: ID

    """Get only accounted votes."""
    onlyAccounted: Boolean = true
  ): VoteConnection!

  """Get all groups where the user is."""
  groups(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): GroupConnection!

  """Get all reports the user has done."""
  reports(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ReportConnection!

  """Return the user's contributions of the type requested."""
  contributions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for contributions returned from the connection."""
    orderBy: ContributionOrder = {field: CREATED_AT, direction: DESC}

    """Type of contribution requested"""
    type: ContributionType

    """Include the trashed contributions if its true"""
    includeTrashed: Boolean = false

    """The id of the contribuable entity (Project, Consultation, Step)"""
    contribuableId: ID
  ): ContributionConnection!

  """Is user subscribed to the proposal news posted by the author ?"""
  isSubscribedToProposalNews: Boolean!

  """Is user subscribed to the newsletter ?"""
  isSubscribedToNewsLetter: Boolean!

  """When the user subscribed to the newsletter."""
  subscribedToNewsLetterAt: DateTime

  """The new email to confirm ?"""
  newEmailToConfirm: String

  """Has the user confirmed his email address ?"""
  isEmailConfirmed: Boolean

  """When the user email confirmation was sent."""
  emailConfirmationSentAt: DateTime

  """The arguments created by user."""
  arguments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for contributions returned from the connection."""
    orderBy: ContributionOrder = {field: CREATED_AT, direction: DESC}

    """Include the trashed contributions if its true"""
    includeTrashed: Boolean = false

    """Include the unpublished contributions if its true"""
    includeUnpublished: Boolean = false
  ): ArgumentConnection!

  """The debate arguments created by user."""
  debateArguments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Ordering options for contributions returned from the connection."""
    orderBy: DebateArgumentOrder = {field: PUBLISHED_AT, direction: DESC}
  ): DebateArgumentConnection!

  """The debate votes of the user."""
  debateVotes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): DebateVoteConnection!
  isAdmin: Boolean!
  isSuperAdmin: Boolean!
  isProjectAdmin: Boolean!
  isOnlyProjectAdmin: Boolean!

  """Get any connection attempt"""
  connectionAttempt(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """Email of the user"""
    email: String

    """
    If true, returns only successful connection attempts /!\ only works with email, not userId
    """
    success: Boolean
  ): UserConnectionAttemptConnection

  """The opinion version created by user."""
  opinionVersions(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): VersionConnection!

  """The event in awaiting or refused status of user."""
  awaitingOrRefusedEvents(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): EventConnection

  """Get proposals assigned to the supervisor."""
  supervisedProposals(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): ProposalConnection

  """Locale chosen by the user"""
  locale: String

  """The event in awaiting status."""
  adminAwaitingEvents: Int!
  birthPlace: String
  isFranceConnectAccount: Boolean
  hasPassword: Boolean
}

"""A connection to a list of items."""
type UserConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """
  Identifies the total count of anonymous items in the connection. (Not fetched from connection)
  """
  anonymousCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [UserEdge]
}

"""A user connection attempt"""
type UserConnectionAttempt {
  """The ID of an object"""
  id: ID!

  """Identifies the user if successfully logged in"""
  user: User

  """Identifies the date and time when the object was created."""
  datetime: DateTime!

  """The email used for the connection attempt"""
  email: String!

  """The IP Address"""
  ipAddress: String!
}

"""A connection to a list of items."""
type UserConnectionAttemptConnection {
  totalCount: Int

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [UserConnectionAttemptEdge]
}

"""An edge in a connection."""
type UserConnectionAttemptEdge {
  """The item at the end of the edge."""
  node: UserConnectionAttempt!

  """A cursor for use in pagination."""
  cursor: String!
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User!

  """A cursor for use in pagination."""
  cursor: String!
}

"""A business-level error."""
type UserError {
  """The reason which caused the error."""
  message: String

  """Path to input field which caused the error."""
  field: [String!]
}

"""A user invitation"""
type UserInvite {
  """The ID of an object."""
  id: ID!

  """Get the invited email"""
  email: String!

  """Will the invited user be an admin?"""
  isAdmin: Boolean!

  """Will the invited user be a project admin?"""
  isProjectAdmin: Boolean!

  """The invitation status"""
  status: UserInviteStatus!

  """The groups associated to the invite"""
  groups: GroupConnection!
}

"""A connection to a list of items."""
type UserInviteConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [UserInviteEdge]
}

"""An edge in a connection."""
type UserInviteEdge {
  """The item at the end of the edge."""
  node: UserInvite

  """A cursor for use in pagination."""
  cursor: String!
}

"""The invitation status"""
enum UserInviteStatus {
  """If the invitation is pending"""
  PENDING

  """If the invitation is expired"""
  EXPIRED
}

"""A user's notifications configuration"""
type UserNotificationsConfiguration {
  """
  A boolean representing if the user wants to receive notifications by mail when someone commented his proposal
  """
  onProposalCommentMail: Boolean!
}

"""Ways in which lists of users can be ordered upon return."""
input UserOrder {
  """The field to order users by."""
  field: UserOrderField! = CREATED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Properties by which users connections can be ordered"""
enum UserOrderField {
  """Allows ordering a list of users by when they were created."""
  CREATED_AT

  """Allowing ordering a list of user by their activity."""
  ACTIVITY
}

"""4 possible values"""
enum UserRole {
  """Represents a user."""
  ROLE_USER

  """Represents a project admin."""
  ROLE_PROJECT_ADMIN

  """Represents an administrator."""
  ROLE_ADMIN

  """Represents Cap Collectif account."""
  ROLE_SUPER_ADMIN
}

"""A type of person"""
type UserType {
  """The id of the type."""
  id: ID!

  """The name of the type."""
  name: String!
}

"""A response"""
type ValueResponse implements Response {
  """Nullable ID in case of empty response."""
  id: String

  """The question."""
  question: Question!

  """The response value which can be a string or a JSON."""
  value: String

  """The response value formatted."""
  formattedValue: String
}

"""A version of contribution"""
type Version implements Node & Contribution & Publishable & Trashable & UniformResourceLocatable & Sourceable & Reportable & Argumentable & ContributionWithAuthor & EditableContribution {
  """The ID of an object"""
  id: ID!

  """
  Return the related contribution if the contribution is related to another.
  """
  related: Contribution

  """The URL to this resource."""
  url: URI!

  """Whether or not the contribution is trashed."""
  trashed: Boolean!

  """Identifies the trashed visibility."""
  trashedStatus: TrashableStatus

  """Identifies the moment the moderator trashed the contribution."""
  trashedAt: DateTime

  """Identifies the reason why the moderator trashed the contribution."""
  trashedReason: String

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason

  """Identifies the date and time when the object was last updated."""
  updatedAt: DateTime

  """Identifies the date and time when the object was created."""
  createdAt: DateTime!

  """Does the viewer already submitted a report ?"""
  viewerHasReport: Boolean!

  """Explenation."""
  comment: String

  """The title of the contribution."""
  title: String!

  """The content of the contribution."""
  body: HTML!

  """The content of the contribution."""
  bodyText: HTML!
  parent: Opinion!

  """The related project."""
  project: Project
  contribuable: Boolean!
  step: ConsultationStep!

  """The sources related to the sourceable."""
  sources(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: SourceOrder = {field: PUBLISHED_AT, direction: DESC}
  ): SourceConnection!

  """
  The viewer unpublished sources related to the sourceable (only visible by viewer).
  """
  viewerSourcesUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
  ): SourceConnection!

  """The available sources categories of to the sourceable."""
  availableSourceCategories: [SourceCategory]

  """The reportings related to the reportable."""
  reportings(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ReportingOrder = {field: CREATED_AT, direction: DESC}
  ): ReportingConnection!

  """Check if a user can report"""
  viewerCanReport: Boolean!

  """The arguments related to the argumentable."""
  arguments(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ArgumentOrder = {field: PUBLISHED_AT, direction: DESC}

    """If provided, returns the arguments of this particular type."""
    type: ArgumentValue

    """The connection will return the trashed results too."""
    includeTrashed: Boolean = false
  ): ArgumentConnection!

  """The unpublished arguments of to the viewer."""
  viewerArgumentsUnpublished(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100

    """If provided, returns the arguments of this particular type."""
    type: ArgumentValue
  ): ArgumentConnection

  """The author of the contribution."""
  author: User!

  """The opinion version's followers."""
  followers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: FollowerOrder = {field: FOLLOWED_AT, direction: DESC}
  ): FollowerConnection

  """The following viewer configuration."""
  viewerFollowingConfiguration: SubscriptionTypeValue

  """Either or not the viewer is following the content."""
  viewerIsFollowing: Boolean!
  votes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: String

    """Returns the first `n` elements from the list."""
    first: Int = 100
    orderBy: ProposalVoteOrder = {field: PUBLISHED_AT, direction: DESC}

    """Filters vote by value"""
    value: YesNoPairedVoteValue
  ): YesNoPairedVoteConnection!
  kind: String!

  """The section of the parent opinion."""
  section: Section!
  answer: Answer

  """The viewer vote."""
  viewerVote: OpinionVote
  diff: HTML
}

"""A connection to a list of items."""
type VersionConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [VersionEdge]
}

"""An edge in a connection."""
type VersionEdge {
  """The item at the end of the edge."""
  node: Version!

  """A cursor for use in pagination."""
  cursor: String!
}

"""Ways in which version connections can be ordered."""
input VersionOrder {
  """The field in which to order nodes by."""
  field: VersionOrderField!

  """The ordering direction."""
  direction: OrderDirection! = ASC
}

"""Properties by which version connections can be ordered"""
enum VersionOrderField {
  """Allows ordering a list of versions by when they were published."""
  PUBLISHED_AT

  """Allows ordering a list of versions by the number of votes it have."""
  VOTES

  """
  Allows ordering a list of versions by the number of arguments it have.
  """
  ARGUMENTS

  """Allows ordering a list of versions by the number of votes ok it have."""
  VOTES_OK

  """Allows ordering a list of versions randomly."""
  RANDOM
}

"""Entities that can be published."""
type VersionVote implements YesNoPairedVote & Publishable & Vote {
  """The ID of an object"""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution."""
  author: User

  """The contribution that was voted."""
  related: Contribution

  """Returns 'vote'."""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason
  value: YesNoPairedVoteValue!
}

interface Vote {
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution."""
  author: User

  """The contribution that was voted."""
  related: Contribution

  """Returns Type of vote"""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!
}

"""A connection to a list of items."""
type VoteConnection {
  """Identifies the total count of items in the connection."""
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [VoteEdge]
}

"""An edge in a connection."""
type VoteEdge {
  """The item at the end of the edge."""
  node: Vote

  """A cursor for use in pagination."""
  cursor: String!
}

"""A vote"""
input VoteInput {
  """The vote id."""
  id: ID!

  """Update the vote privacy."""
  anonymous: Boolean!
}

"""Ways in which lists of votes can be ordered upon return."""
input VoteOrder {
  """The field to order votes by."""
  field: VoteOrderField! = PUBLISHED_AT

  """The ordering direction."""
  direction: OrderDirection! = DESC
}

"""Ordering options for votes returned from the connection."""
enum VoteOrderField {
  PUBLISHED_AT
  POSITION
}

"""Entities that can be published."""
interface YesNoPairedVote {
  """The ID of an object"""
  id: ID!

  """The date of the vote."""
  createdAt: DateTime!

  """The author of the contribution."""
  author: User

  """The contribution that was voted."""
  related: Contribution

  """Returns Type of vote"""
  kind: String!

  """Returns if vote is accounted or not"""
  isAccounted: Boolean!

  """Whether or not the entity is published."""
  published: Boolean!

  """Identifies when the entity can no more be published."""
  publishableUntil: DateTime

  """Identifies when the entity was published at."""
  publishedAt: DateTime

  """Reason that the entity is not published."""
  notPublishedReason: NotPublishedReason
  value: YesNoPairedVoteValue!
}

"""A connection to a list of items."""
type YesNoPairedVoteConnection {
  totalCount: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [YesNoPairedVoteEdge]
}

"""An edge in a connection."""
type YesNoPairedVoteEdge {
  """The item at the end of the edge."""
  node: YesNoPairedVote

  """A cursor for use in pagination."""
  cursor: String!
}

"""3 possible values"""
enum YesNoPairedVoteValue {
  YES
  NO
  MITIGE
}
